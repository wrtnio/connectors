{
  "openapi": "3.1.0",
  "servers": [
    {
      "url": "https://studio-connector-api.wrtn.ai",
      "description": "Production Server"
    },
    {
      "url": "https://studio-connector-poc.dev.wrtn.club",
      "description": "Develop Server"
    },
    {
      "url": "http://localhost:3003",
      "description": "Local Server"
    }
  ],
  "info": {
    "version": "0.1.440",
    "title": "@wrtn/connector",
    "description": "wrtn-ecosystem connectors and sdk",
    "license": {
      "name": "AGPL-3.0-only"
    }
  },
  "paths": {
    "/connector/swal/articles/{id}/sync/dev-to": {
      "post": {
        "summary": "Syncronize article version",
        "description": "upgrade or downgrade version of exported dev.to\n\nSynchronize on a snapshot basis,\nsuch as upgrading or downgrading the version of a document exported to DevTo.\nIf user specify the id of the snapshot in the names from and to among the internal properties,\nfind the exported text from `from` and start synchronizing to the version of `to`.\nIf user want to revert to the past version of the snapshot,\nuser can put the current version in 'from' and the past version in 'to'.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target article's {@link IArticle.id }, Not snapshot ID"
          }
        ],
        "requestBody": {
          "description": "DevTo Secret and snapshot information to sync",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.ISync.ToDevToInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response of Synchronization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IArticle.ISync.ToDevToOutput"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "sync",
          "dev_to",
          "syncToDevTo"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "dev.to에 동기화해줘"
        ]
      }
    },
    "/connector/swal/articles/{id}/sync/google-docs": {
      "post": {
        "summary": "Syncronize article version",
        "description": "upgrade or downgrade version of exported google docs file\n\nSynchronize on a snapshot basis,\nsuch as upgrading or downgrading the version of a document exported to GoogleDocs.\nIf user specify the id of the snapshot in the names from and to among the internal properties,\nfind the exported text from `from` and start synchronizing to the version of `to`.\nIf user want to revert to the past version of the snapshot,\nuser can put the current version in 'from' and the past version in 'to'.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target article's {@link IArticle.id }, Not snapshot ID"
          }
        ],
        "requestBody": {
          "description": "GoogleDocs Secret and snapshot information to sync",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.ISync.ToGoogleDocsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response of Synchronization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IArticle.ISync.ToGoogleDocsOutput"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "sync",
          "google_docs",
          "syncToGoogleDocs"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "google docs에 동기화해줘"
        ]
      }
    },
    "/connector/swal/articles/{id}/sync/notion": {
      "post": {
        "summary": "Syncronize article version",
        "description": "upgrade or downgrade version of exported notion page\n\nSynchronize on a snapshot basis,\nsuch as upgrading or downgrading the version of a document exported to Notion.\nIf user specify the id of the snapshot in the names from and to among the internal properties,\nfind the exported text from `from` and start synchronizing to the version of `to`.\nIf user want to revert to the past version of the snapshot,\nuser can put the current version in 'from' and the past version in 'to'.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target article's {@link IArticle.id }, Not snapshot ID"
          }
        ],
        "requestBody": {
          "description": "Notion Secret and snapshot information to sync",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.ISync.ToNotionInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response of Synchronization",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IArticle.ISync.ToNotionOutput"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "sync",
          "notion",
          "syncToNotion"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "노션에 동기화해줘"
        ]
      }
    },
    "/connector/swal/articles/{id}/exports/dev-to": {
      "post": {
        "summary": "Exports specified article to dev_to",
        "description": "Export the text to Dev.to\n\nThe exported text is recorded by creating a\n{@link IArticleExport bbs_article_exports} object based on the snapshot.\nYou can upgrade and downgrade the version using\nthe 'POST /connector/swal/articles/:id/exports/sync/dev_to' connector in the future.\nAlso, it doesn't matter if you export the same version of the text multiple times.\n\nBecause each export generates a new text,\nyou must use the `sync` connector if you want to change the version of an already exported text.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target article's {@link IArticle.id }, Not snapshot ID"
          }
        ],
        "requestBody": {
          "description": "DevTo Secret and snapshot information to export",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.IExport.ToDevToInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Article Infomation and dev_to secretKey",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IArticle.IExport.ToDevToOutput"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "exports",
          "dev_to",
          "exportsToDevTo"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "dev.to로 내보내줘"
        ]
      }
    },
    "/connector/swal/articles/{id}/exports/google-docs": {
      "post": {
        "summary": "Exports specified article to google_docs",
        "description": "Export the text to GoogleDocs\n\nThe exported text is recorded by creating a\n{@link IArticleExport bbs_article_exports} object based on the snapshot.\nYou can upgrade and downgrade the version using\nthe 'POST /connector/swal/articles/:id/exports/sync/google_docs' connector in the future.\nAlso, it doesn't matter if you export the same version of the text multiple times.\n\nBecause each export generates a new text,\nyou must use the `sync` connector if you want to change the version of an already exported text.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target article's {@link IArticle.id }, Not snapshot ID"
          }
        ],
        "requestBody": {
          "description": "GoogleDocs Secret and snapshot information to export",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.IExport.ToGoogleDocsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Article Infomation and google_docs secretKey",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IArticle.IExport.ToGoogleDocsOutput"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "exports",
          "google_docs",
          "exportsToGoogleDocs"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "google docs로 내보내줘"
        ]
      }
    },
    "/connector/swal/articles/{id}/exports/notion": {
      "post": {
        "summary": "Exports specified article to notion",
        "description": "Export the text to Notion\n\nThe exported text is recorded by creating a\n{@link IArticleExport bbs_article_exports} object based on the snapshot.\nYou can upgrade and downgrade the version using\nthe 'POST /connector/swal/articles/:id/exports/sync/notion' connector in the future.\nAlso, it doesn't matter if you export the same version of the text multiple times.\n\nBecause each export generates a new text,\nyou must use the `sync` connector if you want to change the version of an already exported text.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target article's {@link IArticle.id }, Not snapshot ID"
          }
        ],
        "requestBody": {
          "description": "Notion Secret and snapshot information to export",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.IExport.ToNotionInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Article Infomation and notion secretKey",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IArticle.IExport.ToNotionOutput"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "exports",
          "notion",
          "exportsToNotion"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "notion으로 내보내줘"
        ]
      }
    },
    "/connector/swal/articles/{id}": {
      "patch": {
        "description": "Read an entire contents of article with its every snapshots\n\nAll text content that is not omitted is shown here, so you can also see how the text has been modified at once.\nThis connector reads an article with its every snapshots {@link IArticle.ISnapshot snapshots}\nThis detail contains the entire content created for each version of the document,\nas well as the connection information to the external services from which it was exported.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target article's {@link IArticle.id }, Not snapshot ID"
          }
        ],
        "responses": {
          "200": {
            "description": "Article Infomation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StrictOmitIArticleIArticle.ISnapshotpassword"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "at"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "글 내용 보여줘"
        ]
      },
      "delete": {
        "summary": "Remove an specified article",
        "description": "Erase an article\n\nPerforms soft deletion to the article.\nThis makes the article no longer available, regardless of the number of snapshots.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target article's {@link IArticle.id }, Not snapshot ID"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "remove"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "내 글 삭제해줘"
        ]
      },
      "put": {
        "summary": "Updates the specified article with new data",
        "description": "Update an existing article in the User Database\n\nThis function takes the updated article data as input and updates the corresponding\narticle record in the User Database. It uses the DocumentProvider to apply the changes.\nThe input must adhere to the structure defined by `IArticle.IUpdate`.\nReturns the updated document or the result of the update operation.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/articles",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true
          }
        ],
        "requestBody": {
          "description": "- The new data to update the article. It must match the `IArticle.IUpdate` type.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.IUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The result of the update operation from the DocumentProvider.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IArticle.ISnapshot"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "update"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "내 글 수정해줘"
        ]
      }
    },
    "/connector/swal/articles": {
      "patch": {
        "summary": "List up all summarized articles",
        "description": "List up all summarized articles with pagination and searching options\n\nBecause it is looking at the user's individual writing, user cannot inquire other than your own writing.\nBecause it is a call to a text stored in the connector server's own DB,\nit may be appropriate to call this connector if the user asks to call the text without saying the service name.\nIt is recommended that you first ask the user for the service name.\nIf you are asked to look up the text under the names of `Swal`, `Wrtn Technologies`, `Wrtn`, `user own DB`, `user DB`, etc., you should call this connector.\n\nA list of pageed articles will appear.\nThe article contains abbreviated body content, so you can infer what you have from the title and body.\n\nIf you want to see the full text instead of the omitted text,\nor if you want to see the history of this article being exported to Notion or other services,\nplease look up the details.\nHere, we only show the content of the text up to 100 characters, so if you want to see the latter, you need to look up the details.\nYou can view all the snapshots of this article if you want to look at them in detail.\nThe detailed lookup connector is 'PATCH connector/swal/articles/:id'.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Request info of pagination and searching options.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Paginated summarized articles.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IPageIArticle.ISummary"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "index"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "내 글 조회해줘"
        ]
      },
      "post": {
        "description": "Write Article to User Database\n\nPosts are managed in a snapshot-based structure, enabling rollback at any time.\nWhen a post is created, the system automatically generates the first snapshot.\nThe most recent snapshot reflects the current state of the post.\nBy editing the post or exporting it to external services, you can track which version—i.e., which snapshot—was exported and synchronize it using foreign keys.\nThis system is designed to efficiently handle any post-like documents, such as those from Google Docs, Notion, or Reddit.\nUsing Markdown as the standard format for writing and versioning, it identifies changes through a diff algorithm whenever edits are made.\nThis allows you to compare previous and current versions, track changes, and synchronize updates across services.\nAs these APIs store data exclusively in the Wrtn Technologies Ecosystem Team's database without relying on external APIs,\nthis setup serves as an ideal starting point for creating and managing documents efficiently with robust version control.\n\nIf the user asked to edit the text, it would most likely not be this connector.\nThere is a separate connector for the update, so please use it.\n\nIf the user asks you to write without any service names,\nyou may be referring to this connector.\nAsk the user to confirm.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Article Information to Create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IArticle.ICreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StrictOmitIArticleIArticle.ISnapshotpassword"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "articles",
          "write"
        ],
        "x-samchon-controller": "ArticleController",
        "x-wrtn-function-select-benchmarks": [
          "내 개인 DB에 글 좀 써줘"
        ]
      }
    },
    "/connector/swal/spreadsheets/{id}/exports/google-sheets": {
      "post": {
        "summary": "Exports specified spreadsheet to GoogleSheets",
        "description": "Export the spreadsheet to GoogleSheets\n\nThe exported spreadsheet is recorded by creating a\n{@link ISpreadsheetExport bbs_spreadsheet_exports} object based on the snapshot.\nYou can upgrade and downgrade the version using\nthe 'POST /connector/swal/spreadsheets/:id/exports/sync/google-sheets' connector in the future.\nAlso, it doesn't matter if you export the same version of the spreadsheet multiple times.\n\nBecause each export generates a new file,\nyou must use the `sync` connector if you want to change the version of an already exported file.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/spreadsheets",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target spreadsheet's {@link ISpreadsheet.id }, Not snapshot ID"
          }
        ],
        "requestBody": {
          "description": "GoogleSheets export configuration and snapshot information to export",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISpreadsheet.IExport.ToGoogleSheetsToInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Spreadsheet Information and GoogleSheets export details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISpreadsheet.IExport.ToGoogleSheetsToOutput"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "spreadsheets",
          "exports",
          "google_sheets",
          "exportsToGoogleSheets"
        ],
        "x-samchon-controller": "SpreadsheetController",
        "x-samchon-human": true
      }
    },
    "/connector/swal/spreadsheets/{id}/exports/excel": {
      "post": {
        "summary": "Exports specified spreadsheet to Excel",
        "description": "Export the spreadsheet to Excel\n\nThe exported spreadsheet is recorded by creating a\n{@link ISpreadsheetExport bbs_spreadsheet_exports} object based on the snapshot.\nYou can upgrade and downgrade the version using\nthe 'POST /connector/swal/spreadsheets/:id/exports/sync/excel' connector in the future.\nAlso, it doesn't matter if you export the same version of the spreadsheet multiple times.\n\nBecause each export generates a new file,\nyou must use the `sync` connector if you want to change the version of an already exported file.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/swal/spreadsheets",
                "jmesPath": "data[].{ value: id, label: snapshot.title }"
              }
            },
            "required": true,
            "description": " Target spreadsheet's {@link ISpreadsheet.id }, Not snapshot ID"
          }
        ],
        "requestBody": {
          "description": "Excel export configuration and snapshot information to export",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISpreadsheet.IExport.SnapshotInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Spreadsheet Information and Excel export details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISpreadsheet.IExport.ToExcelToOutput"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "spreadsheets",
          "exports",
          "excel",
          "exportsToExcel"
        ],
        "x-samchon-controller": "SpreadsheetController",
        "x-samchon-human": true
      }
    },
    "/connector/swal/spreadsheets/{id}": {
      "patch": {
        "summary": "Read individual detailed spreadsheet including full data",
        "description": "Read an entire contents of spreadsheet with its every snapshot\n\nAll data content that is not omitted is shown here, so you can also see how the spreadsheet has been modified over time.\nThis connector reads a spreadsheet with its every snapshot {@link ISpreadsheet.ISnapshot snapshots}.\nThis detailed view contains the full data created for each version of the spreadsheet,\nas well as the connection information to the external services to which it was exported.\n\nBy examining the snapshots, you can track changes made to the spreadsheet, compare versions, and understand its history.\nIf the user is interested in a specific version of the spreadsheet or wants to check its export history to external services like Google Sheets or Excel,\nthis connector is the correct choice.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "description": " Target spreadsheet's {@link ISpreadsheet.id }, Not snapshot ID"
          }
        ],
        "responses": {
          "200": {
            "description": "Spreadsheet Information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISpreadsheetISpreadsheet.ISnapshot"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "spreadsheets",
          "at"
        ],
        "x-samchon-controller": "SpreadsheetController",
        "x-samchon-human": true
      }
    },
    "/connector/swal/spreadsheets/{id}/cells": {
      "post": {
        "summary": "Insert or update cells in a spreadsheet (snapshot-based structure)",
        "description": "Insert or update cells in a spreadsheet\n\nThis connector allows adding or updating cells in an existing spreadsheet.\nThe spreadsheet is identified by its {@link ISpreadsheet.id}, and the input should include\nthe cell data to be inserted or updated.\n\nSpreadsheets in the system are managed as snapshots, meaning each update creates a new snapshot\nto preserve version history. Cells, like other spreadsheet components, are part of this snapshot\nstructure. This allows tracking changes to the spreadsheet over time and facilitates rollbacks or\ncomparisons between versions.\n\nWhen updating the spreadsheet, it modifies only the provided cells, leaving other\ncells unchanged. This is particularly useful for partial updates without altering the\nexisting structure or data in the spreadsheet.\n\nIf you want to create a new spreadsheet entirely, please use the `POST /connector/swal/spreadsheets` connector instead.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "format": "uuid"
            },
            "required": true,
            "description": " Target spreadsheet's {@link ISpreadsheet.id }"
          }
        ],
        "requestBody": {
          "description": "Contains the cells to be inserted or updated",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequiredPickISpreadsheet.ICreatecells"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Updated spreadsheet data after modifying the cells",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISpreadsheetISpreadsheet.ISnapshot"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "spreadsheets",
          "cells",
          "insertCells"
        ],
        "x-samchon-controller": "SpreadsheetController",
        "x-samchon-human": true
      }
    },
    "/connector/swal/spreadsheets": {
      "patch": {
        "summary": "List up all summarized spreadsheets",
        "description": "List up all summarized spreadsheets with pagination and searching options\n\nBecause it is looking at the user's individual spreadsheets, the user cannot inquire about spreadsheets other than their own.\nBecause it is a call to data stored in the connector server's own DB,\nit may be appropriate to call this connector if the user asks to call the data without saying the service name.\nIt is recommended that you first ask the user for the service name.\nIf you are asked to look up the spreadsheets under the names of `Swal`, `Wrtn Technologies`, `Wrtn`, `user own DB`, `user DB`, etc., you should call this connector.\n\nA list of paged spreadsheets will appear.\nThe spreadsheet contains abbreviated data previews, so you can infer its contents from the title and preview.\n\nIf you want to see the full data instead of the abbreviated preview,\nor if you want to see the history of this spreadsheet being exported to Google Sheets or other services,\nplease look up the details.\nHere, we only show a preview of the data up to 100 cells, so if you want to see the latter, you need to look up the details.\nYou can view all the snapshots of this spreadsheet if you want to look at them in detail.\nThe detailed lookup connector is 'PATCH connector/swal/spreadsheets/:id'.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Request info of pagination and searching options.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISpreadsheet.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Paginated summarized spreadsheets.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IPageISpreadsheet.ISummary"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "spreadsheets",
          "index"
        ],
        "x-samchon-controller": "SpreadsheetController",
        "x-samchon-human": true
      },
      "post": {
        "summary": "Create Spreadsheet",
        "description": "Create Spreadsheet in User Database\n\nSpreadsheets are managed in a snapshot-based structure, enabling rollback at any time.\nWhen a spreadsheet is created, the system automatically generates the first snapshot.\nThe most recent snapshot reflects the current state of the spreadsheet.\nBy editing the spreadsheet or exporting it to external services, you can track which version—i.e., which snapshot—was exported and synchronize it using foreign keys.\nThis system is designed to efficiently handle any spreadsheet-like documents, such as those from Google Sheets, Excel, or Airtable.\nUsing a structured data format as the standard for writing and versioning, it identifies changes through a diff algorithm whenever edits are made.\nThis allows you to compare previous and current versions, track changes, and synchronize updates across services.\nAs these APIs store data exclusively in the Wrtn Technologies Ecosystem Team's database without relying on external APIs,\nthis setup serves as an ideal starting point for creating and managing spreadsheets efficiently with robust version control.\n\nIf the user asked to edit the spreadsheet, it would most likely not be this connector.\nThere is a separate connector for the update, so please use it.\n\nIf the user asks you to create a spreadsheet without any service names,\nyou may be referring to this connector.\nAsk the user to confirm.\n\nPlease insert the correct data without omitting the data or adding the phrase that you have omitted it.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Spreadsheet Information to Create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISpreadsheet.ICreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISpreadsheetISpreadsheet.ISnapshot"
                }
              }
            }
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "x-samchon-accessor": [
          "connector",
          "swal",
          "spreadsheets",
          "create"
        ],
        "x-samchon-controller": "SpreadsheetController",
        "x-samchon-human": true
      }
    },
    "/connector/marketing-copy/generate-copy": {
      "post": {
        "summary": "Generate marketing copy",
        "description": "Generates marketing copy from given input",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Input for generating marketing copy",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMarketingCopyGenerator.IGenerateMarketingCopyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Generated marketing copy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPartialIMarketingCopyComponents"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "marketing_copy",
          "generate_copy",
          "generateCopy"
        ],
        "x-samchon-controller": "MarketingCopyController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Marketing_full.svg"
      }
    },
    "/connector/marketing-copy/generate-copy-image": {
      "post": {
        "summary": "Generate a marketing copy image",
        "description": "Generates a marketing copy image from the given input",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Input for generating a marketing copy image",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMarketingCopyGenerator.IGenerateMarketingCopyImageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Generated marketing copy image",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMarketingCopyImage"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "marketing_copy",
          "generate_copy_image",
          "generateCopyImage"
        ],
        "x-samchon-controller": "MarketingCopyController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Marketing_full.svg"
      }
    },
    "/connector/rag/analyze": {
      "post": {
        "summary": "Request RAG analysis",
        "description": "Request RAG analysis for the input file\n\nThis connector can be used when creating a chatbot that compares multiple research papers.",
        "tags": [
          "RAG"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information about the file to be analyzed",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IRag.IAnalyzeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IRag.IAnalysisOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "rag",
          "analyze"
        ],
        "x-samchon-controller": "RagController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/RAG_full.svg"
      }
    },
    "/connector/rag/generate/{chatId}": {
      "post": {
        "summary": "Generate RAG-based results",
        "description": "Generates requested results based on RAG analysis\n\nA connector that can be used to generate answers to user questions through a chatbot that compares multiple research papers.",
        "tags": [
          "RAG"
        ],
        "parameters": [
          {
            "name": "chatId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IRag.IGenerateInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IRag.IGenerateOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "rag",
          "generate"
        ],
        "x-samchon-controller": "RagController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/RAG_full.svg"
      }
    },
    "/connector/hwp/parse": {
      "post": {
        "summary": "Parse the Hwp file",
        "description": "Parse the hwp file",
        "tags": [
          "Hwp"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The hwp file to parse",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IHwp.IParseInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The parsed hwp file text data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IHwp.IParseOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "hwp",
          "parse",
          "parseHwp"
        ],
        "x-samchon-controller": "HwpController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/HWP_full.svg"
      }
    },
    "/connector/excel/read/headers": {
      "patch": {
        "summary": "Get the headers in the Excel file",
        "description": "Based on the input file information, the headers of the corresponding Excel file are retrieved",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "File information to read",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IReadExcelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "excel",
          "read",
          "headers",
          "readHeaders"
        ],
        "x-samchon-controller": "ExcelController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg",
        "x-wrtn-function-select-benchmarks": [
          "엑셀 헤더 읽어줘"
        ]
      }
    },
    "/connector/excel/read": {
      "patch": {
        "summary": "Get the contents of the Excel file",
        "description": "Get the contents of the corresponding Excel file based on the input file information",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information on the Excel file to get the contents",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IReadExcelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IReadExcelOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "excel",
          "read",
          "read"
        ],
        "x-samchon-controller": "ExcelController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg",
        "x-wrtn-function-select-benchmarks": [
          "엑셀 읽어줘"
        ]
      }
    },
    "/connector/excel/worksheet": {
      "patch": {
        "summary": "Get a list of Excel worksheets",
        "description": "Get a list of Excel worksheets that exist in the input file url",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The url of the Excel file from which to get the list of worksheets",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IGetWorksheetListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of Excel worksheets.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IWorksheetListOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "excel",
          "worksheet",
          "worksheetList"
        ],
        "x-samchon-controller": "ExcelController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg"
      }
    },
    "/connector/excel/rows/upload": {
      "post": {
        "summary": "Create Excel and add data by uploading Excel files",
        "description": "Upload an Excel file to add data to the file\n\nWhen adding data to Excel, sheet creation precedes if it is a sheet that does not exist yet.\nTherefore, this feature can also be used for sheet creation.\nIf you want to create a sheet only and create an empty file without any data,\nyou just need to specify the name of the sheet without any data.\n\nWhen adding rows to an already existing sheet,\nit is supposed to be added to the lower line, so it is recommended to check the data before adding it.\nIf you provide fileUrl, you can modify it after you work on it. After modification, the file will be issued as a new link.\n\nIt is a connector that allows users to upload files by drag and drop.",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for adding new data to Excel files",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IInsertExcelRowByUploadInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IExportExcelFileOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "excel",
          "rows",
          "upload",
          "insertRowsByUpload"
        ],
        "x-samchon-controller": "ExcelController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg",
        "x-wrtn-function-select-benchmarks": [
          "엑셀 데이터 올려줘"
        ]
      }
    },
    "/connector/excel/rows": {
      "post": {
        "summary": "엑셀 파일 링크를 가지고 액셀 생성 및 데이터 추가",
        "description": "Add data to the Excel file with an Excel file link\n\nWhen adding data to Excel, sheet creation precedes if it is a sheet that does not exist yet.\nTherefore, this feature can also be used for sheet creation.\nIf you want to create a sheet only and create an empty file without any data,\nyou just need to specify the name of the sheet without any data.\n\nWhen adding rows to an already existing sheet,\nit is supposed to be added to the lower line, so it is recommended to check the data before adding it.\nIf you provide fileUrl, you can modify it after you work on it. After modification, the file will be issued as a new link.\n\nA connector that allows you to update a file without uploading it if you know the link to the file in the previous utterance, or if you receive a file link in the utterance from the user.\n\nSince a link to the Excel file generated immediately after the Excel file is generated, calling this connector is more advantageous in terms of user experience than adding data through upload.",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "엑셀 파일에 새로운 데이터를 추가 하기 위한 정보",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IInsertExcelRowInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IExportExcelFileOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "excel",
          "rows",
          "insertRows"
        ],
        "x-samchon-controller": "ExcelController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg",
        "x-wrtn-function-select-benchmarks": [
          "엑셀 데이터 추가해줘"
        ]
      }
    },
    "/connector/excel": {
      "post": {
        "summary": "Add Excel files and sheet",
        "description": "Add Excel files and sheet\n\nCreate an Excel file and get the link back.\nYou can also forward this link to the following connector to reflect further modifications.\nWhen creating a sheet with this feature, the default name 'Sheet1' is created if the sheet name is not provided.",
        "deprecated": true,
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.ICreateSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IExportExcelFileOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "excel",
          "createSheets"
        ],
        "x-samchon-controller": "ExcelController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg",
        "x-wrtn-function-select-benchmarks": [
          "엑셀 파일 만들어줘",
          "엑셀 생성해줘"
        ]
      }
    },
    "/connector/google-docs/markdown": {
      "post": {
        "summary": "Write Google Docs by markdown format string",
        "description": "Generate Google Docs By markdown format string\n\nCreate a document with a markdown, which is the ID of the markdown file and the ID of the document.\nIn the case of Google Docs, URLs are included, so you can open and inquire files directly based on your ID.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Google Docs infomation to write",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Created Google Docs and markdown File ids",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.IResponse"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "markdown",
          "write"
        ],
        "x-samchon-controller": "GoogleDocsController"
      }
    },
    "/connector/google-docs/contents": {
      "delete": {
        "summary": "erase the entire contents of a file and make it an empty file",
        "description": "Remove entire contents of google docs\n\nMake Google Docs a blank file like you just created.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Google Drive and Docs Secret Key and information to clear file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.IClearInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.IClearOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "contents",
          "clear"
        ],
        "x-samchon-controller": "GoogleDocsController"
      }
    },
    "/connector/google-docs": {
      "post": {
        "summary": "Generate Google Docs",
        "description": "Generate Google Docs\n\nSince this is creating a blank page, we recommend that you use\nconnectors that add the content of google-docs in a row.\nAlternatively, we recommend using a different connector because\nthere are other connectors that have the ability to generate\ndocuments with markdown.",
        "deprecated": true,
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Title of Google Docs to generate",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ICreateGoogleDocsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Unique ID of generated Google Docs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.ICreateEmptyFileOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "createDocs"
        ],
        "x-samchon-controller": "GoogleDocsController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg",
        "x-wrtn-standalone": true,
        "x-samchon-human": true
      }
    },
    "/connector/google-docs/permission": {
      "post": {
        "summary": "Grant permission to Google Docs",
        "description": "Grant permission to Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for granting permission to Google Docs",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.IPermissionGoogleDocsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "permission"
        ],
        "x-samchon-controller": "GoogleDocsController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/connector/google-docs/get/{id}": {
      "patch": {
        "summary": "Read Google Docs",
        "description": "Read the contents of Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-docs/get-list",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "description": " Google Docs unique ID"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Google Docs contents",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.IReadGoogleDocsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "get",
          "readDocs"
        ],
        "x-samchon-controller": "GoogleDocsController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/connector/google-docs/template": {
      "post": {
        "summary": "Copy Google Docs",
        "description": "Create new Google Docs by copying existing Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Links to Google Docs to copy and titles of Google Docs to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ICreateDocByTemplateInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Unique ID of the generated Google Docs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.ICreateDocByTemplateOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "template",
          "createDocByTemplate"
        ],
        "x-samchon-controller": "GoogleDocsController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/connector/google-docs/{id}": {
      "put": {
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-docs/get-list",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "description": " Google Docs File ID to update"
          }
        ],
        "requestBody": {
          "description": "Google Secret Key and information to update google docs",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/IGoogleDocs.IUpdateTitleInput"
                  },
                  {
                    "$ref": "#/components/schemas/IGoogleDocs.IUpdateContentInput"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Updated Google Docs file info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.IUpdateOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "update"
        ],
        "x-samchon-controller": "GoogleDocsController"
      },
      "delete": {
        "summary": "Delete Google Docs",
        "description": "Delete Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-docs/get-list",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the Google Docs to delete"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "deleteById"
        ],
        "x-samchon-controller": "GoogleDocsController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/connector/google-docs/get-list": {
      "patch": {
        "summary": "Get a list of Google Docs",
        "description": "Get a list of Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "a list of Google Docs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.IListGoogleDocsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "get_list",
          "list"
        ],
        "x-samchon-controller": "GoogleDocsController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-docs/append": {
      "post": {
        "summary": "Add text to Google Docs",
        "description": "Add text to Google Docs\n\nWhen you pass the input of the markdown format, change the markdown to the appropriate format.\nIt is recommended to check the existing content\nand then use the `update` connector to include the existing content,\nin the case of the 'append' connector, it is not fully Markdown compatible.\nUpdate connector is `PUT /connector/google-docs/:id`.",
        "deprecated": true,
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.IAppendTextGoogleDocsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.ICreateGoogleDocsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_docs",
          "append"
        ],
        "x-samchon-controller": "GoogleDocsController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg",
        "x-samchon-human": true
      }
    },
    "/connector/google-sheet": {
      "patch": {
        "summary": "Get the header information of a Google Sheet",
        "description": "Get the header information of a Google Sheet",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Google Sheet URL and the header index to get",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetHeadersInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Google Sheet header information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_sheet",
          "getHeaders"
        ],
        "x-samchon-controller": "GoogleSheetController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/append": {
      "post": {
        "summary": "Add content to Google Sheets",
        "description": "Add content to Google Sheets",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information to add content",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IAppendToSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.ICreateGoogleSheetOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_sheet",
          "append",
          "appendGoogleSheet"
        ],
        "x-samchon-controller": "GoogleSheetController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg"
      }
    },
    "/connector/google-sheet/create": {
      "post": {
        "summary": "Create a Google Sheet",
        "description": "Create a Google Sheet\n\nThe created sheet will be created in the Google Drive root path.",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The title of the sheet to be created",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.ICreateGoogleSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created sheet id and Url",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.ICreateGoogleSheetOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_sheet",
          "create",
          "createGoogleSheet"
        ],
        "x-samchon-controller": "GoogleSheetController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/permission": {
      "post": {
        "summary": "Grant permissions to Google Sheets",
        "description": "Grant permissions to Google Sheets",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for granting permissions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IPermissionInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_sheet",
          "permission"
        ],
        "x-samchon-controller": "GoogleSheetController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/header": {
      "post": {
        "summary": "Add a Google Sheet header",
        "description": "Add a header to a Google Sheet",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The Google Sheet url and the header name to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IWriteGoogleSheetHeadersInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_sheet",
          "header",
          "writeHeaders"
        ],
        "x-samchon-controller": "GoogleSheetController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/worksheet": {
      "patch": {
        "summary": "Get a list of Google Sheets Worksheets",
        "description": "Get a list of Google Worksheets",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The Google Sheets url to get the list of worksheets",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IGetWorkSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.IGetWorkSheetOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_sheet",
          "worksheet",
          "getWorkSheet"
        ],
        "x-samchon-controller": "GoogleSheetController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/get-rows": {
      "patch": {
        "summary": "Get Row information from Google Sheets",
        "description": "Get Row information from Google Sheets",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetRowsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Row information from Google Sheets",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetRowsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_sheet",
          "get_rows",
          "readRows"
        ],
        "x-samchon-controller": "GoogleSheetController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-calendar/get-list": {
      "patch": {
        "summary": "Get a list of Google Calendars",
        "description": "Get a list of Google Calendars",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of Google Calendars",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "get_list",
          "readCalenders"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "캘린더 리스트 조회해줘"
        ]
      }
    },
    "/connector/google-calendar": {
      "post": {
        "summary": "Create a Google Calendar",
        "description": "Create a Google Calendar",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The title of the calendar to be created",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ICreateCalendarInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The unique ID of the calendar and the title of the calendar",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "createCalendar"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "구글 새 캘린더 만들어줘"
        ]
      }
    },
    "/connector/google-calendar/{calendarId}": {
      "delete": {
        "summary": "Delete a Google Calendar",
        "description": "Delete a calendar",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "description": " The unique ID of the calendar to delete"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "deleteCalendar"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "구글 캘린더 중 이거 삭제해줘"
        ]
      }
    },
    "/connector/google-calendar/{calendarId}/get-events": {
      "patch": {
        "summary": "Get a list of Google Calendar events",
        "description": "Get a list of events in Google Calendar",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the calendar to get the list of events"
          }
        ],
        "requestBody": {
          "description": "Condition to get the list of events",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.IReadGoogleCalendarEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of Google Calendar events",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IReadGoogleCalendarEventOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "get_events",
          "readEvents"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "내 구글 캘린더에 등록된 일정 좀 봐줘"
        ]
      }
    },
    "/connector/google-calendar/{calendarId}/quick-event": {
      "post": {
        "summary": "Add a quick event to Google Calendar",
        "description": "Add a quick event to Google Calendar",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the calendar to add the event to"
          }
        ],
        "requestBody": {
          "description": "Unique ID of the calendar to add the event to, and the event name",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ICreateQuickEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "quick_event",
          "createQuickEvent"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "구글 캘린더에 퀵 이벤트 하나 생성해줘"
        ]
      }
    },
    "/connector/google-calendar/{calendarId}/event": {
      "post": {
        "summary": "Add a Google Calendar event",
        "description": "Add an event to Google Calendar",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the calendar to add the event to"
          }
        ],
        "requestBody": {
          "description": "Information for adding the event",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.IEventRequestBodyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information about the added event",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "event",
          "createEvent"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "구글 캘린더에 이벤트 하나 생성해줘"
        ]
      }
    },
    "/connector/google-calendar/{calendarId}/event/{eventId}": {
      "put": {
        "summary": "Modify a Google Calendar event",
        "description": "Modify an event",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the calendar that contains the event"
          },
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/{calendarId}/get-events",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the event to modify"
          }
        ],
        "requestBody": {
          "description": "The event information to update",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.IEventRequestBodyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated event information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "event",
          "updateEvent"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "구글 캘린더에 이벤트 하나 수정해줘"
        ]
      },
      "delete": {
        "summary": "Delete a Google Calendar event",
        "description": "Delete an event",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "description": " The unique ID of the calendar that contains the event"
          },
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/{calendarId}/get-events",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "description": " The unique ID of the event to delete"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "event",
          "deleteEvent"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "구글 캘린더에 일정 지워줘"
        ]
      }
    },
    "/connector/google-calendar/{calendarId}/event/{eventId}/attendees": {
      "put": {
        "summary": "Add attendees to a Google Calendar event",
        "description": "Add attendees to an event",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the calendar where the event is"
          },
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-calendar/{calendarId}/get-events",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the event to add attendees to"
          }
        ],
        "requestBody": {
          "description": "List of email addresses of attendees to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.IAddAttendeesToEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Event information with attendees added",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_calendar",
          "event",
          "attendees",
          "addAttendeesToEvent"
        ],
        "x-samchon-controller": "GoogleCalendarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "구글 캘린더에 이벤트 참석자 추가해줘"
        ]
      }
    },
    "/connector/google-drive/get/folders": {
      "patch": {
        "summary": "Get a list of Google Drive folders",
        "description": "Get a list of folders in Google Drive",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of Google Drive folders",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.IFolderListGoogleDriveOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_drive",
          "get",
          "folders",
          "folderList"
        ],
        "x-samchon-controller": "GoogleDriveController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "구글 드라이브에 폴더 목록 좀 봐줘"
        ]
      }
    },
    "/connector/google-drive/get/files": {
      "patch": {
        "summary": "Get a list of Google Drive files",
        "description": "Get a list of files in Google Drive",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.IFileListGoogleDriveInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of Google Drive files",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.IFileListGoogleDriveOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_drive",
          "get",
          "files",
          "fileList"
        ],
        "x-samchon-controller": "GoogleDriveController",
        "x-wrtn-function-select-benchmarks": [
          "드라이브에 파일 좀 조회해줘",
          "드라이브에 파일 좀 찾아줘"
        ],
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg"
      }
    },
    "/connector/google-drive/folder": {
      "post": {
        "summary": "Create a Google Drive folder",
        "description": "Create a new folder in Google Drive",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The name of the folder to be created",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ICreateFolderGoogleDriveInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The unique ID of the created folder",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.ICreateFolderGoogleDriveOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_drive",
          "folder",
          "createFolder"
        ],
        "x-samchon-controller": "GoogleDriveController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "드라이브에 폴더 좀 생성해줘"
        ]
      }
    },
    "/connector/google-drive/file": {
      "post": {
        "summary": "Create a Google Drive file",
        "description": "Create a new file in Google Drive",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The name of the file to be created and the unique ID of the folder where the file will be created",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.IUploadFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The unique ID of the created file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.ICreateFileGoogleDriveOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_drive",
          "file",
          "createFile"
        ],
        "x-samchon-controller": "GoogleDriveController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "드라이브에 파일 좀 생성해줘"
        ]
      }
    },
    "/connector/google-drive/file/{id}": {
      "delete": {
        "summary": "Delete a Google Drive file",
        "description": "Delete a file in Google Drive",
        "tags": [
          "Google Drive"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-drive/get/files",
                "jmesPath": "data[].{value: id || '', label: name || ''}"
              }
            },
            "required": true,
            "description": " The unique ID of the file to be deleted"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_drive",
          "file",
          "deleteFile"
        ],
        "x-samchon-controller": "GoogleDriveController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "드라이브에 파일 좀 삭제해줘"
        ]
      }
    },
    "/connector/google-drive/folder/{id}": {
      "delete": {
        "summary": "Delete a Google Drive folder",
        "description": "Delete a folder in Google Drive",
        "tags": [
          "Google Drive"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-drive/get/folders",
                "jmesPath": "data[].{value: id || '', label: name || ''}"
              }
            },
            "required": true,
            "description": " The unique ID of the folder to be deleted"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_drive",
          "folder",
          "deleteFolder"
        ],
        "x-samchon-controller": "GoogleDriveController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "드라이브에 폴더 좀 삭제해줘"
        ]
      }
    },
    "/connector/google-drive/permission": {
      "post": {
        "summary": "Grant Google Drive permission",
        "description": "Grants permission to access a file or folder",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for granting permission",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.IPermissionGoogleDriveInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_drive",
          "permission"
        ],
        "x-samchon-controller": "GoogleDriveController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "드라이브 폴더에 접근 권한 좀 설정해줘",
          "드라이브 파일에 접근 권한 좀 설정해줘"
        ]
      }
    },
    "/connector/google-drive/get/file/{id}": {
      "patch": {
        "summary": "Read text from a Google Drive file",
        "description": "Read text from a file",
        "tags": [
          "Google Drive"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/google-drive/get/files",
                "jmesPath": "data[].{value: id || '', label: name || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the file"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The text content of the file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.IGetFileOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_drive",
          "get",
          "file",
          "readFile"
        ],
        "x-samchon-controller": "GoogleDriveController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "드라이브 파일에 텍스트 좀 읽어줘"
        ]
      }
    },
    "/connector/gmail/send": {
      "post": {
        "summary": "GMAIL Send",
        "description": "Sending mail\n\nGmail is a free web-based email service provided by Google.\n\nThis connector is for sending emails,\nand if you send it as simple text, the sentences will be displayed as one long line, so you need to insert a line break character.\nThe current format uses `text/html; charset=utf-8` as content-type.\nIn some cases, you can use the HTML format.\n\nIf you want to attach a file, you must specify the name of the file and the address at which it is stored.\nThe saved file is read as a GET request inside the function, encoded, and processed.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information needed to send an email.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ICreateMailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "ID of the sent email.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.ISendMailOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "send"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "지메일 보내줘",
          "메일 보내줘"
        ]
      }
    },
    "/connector/gmail/draft": {
      "post": {
        "summary": "Create GMAIL Draft",
        "description": "Create a mail draft\n\nGmail is a free web-based email service provided by Google.\n\nThis connector is for sending emails,\nand if you send it as simple text, the sentences will be displayed as one long line, so you need to insert a line break character.\nThe current format uses `text/html; charset=utf-8` as content-type.\nIn some cases, you can use the html format.\n\nIf you want to attach a file, you must specify the name of the file and the address at which it is stored.\nThe saved file is read as a GET request inside the function, encoded, and processed.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for creating a mail draft.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ICreateMailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "draft"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "메일 초안 생성해줘"
        ]
      }
    },
    "/connector/gmail/reply/{id}": {
      "post": {
        "summary": "GMAIL Reply",
        "description": "Reply to received email\n\nGmail is a free web-based email service provided by Google.\n\nThis connector is for sending emails,\nand if you send it as simple text, the sentences will be displayed as one long line, so you need to insert a line break character.\nThe current format uses `text/html; charset=utf-8` as content-type.\nIn some cases, you can also use the HTML format.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true
          }
        ],
        "requestBody": {
          "description": "Information required for replying to emails.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IReplyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.ISendMailOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "reply"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "지메일 온 거 답장해줘"
        ]
      }
    },
    "/connector/gmail/get/{id}": {
      "patch": {
        "summary": "Get GMAIL information",
        "description": "Get information about a mail\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the email",
            "description": " Unique ID of the email."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Information about the email.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.IFindGmailOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "get",
          "findEmail"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "메일 상세 조회해줘"
        ]
      }
    },
    "/connector/gmail/read-list": {
      "patch": {
        "summary": "Get GMAIL list",
        "description": "Get mailing list\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for getting mailing list",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IFindEmailListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Mailing list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.IFindGmailListOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "read_list",
          "findEmails"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "메일 목록 조회해줘"
        ]
      }
    },
    "/connector/gmail/{id}/hardDelete": {
      "delete": {
        "summary": "Delete mail",
        "description": "Delete mail\n\nGmail is a free web-based email service provided by Google.\n\nThis function requires special attention because it permanently deletes mail instead of moving it to the trash.\n\nMost users will want to delete mail that is already in the trash.\n\nTherefore, if the user wants to delete it, it is better to guide them to move the mail to the trash, but if they still want to delete it, it is right to target the trash.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "hardDelete"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "Gmail에서 메일 하나만 삭제해줘"
        ]
      }
    },
    "/connector/gmail/{id}": {
      "delete": {
        "summary": "Delete GMAIL",
        "description": "Move mail to trash\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true,
            "description": " The unique ID of the email to be deleted"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "removeMail"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "메일 삭제해줘"
        ]
      }
    },
    "/connector/gmail/label": {
      "post": {
        "summary": "Create GMAIL label",
        "description": "Create a label\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for creating a label",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ILabelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Unique ID of the created label",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.ILabelOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "label",
          "createLabel"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "메일 라벨 생성해줘"
        ]
      }
    },
    "/connector/gmail/label/{mailId}": {
      "post": {
        "summary": "GMAIL Label Assignment",
        "description": "Assign a label to a mail\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "mailId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the mail to assign a label to"
          }
        ],
        "requestBody": {
          "description": "A list of unique IDs of labels to assign",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IMailLabelOperationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "label",
          "addLabelToMail"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "메일에 라벨링해줘"
        ]
      },
      "delete": {
        "summary": "Remove GMAIL labels",
        "description": "Remove labels assigned to mail\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "mailId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the mail from which to remove labels",
            "description": " Unique ID of the mail from which to remove labels."
          }
        ],
        "requestBody": {
          "description": "A list of unique IDs of labels to remove.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IMailLabelOperationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "label",
          "removeLabelFromMail"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "메일에 라벨 제거해줘"
        ]
      }
    },
    "/connector/gmail": {
      "delete": {
        "summary": "Delete multiple mails",
        "description": "Delete multiple mails\n\nGmail is a free web-based email service provided by Google.\nThis function requires special attention because it permanently deletes mail instead of moving it to the trash.\nMost users will want to delete mail that is already in the trash.\nTherefore, if the user wants to delete it, it is better to guide them to move the mail to the trash, but if they still want to delete it, it is right to target the trash.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IDeleteMailListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "gmail",
          "deleteMailList"
        ],
        "x-samchon-controller": "GmailController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "메일 삭제해줘"
        ]
      }
    },
    "/connector/hancell/sheet": {
      "post": {
        "summary": "Modify Hansel",
        "description": "Modify a Hansel sheet\n\nIf the sheet already exists, modify it, or add it if it did not exist before.",
        "tags": [
          "Hancel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Hansel information to modify",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IHancell.IUpsertSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Link to the newly created file after modification",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IHancell.IUpsertSheetOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "hancell",
          "sheet",
          "upsertSheet"
        ],
        "x-samchon-controller": "HancellController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Hancel_full.svg"
      }
    },
    "/connector/hancell/read": {
      "patch": {
        "summary": "Read a Hansel file",
        "description": "Read a Hansel file",
        "tags": [
          "Hancel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Hansel file information to read",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IHancell.IReadHancellInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Hansel file information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IHancell.IReadHancellOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "hancell",
          "read"
        ],
        "x-samchon-controller": "HancellController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Hancel_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-map/search": {
      "patch": {
        "summary": "Kakao Map Search",
        "description": "Search with Kakao Map\n\nIn addition to the place name company, category, and phone number,\nit also provides lot number and road name addresses in the Korean address system.\nIt can be used with public data or other address-based connectors.",
        "tags": [
          "Kakao Map"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search condition",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoMap.SearchByKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoMap.SearchByKeywordOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "kakao_map",
          "search"
        ],
        "x-samchon-controller": "KakaoMapController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/KakaoMap_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/dall-e-3/generate": {
      "post": {
        "summary": "dall-e-3 image generator node",
        "description": "Generate an image using the dall-e-3 model",
        "tags": [
          "Dall-e-3"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for image generation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDallE3.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "URL of the generated image",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDallE3.IResponse"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "dall_e_3",
          "generate",
          "generateImage"
        ],
        "x-samchon-controller": "DallE3Controller",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Dall-e3_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "dall-e로 그림 그려줘"
        ]
      }
    },
    "/connector/google-search": {
      "patch": {
        "summary": "Google search",
        "description": "Search Google for the search term you entered",
        "tags": [
          "Google Search"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Google search terms",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Google search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_search",
          "search"
        ],
        "x-samchon-controller": "GoogleSearchController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSearch_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "구글 검색 좀 해줘"
        ]
      }
    },
    "/connector/google-search/wanted": {
      "patch": {
        "summary": "Wanted job posting search",
        "description": "Search for job postings on Wanted",
        "tags": [
          "Wanted"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Wanted job posting search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_search",
          "wanted",
          "searchForWanted"
        ],
        "x-samchon-controller": "GoogleSearchCareerController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/_wanted_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "원티드에서 채용 공고 좀 찾아줘"
        ]
      }
    },
    "/connector/google-search/incruit": {
      "patch": {
        "summary": "Search Incruit job postings",
        "description": "Search for job postings on Incruit",
        "tags": [
          "Incruit"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results for Incruit job postings",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_search",
          "incruit",
          "searchForIncruit"
        ],
        "x-samchon-controller": "GoogleSearchCareerController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Incruit_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "인크루트에서 채용 공고 좀 찾아줘"
        ]
      }
    },
    "/connector/google-search/saramin": {
      "patch": {
        "summary": "Search for Saramin job postings",
        "description": "Search for job postings in Saramin",
        "tags": [
          "Saramin"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search for Saramin job postings results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_search",
          "saramin",
          "searchForSaramin"
        ],
        "x-samchon-controller": "GoogleSearchCareerController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Saramin_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "사람인에서 채용 공고 좀 찾아줘"
        ]
      }
    },
    "/connector/google-search/jumpit": {
      "patch": {
        "summary": "Jumpfit job posting search",
        "description": "Search for job postings on Jumpfit",
        "tags": [
          "Jumpit"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Jumpfit job posting search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_search",
          "jumpit",
          "searchForJumpit"
        ],
        "x-samchon-controller": "GoogleSearchCareerController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/jumpit_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "점핏에서 채용 공고 좀 찾아줘"
        ]
      }
    },
    "/connector/google-search/careerly": {
      "patch": {
        "summary": "Careerly Search",
        "description": "Search for posts in Careerly",
        "tags": [
          "Careerly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Careerly Post Search Results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_search",
          "careerly",
          "searchForCareerly"
        ],
        "x-samchon-controller": "GoogleSearchCareerController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/careerly_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "커리어리에서 채용 공고 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/aladine": {
      "patch": {
        "summary": "Aladdin Search",
        "description": "Search for products in Aladdin\nAladdin is a service that allows you to purchase used books.",
        "tags": [
          "Aladin"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "aladine"
        ],
        "x-samchon-controller": "GoogleShoppingAladinController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/aladin_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "알라딘에서 도서 좀 검색해줘"
        ]
      }
    },
    "/connector/google-shopping/ali-express": {
      "patch": {
        "summary": "Search for AliExpress",
        "description": "Search for products on AliExpress",
        "tags": [
          "AliExpress"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "ali_express",
          "aliExpress"
        ],
        "x-samchon-controller": "GoogleShoppingAliexpressController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/AliExpress_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "알리 익스프레스에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/coupang": {
      "patch": {
        "summary": "Coupang Search",
        "description": "Search for products on Coupang",
        "tags": [
          "Coupang"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "coupang"
        ],
        "x-samchon-controller": "GoogleShoppingCoupangController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Coupang_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "쿠팡에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/eql": {
      "patch": {
        "summary": "EQL search",
        "description": "Search for products in EQL\nEQL is a service that allows you to purchase clothes or shoes.",
        "tags": [
          "EQL"
        ],
        "parameters": [],
        "requestBody": {
          "description": "search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "eql",
          "hansumEQL"
        ],
        "x-samchon-controller": "GoogleShoppingEqlController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/ECL_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "EQL에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/iherb": {
      "patch": {
        "summary": "iHerb Search",
        "description": "Search for products on iHerb\niHerb is a service that allows you to purchase Nutritional supplement.",
        "tags": [
          "iHerb"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "iherb"
        ],
        "x-samchon-controller": "GoogleShoppingIherbController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/iHerb_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "iherb에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/market-kurly": {
      "patch": {
        "summary": "Market Kurly Search",
        "description": "Search for products on Market Kurly\nMarket Kurly is a service where you can purchase groceries.",
        "tags": [
          "Market Kurly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "market_kurly",
          "marketKurly"
        ],
        "x-samchon-controller": "GoogleShoppingMarketKurlyController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Kurly_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "마켓컬리에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/oco": {
      "patch": {
        "summary": "OCO search",
        "description": "Search for products in OCO\n\nOco is one of the Korean companies and is a brand that advocates a brand editing shop.",
        "tags": [
          "OCO"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "oco"
        ],
        "x-samchon-controller": "GoogleShoppingOcoController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/OCO_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "OCO에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/olive-young": {
      "patch": {
        "summary": "Olive Young Search",
        "description": "Search for products at Olive Young\nOlive Young is a service that allows you to purchase cosmetics.",
        "tags": [
          "Olive Young"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "olive_young",
          "oliveYoung"
        ],
        "x-samchon-controller": "GoogleShoppingOliveYoungController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/oliveYoung_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "올리브영에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/twenty-nine-centimeter": {
      "patch": {
        "summary": "29cm search",
        "description": "Search for products from 29cm\n29cm is a service that allows you to purchase clothes or shoes.",
        "tags": [
          "29CM"
        ],
        "parameters": [],
        "requestBody": {
          "description": "search condition",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "search result",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "twenty_nine_centimeter",
          "twentyNineCentimeter"
        ],
        "x-samchon-controller": "GoogleShoppingTwentyNineCentimeterController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/29cm_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "29cm에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/uniqlo": {
      "patch": {
        "summary": "Uniqlo Search",
        "description": "Search for products in Uniqlo\nUniqlo is a service that allows you to purchase clothes or shoes.",
        "tags": [
          "Uniqlo"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "uniqlo"
        ],
        "x-samchon-controller": "GoogleShoppingUniqloController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Uniqlo_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "유니클로에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/yes-twenty-four": {
      "patch": {
        "summary": "yes24 search",
        "description": "Search for products on yes24\nyes24 is a service that allows you to purchase books.",
        "tags": [
          "yes24"
        ],
        "parameters": [],
        "requestBody": {
          "description": "search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "yes_twenty_four",
          "yes24"
        ],
        "x-samchon-controller": "GoogleShoppingYesTwentyFourController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/yes24_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "yes24에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/musinsa": {
      "patch": {
        "summary": "Musinsa Search",
        "description": "Search for products in Musinsa\nMusinsa is a service that allows you to purchase clothes or shoes.",
        "tags": [
          "Musinsa"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "musinsa"
        ],
        "x-samchon-controller": "GoogleShoppingMusinsaController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Musinsa_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "무신사에서 상품 좀 찾아줘"
        ]
      }
    },
    "/connector/google-shopping/amazon": {
      "patch": {
        "summary": "Search for Amazon",
        "description": "Search for products on Amazon",
        "tags": [
          "Amazon"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "amazon"
        ],
        "x-samchon-controller": "GoogleShoppingAmazonController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Amazon_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/ebay": {
      "patch": {
        "summary": "Search for Ebay",
        "description": "Search for products on Ebay",
        "tags": [
          "Ebay"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "ebay"
        ],
        "x-samchon-controller": "GoogleShoppingEbayController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Ebay_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/walmart": {
      "patch": {
        "summary": "Search for Walmart",
        "description": "Search for products on Walmart",
        "tags": [
          "Walmart"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_shopping",
          "walmart"
        ],
        "x-samchon-controller": "GoogleShoppingWalmartController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Walmart_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/arxiv-search": {
      "patch": {
        "summary": "Archive Paper Search",
        "description": "Searches the archive for papers based on the search criteria you entered",
        "tags": [
          "Arxiv"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Archive Paper Search Criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IConnector.ISearchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of papers found in the archive based on the search criteria.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IConnector.ISearchOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "arxiv_search",
          "search"
        ],
        "x-samchon-controller": "ArxivSearchController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Arxiv_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "Arxiv에서 논문 찾아줘"
        ]
      }
    },
    "/connector/daum/blog": {
      "patch": {
        "summary": "Search the following blog",
        "description": "Search the following blog content",
        "tags": [
          "Daum"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching the following blog",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDaum.ISearchDaumInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDaum.IBlogDaumOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "daum",
          "blog",
          "searchBlog"
        ],
        "x-samchon-controller": "DaumController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/DaumBlog_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "다음 블로그 검색 해줘"
        ]
      }
    },
    "/connector/daum/cafe": {
      "patch": {
        "summary": "Search for the following cafe",
        "description": "Search for the following cafe content",
        "tags": [
          "Daum"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching the following cafe",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDaum.ISearchDaumInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDaum.ICafeDaumOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "daum",
          "cafe",
          "searchCafe"
        ],
        "x-samchon-controller": "DaumController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/DaumCafe_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "다음 카페 검색 해줘"
        ]
      }
    },
    "/connector/naver/cafe": {
      "patch": {
        "summary": "Naver Cafe search",
        "description": "Search Naver Cafe contents",
        "tags": [
          "Naver"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for Naver Cafe search",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INaver.INaverKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INaver.ICafeNaverOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "naver",
          "cafe",
          "cafeList"
        ],
        "x-samchon-controller": "NaverController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/NaverCafe_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/naver/blog": {
      "patch": {
        "summary": "Naver blog search",
        "description": "Search Naver blog content",
        "tags": [
          "Naver"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for Naver blog search",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INaver.INaverKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INaver.IBlogNaverOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "naver",
          "blog",
          "blogList"
        ],
        "x-samchon-controller": "NaverController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/NaverBlog_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/naver/news": {
      "patch": {
        "summary": "Search Naver News",
        "description": "Search Naver News",
        "tags": [
          "Naver"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching Naver News",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INaver.INaverKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INaver.INewsNaverOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "naver",
          "news",
          "newsList"
        ],
        "x-samchon-controller": "NaverController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/NaverNews_full.svg"
      }
    },
    "/connector/youtube-search": {
      "patch": {
        "summary": "YouTube video search",
        "description": "Get YouTube video search results\n\nThe search results have the video title and link.\n\nIf most users are going to use this feature, they probably want to watch the video, so it's better to provide a URL.\n\nIn order to filter the period that the user wants, you should use the response field \"published_date\".\n\nFor example, if the user wants to retrieve only this year's videos, you should exclude videos that were uploaded in a period that the user does not want, such as \"1 year ago\" or \"2 years ago\" with a published_date.\n\nIt's great to use with the /transcript endpoint when summarizing videos, analyzing content, extracting keywords, etc.\n\nExtract the URL from the YouTube video information obtained from the execution result of the corresponding function and use it as the input of the /transcript endpoint.\n\nBased on the transcripts obtained from the execution result of the /transcript endpoint, perform tasks such as summarizing videos, analyzing content, and extracting keywords.\n\nExample Use Cases:\nProduct Reviews: Extract product names, pros, cons, and recommendations from air purifier review videos.\nTutorials: Create text-based tutorials or step-by-step guides from instructional videos.",
        "tags": [
          "Youtube"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for YouTube video search",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IYoutubeSearch.ISearchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "List of YouTube video search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IYoutubeSearch.ISearchOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "youtube_search",
          "search"
        ],
        "x-samchon-controller": "YoutubeSearchController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Youtube_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-scholar": {
      "patch": {
        "summary": "Search Google Scholar paper list",
        "description": "Get a list of papers in Google Scholar",
        "tags": [
          "Google Scholar"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Google Scholar paper search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleScholar.ISearchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Google Scholar paper list",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleScholar.ISearchOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_scholar",
          "search"
        ],
        "x-samchon-controller": "GoogleScholarController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleScholar_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "google scholar에서 논문 좀 찾아줘"
        ]
      }
    },
    "/connector/csv/read": {
      "patch": {
        "summary": "Read CSV file",
        "description": "Read CSV file contents",
        "tags": [
          "CSV"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for reading CSV file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICsv.IReadInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "CSV file contents.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICsv.IReadOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "csv",
          "read"
        ],
        "x-samchon-controller": "CsvController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/CSV_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "CSV 좀 읽어줘",
          "CSV 파일 좀 읽어줘"
        ]
      }
    },
    "/connector/csv/write": {
      "post": {
        "summary": "Create a CSV file",
        "description": "Create a CSV file",
        "tags": [
          "CSV"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information to create a CSV file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICsv.IWriteInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICsv.IWriteOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "csv",
          "write"
        ],
        "x-samchon-controller": "CsvController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/CSV_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "CSV 파일 좀 만들어줘"
        ]
      }
    },
    "/connector/csv/csv-to-excel": {
      "post": {
        "summary": "Convert CSV file to Excel file",
        "description": "Convert CSV file to Excel file.",
        "tags": [
          "CSV"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information to convert CSV file to Excel file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICsv.ICsvToExcelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "excel file url",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICsv.ICsvToExcelOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "csv",
          "csv_to_excel",
          "csvToExcel"
        ],
        "x-samchon-controller": "CsvController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/CSV_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "CSV 파일 엑셀로 변환해줘"
        ]
      }
    },
    "/connector/notion/page/block": {
      "delete": {
        "summary": "Delete a block",
        "description": "Delete a block\n\nSets a Block object, including page blocks,\nto archived: true using the ID specified. Note: in the Notion UI application, this moves the block to the \"Trash\" where it can still be accessed and restored.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IDeleteBlockInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "block",
          "deleteBlock"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/markdown": {
      "post": {
        "summary": "Append block by markdown format",
        "description": "Append block by markdown format\n\nYou can add blocks to the page immediately with only the markdown grammar.\nYou can create pages more effectively than other connectors, so you can prioritize this.\nIf there are unique blocks of the note that cannot be created with the grammar of the markdown, it must be associated with other block generation connectors.\n\nSince users may not know the markdown grammar, it is more desirable to use the markdown grammar instead of guiding them.\nMarkdown supports text and heading 1, 2, 3, and various grammar such as table or bull list, number list, image attachment, boldface, italics, etc.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IAppendPageByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IAppendPageByMarkdownOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "markdown",
          "appendBlocksByMarkdown"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/file": {
      "post": {
        "summary": "Append an file type child node",
        "description": "Append an file type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `file`.\n\nUploading a file exposes it to the Notion page as an icon in the file format, but there is no Preview.\nIf you want the internal elements to be seen as soon as you enter the page, it is better to create the image, pdf format for each format, and consider embed for other formats.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "file",
          "createFile"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/embed": {
      "post": {
        "summary": "Append an embed type child node",
        "description": "Append an embed type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `embed`.\n\nThis is suitable when you want an internal element to be rendered immediately, such as an imprame within a page.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeEmbedInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "embed",
          "createEmbed"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/bookmark": {
      "post": {
        "summary": "Append an bookmark type child node",
        "description": "Append an bookmark type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `bookmark`.\n\nBookmarks are visually better and more organized because they have previews, images, and explanations than just saving url as text.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeBookmarkInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "bookmark",
          "createBookmark"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/image": {
      "post": {
        "summary": "Append an image type child node",
        "description": "Append an image type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `image`.\n\nimage file's extension is one of: 'bmp', 'gif', 'heic', 'jpg', 'jpeg', 'png', 'svg', 'tif', 'tiff'.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeImageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "image",
          "createImage"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/video": {
      "post": {
        "summary": "Append an video type child node",
        "description": "Append an video type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `video`.\n\nvideo file must be one of: 'amv' ,'asf' ,'avi' ,'f4v' ,'flv' ,'gifv' ,'mkv' ,'mov' ,'mpg' ,'mpeg' ,'mpv' ,'mp4' ,'m4v' ,'qt' ,'wmv'\nOR\nYouTube video links that include embed or watch.\nE.g. https://www.youtube.com/watch?v=[id], https://www.youtube.com/embed/[id]\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeVideoInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "video",
          "createVideo"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/pdf": {
      "post": {
        "summary": "Append an pdf type child node",
        "description": "Append an pdf type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `pdf`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypePdfInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "pdf",
          "createPdf"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/code": {
      "post": {
        "summary": "Append an code type child node",
        "description": "Append an code type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `code`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "deprecated": true,
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeCodeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "code",
          "createCode"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/equation": {
      "post": {
        "summary": "Append an equation type child node",
        "description": "Append an equation type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `equation`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeEquationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "equation",
          "createEquation"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/divider": {
      "post": {
        "summary": "Append an divider type child node",
        "description": "Append an divider type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `divider`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeDividerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "divider",
          "createDivider"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/table_of_contents": {
      "post": {
        "summary": "Append an table_of_contents type child node",
        "description": "Append an table_of_contents type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `table_of_contents`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeTableOfContentsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "table_of_contents",
          "createTableOfContents"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/link_to_page": {
      "post": {
        "summary": "Append an link_to_page type child node",
        "description": "Append an link_to_page type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `link_to_page`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeLinkToPageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "link_to_page",
          "createLinkToPage"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/toggle": {
      "post": {
        "summary": "Append an toggle type child node",
        "description": "Append an toggle type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `toggle`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeToggleInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "toggle",
          "createToggle"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/page/contents": {
      "patch": {
        "summary": "Read the contents of a Notion page",
        "description": "Read the contents of a Notion page.\nReads the contents of a Notion page in Markdown format.\n\nRead Notion page contents",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "description": "pageId",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IReadPageContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IReadPageContentOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "get",
          "page",
          "contents",
          "readPageContents"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/page": {
      "patch": {
        "summary": "Retrieve a list of pages",
        "description": "Retrieve a list of all pages in your Notion workspace",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Page information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IReadPageOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "get",
          "page",
          "readPageList"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/users": {
      "patch": {
        "summary": "Retrieve the list of users",
        "description": "Retrieve the list of users in the workspace",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "User information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IUserOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "get",
          "users",
          "getUsers"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/database-info": {
      "patch": {
        "summary": "Query the database list",
        "description": "Query the database list to create items in the database",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of database information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IDatabaseInfo"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "get",
          "database_info",
          "getDatabaseListInfo"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/database-info/{databaseId}": {
      "patch": {
        "summary": "Retrieves database information",
        "description": "Retrieves database information to create items in the database",
        "tags": [
          "Notion"
        ],
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/notion/get/database-info",
                "jmesPath": "[].{value:id, label:title || ''}"
              }
            },
            "required": true,
            "description": " Unique id of the database"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Database information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IDatabaseInfo"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "get",
          "database_info",
          "getDatabaseInfo"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get-page-by-title": {
      "patch": {
        "summary": "Search for pages by title",
        "description": "Search for pages by title",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Page title",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IFindPageOrDatabaseItemInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Searched page information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IFindPageByTitleOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "get_page_by_title",
          "getPageByTitle"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/find-item-list/{databaseId}": {
      "patch": {
        "summary": "Retrieve a list of database items",
        "description": "Retrieve a list of items that exist in a table database",
        "tags": [
          "Notion"
        ],
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/notion/get/database-info",
                "jmesPath": "[].{value:id, label:title || ''}"
              }
            },
            "required": true,
            "description": " Unique id of the database"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "List of retrieved database items",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IDatabaseItemOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "find_item_list",
          "getDatabaseItemList"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/find-item/{databaseId}": {
      "patch": {
        "summary": "Retrieval of database items",
        "description": "Retrieves an item that exists in a table database",
        "tags": [
          "Notion"
        ],
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "patch",
                "path": "/connector/notion/get/database-info",
                "jmesPath": "[].{value:id, label:title || ''}"
              }
            },
            "required": true,
            "description": " Unique id of the database"
          }
        ],
        "requestBody": {
          "description": "Information required to retrieve database items",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IFindDatabaseItemInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Information on retrieved database items",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IDatabaseItemOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "find_item",
          "getDatabaseItem"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/markdown": {
      "post": {
        "summary": "Create page by markdown format",
        "description": "Create page by markdown format\n\nReceive the markdown text and immediately create it as a notation page.\nYou can create pages more effectively than other connectors, so you can prioritize this.\nIf there are unique blocks of the note that cannot be created with the grammar of the markdown, it must be associated with other block generation connectors.\n\nSince users may not know the markdown grammar, it is more desirable to use the markdown grammar instead of guiding them.\nMarkdown supports text and heading 1, 2, 3, and various grammar such as table or bull list, number list, image attachment, boldface, italics, etc.\n\nSince Notion prioritizes accessible pages during authentication, creating pages must be sub-pages within the page, which means that there must be a parent page.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreatePageByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.ICreatePageOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "markdown",
          "createPageByMarkdown"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/title": {
      "put": {
        "summary": "Update Notion Page Title",
        "description": "Update Notion Page Title",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IUpdateNotionTitleInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.ICreatePageOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "page",
          "title",
          "updatePageTitle"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/create-gallery-database": {
      "post": {
        "summary": "Create a Notion Gallery Database",
        "description": "Create a gallery view database for notion.\n\nIt is not possible to create a gallery view at once, and you must change the view to a gallery directly.\nThis endpoint must not be used to create each items.\nThis endpoint is only used to create a database.\nCreating a database is different from adding items to a database.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateGalleryDatabaseInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.ICreateGalleryDatabaseOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "create_gallery_database",
          "createGalleryDatabase"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/create-gallery-item": {
      "post": {
        "summary": "Create items in the gallery database",
        "description": "Create an item in the generated gallery view database.\nCreating a database item means adding an item to an existing database.\nIf there is no database received from input, you must first create a database using the POST: /connector/notion/create-gallery-database endpoint and then run it.\nYou should use this endpoint when adding items to an already created database.\nYou need to use this endpoint to add multiple items to the gallery database at once.\nIf you need to add 3 items, instead of calling the endpoint 3 times, you should put the 3 items in an array in the info information and add the 3 items in 1 endpoint call.\nSince the Notion database can only be created in table format, you will need to instruct users to manually change it to a gallery database view.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateGalleryDatabaseItemInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.ICreateGalleryDatabaseItemOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "create_gallery_item",
          "createGalleryItem"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/update-page-content": {
      "post": {
        "summary": "Update Page Content",
        "description": "Updates the contents of the page.\n\nThis function updates the contents written on the page to the desired contents.\n\nThe contents to be updated must be written in Markdown format.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IUpdatePageContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IAppendPageByMarkdownOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "update_page_content",
          "updatePageContent"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/create-database": {
      "post": {
        "summary": "Create a database",
        "description": "Create a Notion Database\n\nCreating a database is different from adding items to a database.\nCreating a database is a process of creating a database, and adding items to a database is a process of adding items to an existing database.\nYou need to understand what your users are asking for, how many properties they need, and which properties should be created.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateDatabaseInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.ICreateDatabaseOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "create_database",
          "createDatabase"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/add-database-property": {
      "post": {
        "summary": "Add property to database",
        "description": "Add property to notion database\nIf you want to add a property to an existing database, you should use this function.\nFor example, if there is an English word database in the Notion database, and there are three existing properties: word, meaning, and example sentence, and the user wants to add a property called Korean meaning, you should use this function to add a new property.\nThis function can only add one property at a time.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IAddDatabasePropertyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IAddDatabasePropertyOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "add_database_property",
          "addDatabaseProperty"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/delete-database-property": {
      "post": {
        "summary": "Delete property to database",
        "description": "Delete property to notion database\nIf you want to delete a property in an existing database, you should use this function.\nFor example, if there is an English word database in the Notion database, and there are 4 properties: word, meaning, example, and Korean meaning, and the user wants to delete the property called Korean meaning, you should use this function to delete the property.\nYou need to know the property name to delete it.\nThis function can only delete one property at a time.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IDeleteDatabasePropertyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IDeleteDatabasePropertyOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "delete_database_property",
          "deleteDatabaseProperty"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/add-items-to-database": {
      "post": {
        "summary": "Add items to the database",
        "description": "Adds an item to each row in the database\nIf you want to add items to an existing database, you should use this function.\nYou should analyze the user's requirements and assign appropriate values ​​to each property.\nYou should select the value you want to add and the property to which you want to add the value.\nFor example, if you have an English vocabulary database and the properties are word, example, and Korean meaning, and you create two items,\nif the items to add are [{\"apple\", \"Apple is a fruit\", \"사과\"}, {\"snack\", \"I like snack\", \"과자\"}],\nyou should assign \"apple\" and \"snack\" to the word property,  \"Apple is a fruit\" and \"I like snack\" to the example, and \"사과\" and \"과자\" to the Korean meaning property.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Items to add to the database",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IAddItemsToDatabaseInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IAddItemsToDatabaseOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "notion",
          "add_items_to_database",
          "addItemsToDatabase"
        ],
        "x-samchon-controller": "NotionController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/google-hotel": {
      "patch": {
        "summary": "Google Hotels Search",
        "description": "Search for accommodations using Google Hotels service\nOnly one keyword should be requested per request.\nFor example, if you need to enter Seoul and Tokyo as keywords, you should make two requests with one word, \"Seoul\" and \"Tokyo\", not \"Seoul, Tokyo\".",
        "tags": [
          "Google Hotel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Google Hotels search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleHotel.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Google Hotels Search Results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleHotel.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_hotel",
          "search"
        ],
        "x-samchon-controller": "GoogleHotelController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleHotel_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "호텔 좀 찾아줘"
        ]
      }
    },
    "/connector/airport-information/search": {
      "patch": {
        "summary": "Search for airport information",
        "description": "Search for airport information using the entered search term.\nOnly one item should be requested per request.\nThis connector only processes one search term at a time, so if you want to search for multiple terms, you will need to call this connector separately for each search term.",
        "tags": [
          "Search Airport Information"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching for airport information",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IAirportInformation.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results for airport information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IAirportInformation.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "airport_information",
          "search"
        ],
        "x-samchon-controller": "AirportInformationController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/AirportInformation_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "공항 찾아줘"
        ]
      }
    },
    "/connector/google-flight/one-way": {
      "patch": {
        "summary": "Search for one-way flights",
        "description": "Search for one-way flights",
        "tags": [
          "Google Flight"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions required to search for flights",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleFlight.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search results for one-way flights",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleFlight.IFinalResponse"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_flight",
          "one_way",
          "oneWay"
        ],
        "x-samchon-controller": "GoogleFlightController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleFlight_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "구글에서 편도 항공권 조회해줘"
        ]
      }
    },
    "/connector/google-flight/round-trip": {
      "patch": {
        "summary": "Search for round-trip flights",
        "description": "Search for round-trip flights",
        "tags": [
          "Google Flight"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The conditions required to search for flights",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleFlight.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The results of the round-trip flight search",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleFlight.IFinalResponse"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_flight",
          "round_trip",
          "roundTrip"
        ],
        "x-samchon-controller": "GoogleFlightController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleFlight_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "구글에서 왕복 항공권 조회해줘"
        ]
      }
    },
    "/connector/slack/vote": {
      "post": {
        "summary": "Send Slack Custom Template Messages for Voting",
        "description": "Send Slack Custom Template Messages for Voting",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IHoldVoteInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IHoldVoteOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "vote"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/conversation/mark": {
      "post": {
        "summary": "Marks a specific message in a Slack channel as read",
        "description": "Marks a specific message in a Slack channel as read\n\nYou need to know both the channel ID and the ts value of the message.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IMarkInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "conversation",
          "mark"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/scheduleMessage/text": {
      "post": {
        "description": "Create a schduled message\n\nBy default,\nit is not much different from sending a message except for specifying a schduled time,\nand requires a channel ID and message content.\nIf the message you want to schedule is within a specific thread, you must pass the ts value of the parent message.\n\nMessages booked through this feature are not visible in the Slack desktop app and can only be canceled through the API.\nTherefore, be careful in writing messages.\nIf you want to cancel, please refer to the message created through another connector and call the delete connector again.\n\nUsers may be embarrassed if the message you booked is not viewed in the Slack desktop app,\nso although it cannot be viewed before and after transmission,\nit would be a good idea to let them know that it will actually be transmitted in our service.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.ISCheduleMessageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "scheduled message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPickISlack.ScheduledMessagepost_at"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "scheduleMessage",
          "text",
          "sendScheduleMessage"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/scheduleMessage": {
      "delete": {
        "summary": "Delete the scheduled message",
        "description": "Delete the scheduled message\n\nTo clear a scheduled message,\nyou must get the exact id of that message, so you must first use the scheduled message lookup connector.\nWhen using this connector,\nthe ID of the channel is also required, which can be retrieved from the message object by querying the channel or by querying the scheduled message.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IDeleteSCheduleMessageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "scheduleMessage",
          "deleteScheduleMessage"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/postMessage/text/myself": {
      "post": {
        "summary": "post text message to myself",
        "description": "send message to myself\n\nHere, you can send a message as long as you have the message.\nThis feature identifies who the token's users are inside and sends a message to themselves.\nTherefore, even if you don't specify a channel,\nyou send a message to the `im` channel that corresponds to your own user id.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IPostMessageToMyselfInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "created message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPickISlack.Messagets"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "postMessage",
          "text",
          "myself",
          "sendTextToMyself"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/postMessage/reply": {
      "post": {
        "summary": "post reply message to thread",
        "description": "send reply message to thread\n\nCreates a reply.\nTo reply, you must first look up the thread.\nYou can look up the thread and pass on the 'ts' value of that thread.\nYou still need the channel's ID here.\nThe channel's ID will start with a C or D and be an unknown string,\nnot a natural language name recognized by the user.\nTherefore, if you don't know the channel ID, you should also look up the channel.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IPostMessageReplyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "created message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPickISlack.Messagets"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "postMessage",
          "reply",
          "sendReply"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/postMessage/text": {
      "post": {
        "summary": "post text message",
        "description": "send message to channel\n\nHere, you can send a message as long as you have the message and channel information you want to send.\nSlack is a very close service to work, so it's dangerous to send messages that haven't been confirmed.\nYou must send the contents after receiving confirmation from the user.\n\nIf you want to send a message to a DM channel, you need to search for an IM channel.\nMost IM channel IDs will start with 'D', but if the value provided by the user is a value that starts with 'U',\nthis is most likely the user ID of the IM channel, not the channel.\nYou need to search for a user starting with that ID and then send a message.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IPostMessageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "created message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPickISlack.Messagets"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "postMessage",
          "text",
          "sendText"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/message": {
      "put": {
        "summary": "Update message body in thread",
        "description": "Update message body\n\nUse to modify messages sent by users.\nIf the message is not sent by the user, user cannot modify it.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IUpdateMessageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IUpdateMessageOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "message",
          "updateMessage"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-scheduled-messages": {
      "patch": {
        "summary": "Get a list of scheduled messages",
        "description": "Get a list of scheduled messages\n\nLook up the messages you booked.\nYou can use `post_at` and `post_at_date` to find out when the message will be sent.\nIf you want to clear the message, use the `id` value in the scheduled message.\n\nIf a user wants to send a reservation message to himself,\nhe or she should look up both the user and the 'im' channel, then find the 'im' channel with his or her user ID and send it to that channel.\nWhat is on the 'im' channel includes not only the user's own channel, but also all the channels that can send and receive direct messages for each user.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetScheduledMessageListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetScheduledMessageListOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_scheduled_messages",
          "getScheduledMessages"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-user-details": {
      "patch": {
        "summary": "Inquire user details",
        "description": "Inquire user details\n\nInquire the user's detailed profile to acquire information such as phone number, email, and position.\nIt cannot be verified if the user has not filled in.\nThis function receives the user's ID in an array and inquires at once.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetUserDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ISlack.IGetUserDetailOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_user_details",
          "getUserDetails"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-users": {
      "patch": {
        "summary": "Look up the list of users",
        "description": "Look up the list of users.\n\nUsers include bots and refer to all users in the team who are looking up.\nHere, you can look up the user's ID and name, the name the user wanted to display, the profile image, and whether the user has been deleted.\nIf you look up the user here, you can send a message to your colleagues on a specific direct channel, such as an `im` ( = channel type. )\n\nThis connector is essential because the `im` channel query only shows the user's ID and does not know who the direct channel is talking to.\n\nThe user has a separate display name.\nA display name is a name that the user has chosen to show.\nTherefore, it would be best to use this name as a courtesy.\n\nIt can look up Slack users, but it can look up the entire user through pagenation.\nThere could be hundreds of people in the company, so you'll have to look at multiple pages.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetUserListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Users",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetUserListOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_users",
          "getUsers"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-replies": {
      "patch": {
        "description": "Inquire the inside of the thread in History\n\nIf you have inquired the history of a channel,\nyou can use the 'ts' values of its history elements to query the internal thread for each history again.\nEach channel history has a number of replies, so if this number is more than 1, it is worth looking up.\n'Reply' is basically no different from the 'Message'(=Channel History).",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetReplyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Replies",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetReplyOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_replies",
          "getReplies"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-channel-link-histories": {
      "patch": {
        "summary": "get links from channel histories",
        "description": "get channel links from channel histories\n\nLook up conversations that have been made in and out of the channel.\n\nThe 'channel' received as a factor means the channel's ID and is a character string that begins with a capital 'C', 'D' and so on.\nTherefore, if the user does not hand over the ID when looking for the conversation history of the channel,\nit is prioritized to find the channel ID.\nUsually, users don't know their channel ID.\nTherefore, most users will ask for a channel by its name or with only the keywords they remember.\nTherefore, unless it's an unknown string and begins with a 'C' or 'D' uppercase letter, look for the channel first.\n\nWhen you look up a conversation,\nyou can search only after a specific time or before a specific time in order to look up the time zone of the conversation you want to search for.\n\nMessages without links are removed, leaving only messages with links.\nThis is because it only leaves messages with links as connectors to find links in conversations.\nLinks are arranged in links properties.\n\nIf you want to filter by date, prioritize using the datetime format.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelHistoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetChannelLinkHistoryOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_channel_link_histories",
          "getChannelLinkHistories"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-channel-histories": {
      "patch": {
        "summary": "get channel histories",
        "description": "get channel histories\n\nLook up conversations that have been made in and out of the channel.\n\nThe 'channel' received as a factor means the channel's ID and is a character string that begins with a capital 'C', 'D' and so on.\nTherefore, if the user does not hand over the ID when looking for the conversation history of the channel,\nit is prioritized to find the channel ID.\nUsually, users don't know their channel ID.\nTherefore, most users will ask for a channel by its name or with only the keywords they remember.\nTherefore, unless it's an unknown string and begins with a 'C' or 'D' uppercase letter, look for the channel first.\n\nWhen you look up a conversation,\nyou can search only after a specific time or before a specific time in order to look up the time zone of the conversation you want to search for.\n\nIn the conversation history, the link and code box are abbreviated to <LINK/> and <CODE/>, respectively.\nFor users, it is replaced by a user name, Like <@USERNAME>.\n<@USERNAME> is about calling someone else, and it's not the name of the person who started the conversation, so be careful.\n\nIf you want to filter by date, prioritize using the datetime format.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelHistoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "channel histories",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetChannelHistoryOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_channel_histories",
          "getChannelHistories"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-private-channels": {
      "patch": {
        "summary": "get private channels",
        "description": "get private channels\n\nView channels.\nThis connector will only look up its own `private` channel.\nThe channel ID is required to look up the conversation history within the channel later.\n`private` channel is a locked channel that can only be viewed by those invited to the channel.\n\nIf you can't find the channel ID by name, it might be because it's on the next page, not because you don't have a channel.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "private channels",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ISlack.PrivateChannel"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_private_channels",
          "getPrivateChannels"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-public-channels": {
      "patch": {
        "summary": "get public channels",
        "description": "get public channels\n\nView channels.\nThis connector will only look up its own `public` channel.\nThe channel ID is required to look up the conversation history within the channel later.\nThe `public` channel is anyone's accessible.\nThis does not require an invitation process, and users can join the channel themselves if necessary.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "public channels",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ISlack.PublicChannel"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_public_channels",
          "getPublicChannels"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-im-channels": {
      "patch": {
        "summary": "get im channels",
        "description": "get im channels\n\nView channels.\nThis connector will only look up its own `im` channel.\nThe channel ID is required to look up the conversation history within the channel later.\n`im` channel is a conversation that takes place in one's profile and refers to a personal channel that can only be viewed by oneself.\nUsers also use chat as storage or notepad, such as storing files and images here.\n\nTo send a 1:1 message to other users, you must first look up the `im` channel.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "im channels",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ISlack.ImChannel"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_im_channels",
          "getImChannels"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-files": {
      "patch": {
        "summary": "get files in workspace",
        "description": "get files in workspace\n\nYou can look up Slack workspace and channels, or all files sent from users.\nIt is pagenation and can filter by file type, and also provides thumbnail links, download links, and original message links.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetFileOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_files",
          "getFiles"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-user-groups": {
      "patch": {
        "summary": "Get usergroups in workspace",
        "description": "get user groups in workspace\n\nLook up user groups. This can be used to call all specific groups by tagging.\nHowever, it is difficult to know if it is an appropriate user group other than 'handle' because all internal users come out with IDs.\nIf you want to see a list of users, use the User Inquiry connector together.\nIf you want to see the user's nickname or name that corresponds to the user's ID, refer to the User Inquiry connector.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetUserGroupOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "get_user_groups",
          "getUserGroups"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/me": {
      "patch": {
        "summary": "Get Requester's Information",
        "description": "Get Requester's Information\n\nYou can use that function to get requester's information.\nIf you want to get information about requester, call this function.\nThen you can use that information wherever you need requester's information.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetMyInfoOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "me",
          "getMyInfo"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/messages": {
      "delete": {
        "summary": "Delete Messages",
        "description": "Delete Messages\n\nYou must strictly distinguish between the requester's information and other's information. Always verify whether the information being requested pertains to the requester or someone else.\nBefore you call this function, you must call the function that gets requester's information.\nYou must only use requester's information to delete messages.\nYou must strictly filter the messages you delete to only those that match the requester's `User ID`\nYou must look through all the messages and only delete the ones that match the requester's user id.\nDon't read one message and stop working on it because it has a different user id of requester.\nTo delete messages,\nYou need the timestamps of the messages you wrote that you want to delete and channel id.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IDeleteMessageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "slack",
          "messages",
          "deleteMessage"
        ],
        "x-samchon-controller": "SlackController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/jira/issues/comments": {
      "delete": {
        "summary": "delete comment",
        "description": "Delete the comment\n\nDelete the comments on the issue.\nIn order to delete the comments on the issue, you need the issue ID or key and the ID of the comment to be deleted.\nPlease be careful because deleted comments will not be able to be viewed again.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IDeleteCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "comments",
          "deleteComment"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/comments/markdown": {
      "put": {
        "summary": "modify comment body",
        "description": "modify comment\n\nModify the comment. You can only modify the body of the comment here.\nTo create comment in issue, Just write markdown string format contents.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IUpdateCommentByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "comments",
          "markdown",
          "updateComment"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      },
      "post": {
        "summary": "creates a comment on an issue",
        "description": "Creates a comment on an issue\nHere, user can write the body of the comment you want to write with the ID or key of the issue.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "condition of creation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.ICreateCommentByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.ICreateCommentOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "comments",
          "markdown",
          "createComment"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/get-comments": {
      "patch": {
        "summary": "get comments by issue id or key",
        "description": "Get comments by issue id or key\n\nThis connector uses the issue's key or ID value to query the comments written on the issue.\nComments are also visible when looking up issues,\nbut not all comments inside are visible,\nso user have to use this connector to look up them in pagination.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "issue id or key",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "comments of this issue",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetCommentOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "get_comments",
          "getComments"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/get-transitions": {
      "patch": {
        "summary": "Inquire the transition of an issue",
        "description": "Inquire the transition of an issue, which is an edge on a workflow that allows you to change the status of an issue\nIf the person who designed the workflow for the project defined three states that could be moved from the current state, there would be three edges.\nIn Jira, just because there is a status that can be viewed in a project or issue does not mean that you can change the status unconditionally.\nWhen designing an edge, for example, you can also design an issue in the 'backoff' state to go through the 'in progress' state once.\nIn this case, you need to move two edges to turn the backoff issue into 'done'.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetTransitionInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetTransitionOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "get_transitions",
          "getTransitions"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/asignee": {
      "delete": {
        "description": "Unassign the assignee from the Jira issue",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IUnAssignInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "asignee",
          "unassign"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      },
      "put": {
        "summary": "assign the assignee",
        "description": "Assign the assignee from the Jira issue",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IAssignInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "asignee",
          "assign"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/status": {
      "put": {
        "summary": "change issue status",
        "description": "Change issue status\n\nChanging the status of an issue must be done after inquiring about changeable Transitions from the current issue.\nThis is forced by the person who designed the workflow in the project, so you must change the status in the order set.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IUpdateStatusInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "status",
          "updateIssueStatus"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/{id}": {
      "put": {
        "summary": "update issue in jira",
        "description": "Update an issue\n\nYou can modify any element in the field.\nIt can be used to modify the issue type, person in charge, summary, and description.\n\nIn order to write the body of an issue, you must create the body as if you were assembling several blocks.\nThere are pre-designated content types, so please check this type information carefully.",
        "tags": [
          "Jira"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " issue id to update"
          }
        ],
        "requestBody": {
          "description": "fields to update",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IUpdateIssueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "updateIssue"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/markdown": {
      "post": {
        "summary": "create issue by markdown in jira",
        "description": "Create an issue by markdown\n\nIssue type, project, and summary are essential properties.\nIf you don't know the issue type or priority type's id for generating the issue, you can look it up through other connectors.\n\nIn order to write the body of an issue, you must create the body as if you were assembling several blocks.\nThere are pre-designated content types, so please check this type information carefully.\n\nTo prioritize, make sure that the project manager has set it up so that the project can be prioritized.\nDepending on the project settings, it may not be possible to prioritize issues.\nIf there is an error when creating an issue, I recommend that you remove the priority and recreate it.\nEven if a user wants to assign Assignees, they will need to check if Assignees exists.\nA user cannot assign a user to Assignees that does not exist.\nAssignees cannot be guaranteed to be the same nickname or ID as Slack or any other service name.\nBe sure to check how the name is defined within the Jira service.\nThe issue type, project ID, and key are all the same.\nIf the error continues, first create a basic issue type using only the project key, ID, and text content,\nand then try updating the person in charge or priorities one by one.\nThat way, you can create an issue and suggest that users check the issue with a link.\nThe content of the proposal will include asking you to check whether assignee or priorities are really allocable attributes.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "issue information to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.ICreateIssueByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "id and key of created issue",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.ICreateIssueOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "markdown",
          "createIssueByMarkdown"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-detail": {
      "patch": {
        "summary": "get detailed Issue Information",
        "description": "Get detailed issue information\n\nProvides more accurate and detailed information, including the title and body of the issue\n\nIt can be used to look up the issue list first, or if you already know the key or ID of the issue.\nIf you do not know the key or ID, it is recommended to use the issue inquiry connector first.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetIssueDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Detailed Issue Information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueDetailOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "get_issue_detail",
          "getIssueDetail"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issues": {
      "patch": {
        "summary": "Find The Jira issues.",
        "description": "Find Jira issues\n\nIn order to inquire about any issues within the project, you must first inquire about the project and find out the key of the project.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "condition of request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetIssueInputByBasicAuth"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "paginated list of issues visible to the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "get_issues",
          "getIssues"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-projects": {
      "patch": {
        "summary": "Find the Jira projects.",
        "description": "Find the Jira projects\n\nThe Jira project has a unique key and can then be used to query issues with the key.\nReturns a paginated list of projects visible to the user.\n\nIn order to inquire about any issues within the project, you must first inquire about the project and find out the key of the project.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "condition of request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetProjectInputByBasicAuth"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "paginated list of projects visible to the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetProjectOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "get_projects",
          "getProjects"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-labels": {
      "patch": {
        "summary": "Find issue labels",
        "description": "Find issue labels",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetIssueLabelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "paginated list of labels",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueLabelOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "get_issue_labels",
          "getIssueLabels"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-types": {
      "patch": {
        "summary": "Find issue types",
        "description": "Find issue types\n\nIn order for the user to inquire about the issue type, the ID of the project is required.\nIf the user mentioned the key or name of the project,\nit is necessary to first inquire the project and get the correct project ID.\nThe ID of the project is a numeric character type.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetIssueTypeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "issue types",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueTypeOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "get_issue_types",
          "getIssueTypes"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-statuses": {
      "patch": {
        "summary": "Find issue statuses",
        "description": "Find issue statuses for searching issue",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetIssueStatusInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "issue statuses",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueStatusOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "get_issue_statuses",
          "getIssueStatus"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-priorities": {
      "patch": {
        "summary": "Inquire the priority levels that can be assigned to the issue.",
        "description": "There are five priorities: 'Highest', 'High', 'Medium', 'Low', and 'Lowest'.\nTherefore, it can be used as an enum value without requesting this API,\nand this API is already deprecated on the Jira REST API document.\nHowever, for projects that can already be specified by creating a priority level, this connector is added just in case.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetIssuePriorityInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "issue priorities",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MyPickIJira.Prioritynameid"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "get_issue_priorities",
          "getIssuePriorities"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/get-users-assignable": {
      "patch": {
        "summary": "Find assignable users in issue",
        "description": "Find a person within the issue who can be assigned as assignee.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetIssueAssignableInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "assignable users",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "issues",
          "get_users_assignable",
          "getUsersAssignableInIssue"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/projects/get-users-assignable": {
      "patch": {
        "summary": "Find assignable users in project",
        "description": "Find a person within the project who can be assigned as assignee.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetProjectAssignableInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "assignable users",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "projects",
          "get_users_assignable",
          "getUsersAssignableInProject"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-status-categories": {
      "patch": {
        "summary": "get status categories",
        "description": "Get status categories",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IGetStatusCategoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IJira.StatusCategory"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "jira",
          "get_status_categories",
          "getStatusCategories"
        ],
        "x-samchon-controller": "JiraController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/google-map/autocomplete": {
      "patch": {
        "summary": "Returns predictions for the given input in Google Maps",
        "description": "recommendations for automatic completion or location through a search word or a latitude coordinate value to be used with the search word.\n\nSince it is a text auto-completion, this feature allows you to find better search keywords.\nHowever, since there is a separate connector for searching the surrounding geography, it is recommended to use that connector if you want to find a place that is not a keyword.\nIt is recommended that you use this connector to narrow down the search keyword before writing the place search connector.",
        "tags": [
          "Google Map"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleMap.IAutocompleteInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleMap.IAutocompleteOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_map",
          "autocomplete"
        ],
        "x-samchon-controller": "GoogleMapController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMap_full.svg"
      }
    },
    "/connector/google-map/review": {
      "patch": {
        "summary": "Search Google Map restaurant reviews",
        "description": "Search for restaurant reviews selected from Google Maps",
        "tags": [
          "Google Map"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Unique id of the restaurant",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleMap.IReviewRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Restaurant review search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleMap.IReviewResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_map",
          "review"
        ],
        "x-samchon-controller": "GoogleMapController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMap_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "구글 맵에서 식당 리뷰 좀 봐줘",
          "식당 리뷰 좀 보고 알려줘"
        ]
      }
    },
    "/connector/google-map/search-text": {
      "patch": {
        "summary": "Search by text in Google Maps",
        "description": "General search functionality on Google Maps\n\nIf possible, it is recommended to use POST/connector/google-map/search-text connector rather than this.\nHere, it is difficult to conduct additional search after providing information to users because only restaurants are searched using the Serp API and the response parameter does not provide a Google Map link.",
        "tags": [
          "Google Map"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Keyword",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleMap.ISearchTextInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleMap.ISearchTextOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_map",
          "search_text",
          "searchText"
        ],
        "x-samchon-controller": "GoogleMapController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMap_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "구글 맵에서 \"강남\" 이라는 키워드로 장소 검색 좀 해줘"
        ]
      }
    },
    "/connector/google-map": {
      "patch": {
        "summary": "Google Map restaurant search",
        "description": "Search for restaurants using Google Maps",
        "tags": [
          "Google Map"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search term to search for restaurants",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleMap.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Restaurant search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleMap.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_map",
          "search"
        ],
        "x-samchon-controller": "GoogleMapController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMap_full.svg",
        "x-wrtn-standalone": true,
        "x-wrtn-function-select-benchmarks": [
          "구글 맵에서 식당 좀 찾아줘"
        ]
      }
    },
    "/connector/github/users/get-received-events": {
      "patch": {
        "summary": "List events received by the authenticated user",
        "description": "List events received by the authenticated user\n\nThese are events that you've received by watching repositories and following users.\nIf you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.\nIn this case, the \"received\" event includes the repository that the user is interested in or the activity of the user who is following,\nfor example, if the user has pushed to the repository, or if an issue has been created from the repository that the user is interested in.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for Getting Received Event",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetReceivedEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Received Event of user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "users",
          "get_received_events",
          "getReceivedEvents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 유저의 최근 이벤트 알려줘"
        ]
      }
    },
    "/connector/github/users/get-pinned-repositories": {
      "patch": {
        "summary": "Inquire the user's pinned repository names",
        "description": "Inquire the user's pinned repositories\n\nInquire up to 6 repositories where the user has pinned.\nHere, only the name of the repository is searched, so if necessary, find detailed information about the repository by pageing the user's repository list.\nPlacing a pin in a repository is most likely a repository that users are most confident in.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserPinnedRepositoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "repositories",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "users",
          "get_pinned_repositories",
          "getUserPinnedRepositories"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 유저의 대표 레포지토리들 조회해줘",
          "Github에서 유저가 핀 꽂은 레포들 알려줘"
        ]
      }
    },
    "/connector/github/users/get-repositories": {
      "patch": {
        "summary": "Inquire the user's repositories",
        "description": "Inquire the user's repositories\n\nSince it contains only the simplest information of the repository here, there is no way to know the lead me of the repository or detailed information.\nIt is recommended to use additional connectors to explore because other connectors have the ability to read leads or internal files in the repository.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserRepositoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "repositories",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetUserRepositoryOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "users",
          "get_repositories",
          "getUserRepositories"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 유저의 레포지토리들 조회해줘",
          "Github에서 유저 레포들 알려줘"
        ]
      }
    },
    "/connector/github/organizations/users/get-events": {
      "patch": {
        "summary": "Lists organization events for the authenticated user",
        "description": "Lists organization events for the authenticated user\n\nThis API endpoint retrieves events that have occurred within the organizations\nthe authenticated user is a member of. It includes activities such as issues,\npull requests, commits, and other actions taken within the organization's repositories.\n\nThe events cover all repositories within the organization that the user has access to,\nmaking it useful for tracking the organization's activity or monitoring the progress\nof projects that the user is involved in within the team.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetOrganizationEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of events from the organizations the authenticated user is a member of.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "organizations",
          "users",
          "get_events",
          "getUserOrganizationEvents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 organization에서 특정 유저 이벤트 조회해줘"
        ]
      }
    },
    "/connector/github/organizations/get-issues": {
      "patch": {
        "summary": "List organization issues assigned to the authenticated user",
        "description": "List organization issues assigned to the authenticated user\n\nSimilar to the 'get-issues' connector, it is suitable for inquiring only about issues assigned within a specific organization.\nNaturally, the user will have to be a member of that organization.\n\nHere, the result value can be inquired together with PR because PR on GitHub is essentially an issue-like object.\nIf you want to see the issue separately, you should use a connector that looks up the issue in the repo, not the organization.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetOrganizationAuthenticationUserIssueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetOrganizationAuthenticationUserIssueOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "organizations",
          "get_issues",
          "getOrganizationIssues"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 organization에 생성되어 있는 이슈 좀 봐줘"
        ]
      }
    },
    "/connector/github/organizations/get-repositories": {
      "patch": {
        "summary": "List organization repositories",
        "description": "List organization repositories\n\nThis endpoint allows you to list all repositories that belong to a specified organization on GitHub.\nIt's useful for viewing all the repositories under an organization’s account, including both public and private repositories, depending on your access level.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetOrganizationEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetOrganizationRepositoryOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "organizations",
          "get_repositories",
          "getOrganizationRepositories"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 organization에 생성되어 있는 레포 좀 봐줘"
        ]
      }
    },
    "/connector/github/organizations/get-events": {
      "patch": {
        "summary": "List public organization events.",
        "description": "List public organization events\n\nIf you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.\n\nThis API endpoint retrieves a stream of public events that have occurred\nwithin a specified organization. These events include activities such as\nrepository creation, issues, pull requests, and other actions taken by members\nof the organization across all its public repositories.\n\nThis is useful for monitoring the public activity within an organization,\nproviding insights into how the organization is managing its projects,\nthe work being done by its members, and the overall public engagement with\nits repositories.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetOrganizationEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "organizations",
          "get_events",
          "getOrganizationEvents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 organization에서 이벤트 조회해줘"
        ]
      }
    },
    "/connector/github/repos/get-collaborators": {
      "patch": {
        "summary": "List repository collaborators",
        "description": "List repository collaborators\n\nFor organization-owned repositories, the list of collaborators includes outside collaborators,\norganization members that are direct collaborators, organization members with access through team memberships,\norganization members with access through default organization permissions, and organization owners.\nOrganization members with write, maintain, or admin privileges on the organization-owned repository can use this endpoint.\nTeam members will include the members of child teams.\n\nYou can refer to it before specifying a person in charge of the issue or a reviewer for PR.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCollaboratorInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetCollaboratorOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "get_collaborators",
          "getCollaborators"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 내 레포 코드 리뷰해줄 사람 찾아줘",
          "Github에서 레포 콜라보레이터 조회해줘"
        ]
      }
    },
    "/connector/github/repos/commits/contents": {
      "delete": {
        "summary": "Delete file content and commit",
        "description": "Delete file content in github repository\n\nTo delete file content is the same as creating a single commit.\nCommit is a hash that must be created in github to save changes, such as uploading, modifying, deleting, and so on.\n\nAs the sha value of the file to be modified, a conflict may occur if it is not the latest sha value among the sha values of the file.\nIt's safe when you look up a list of files through API to check sha and put in a value, or want to re-modify the sha value of a file you just created.\n\nIf the user directly asks you to add, modify, or delete a file for a specific PR or specific branch, this connector should be considered.\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IDeleteFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "commits",
          "contents",
          "deleteFileContents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 방금 커밋한 거 취소해줘",
          "Github에서 커밋된 파일 삭제해줘"
        ]
      },
      "put": {
        "summary": "Update File content and commit",
        "description": "Update file content in github repository\n\nUpdating file content is the same as creating a single commit.\nCommit is a hash that must be created in github to save changes, such as uploading, modifying, deleting, and so on.\n\nAs the sha value of the file to be modified, a conflict may occur if it is not the latest sha value among the sha values of the file.\nIt's safe when you look up a list of files through API to check sha and put in a value, or want to re-modify the sha value of a file you just created.\n\nIf you modify a file, it's not like appending the code to the file, it's like overwriting the file.\nGenerally, if a user says he wants to modify it, it means that he wants to add the code to a specific file or refact it,\nso it's right to check the existing code and then change some of the contents to the original to reflect it.\nIn addition, it is recommended to receive confirmation from the user every time about the content and then modify or add it.\n\nIf the user directly asks you to add, modify, or delete a file for a specific PR or specific branch, this connector should be considered.\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message.\n\nThe input property, which means the content of a file, changes to base64 inside that connector when written in human-recognizable natural language. So, do not encode any writing into base64.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "description": "test",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IUpdateFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IUpsertFileContentOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "commits",
          "contents",
          "updateFileContents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 커밋 수정해줘"
        ]
      },
      "post": {
        "summary": "Create File content and commit",
        "description": "Create file content in github repository\n\nIf the file already exists in the same path, you should use the modification API and this connector is only responsible for generation.\nCreating file content is the same as creating a single commit.\nCommit is a hash that must be created in github to save changes, such as uploading, modifying, deleting, and so on.\n\nIf someone says they want to add a file to the repo it's like they want to commit.\nHowever, in this case, you should check which branch you want to add the file to, and you should not create it in the default branch if you do not specify the branch.\nUsers value branches that reflect their commitments.\nIn addition, it is recommended to receive confirmation from the user every time about the content and then modify or add it.\n\nIf the user directly asks you to add, modify, or delete a file for a specific PR or specific branch, this connector should be considered.\n\nThe input property, which means the content of a file, changes to base64 inside that connector when written in human-recognizable natural language. So, do not encode any writing into base64.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IUpsertFileContentOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "commits",
          "contents",
          "createFileContents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 커밋해줘",
          "Github에서 커밋 추가해줘"
        ]
      }
    },
    "/connector/github/repos/get-folder-structures": {
      "patch": {
        "summary": "Review Repository Folder Structure",
        "description": "Review Repository Folder Structure\n\nIt allows you to know the overall folder structure by traversing files in the repository.\nThis feature is intended to navigate like a DFS based on folders.\nIf this function is so vast that you cannot see the entire folder, you can pass the `path` again to inquire.\nThe `path` delivered is treated like a Root folder and continues the navigation from this folder.\nThis feature is designed to navigate to the inside two more times, up to steps 0, 1 at a time, based on the root folder.\n\nIf you want to know the details of the file, it is recommended to use the get-contents connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetRepositoryFolderStructureInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/RepositoryFolderchildrenany"
                      },
                      {
                        "$ref": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                      }
                    ],
                    "discriminator": {
                      "propertyName": "type",
                      "mapping": {
                        "dir": "#/components/schemas/RepositoryFolderchildrenany",
                        "file": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "get_folder_structures",
          "getRepositoryFolderStructures"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 레포 폴더 구조 조회해줘",
          "Github에서 레포 폴더 구조 봐줘"
        ]
      }
    },
    "/connector/github/repos/get-contents/bulk": {
      "patch": {
        "summary": "Look up repository files(bulk)",
        "description": "Look up repository files(bulk)\n\nIf the file you want to inquire is a folder, internal files are provided in an array,\nand if it is a file, it inquires about the encoding method of the file and the body content of the file.\nSince there may be countless files and folders in the github repository, there may be many files that exceed the rate limit.\nIn this case, you can try to solve this problem by sequentially finding the folders one by one using the corresponding connector.\nYou can pass multiple file paths to view multiple files at the same time.\nThere is no limit to the number of files.\n\nThis is suitable for viewing files on specific branches, but if the user is for the purpose of viewing details of code reviews or PR, it is recommended to use a different connector.\nThere are connectors that view the list of files changed in PR, or see the changes.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetBulkFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "array",
                        "items": {
                          "oneOf": [
                            {
                              "$ref": "#/components/schemas/IGithub.RepositoryFolder"
                            },
                            {
                              "$ref": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                            }
                          ],
                          "discriminator": {
                            "propertyName": "type",
                            "mapping": {
                              "dir": "#/components/schemas/IGithub.RepositoryFolder",
                              "file": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                            }
                          }
                        }
                      },
                      {
                        "$ref": "#/components/schemas/IGithub.RepositoryFile"
                      },
                      {
                        "type": "object",
                        "properties": {
                          "type": {
                            "const": "null",
                            "title": "type"
                          },
                          "size": {
                            "const": 0,
                            "title": "size"
                          },
                          "message": {
                            "const": "No files exist corresponding to the path.",
                            "title": "message"
                          }
                        },
                        "required": [
                          "type",
                          "size",
                          "message"
                        ]
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "get_contents",
          "bulk",
          "getBulkFileContents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 여러 개 읽어서 한 번에 유저가 짠 코드 좀 봐줘",
          "Github에서 여러 개 읽어서 한 번에 레포 코드 좀 봐줘"
        ]
      }
    },
    "/connector/github/repos/get-contents": {
      "patch": {
        "summary": "Look up repository files",
        "description": "Look up repository files\n\nIf the file you want to inquire is a folder, internal files are provided in an array,\nand if it is a file, it inquires about the encoding method of the file and the body content of the file.\nSince there may be countless files and folders in the github repository, there may be many files that exceed the rate limit.\nIn this case, you can try to solve this problem by sequentially finding the folders one by one using the corresponding connector.\n\nThis is suitable for viewing files on specific branches, but if the user is for the purpose of viewing details of code reviews or PR, it is recommended to use a different connector.\nThere are connectors that view the list of files changed in PR, or see the changes.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "array",
                      "items": {
                        "oneOf": [
                          {
                            "$ref": "#/components/schemas/IGithub.RepositoryFolder"
                          },
                          {
                            "$ref": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                          }
                        ],
                        "discriminator": {
                          "propertyName": "type",
                          "mapping": {
                            "dir": "#/components/schemas/IGithub.RepositoryFolder",
                            "file": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                          }
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/IGithub.RepositoryFile"
                    },
                    {
                      "type": "object",
                      "properties": {
                        "type": {
                          "const": "null",
                          "title": "type"
                        },
                        "size": {
                          "const": 0,
                          "title": "size"
                        },
                        "message": {
                          "const": "No files exist corresponding to the path.",
                          "title": "message"
                        }
                      },
                      "required": [
                        "type",
                        "size",
                        "message"
                      ]
                    }
                  ]
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "get_contents",
          "getFileContents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 딱 파일 1개만 읽어서 유저가 짠 코드 좀 봐줘",
          "Github에서 딱 파일 1개만 읽어서 레포 코드 좀 봐줘"
        ]
      }
    },
    "/connector/github/repos/get-readme": {
      "patch": {
        "summary": "Read the README file",
        "description": "Read the README file in the repository\n\nREADME is one of the initial settings of the project and usually records a description of this repository,\nso it's useful if you want to see a rough description of the repository.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetReadmeFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "$ref": "#/components/schemas/IGithub.RepositoryFile"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "file": "#/components/schemas/IGithub.RepositoryFile"
                    }
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "get_readme",
          "getReadmeFile"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 리드미 내용 보고 레포 설명해줘",
          "Github에서 리드미 읽어줘"
        ]
      }
    },
    "/connector/github/repos/get-events": {
      "patch": {
        "summary": "List events for the authenticated user",
        "description": "List events for the authenticated user\n\nIf you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.\nYou can check all events surrounding the repository, such as who inquired and who forked.\nIt is used in conjunction with a connector that inquires the activity details and is suitable for checking how active the repository is.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetRepoEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repos",
          "get_events",
          "getRepoEvents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 레포 이벤트 조회해줘"
        ]
      }
    },
    "/connector/github/networks/get-events": {
      "patch": {
        "summary": "List public events for a network of repositories",
        "description": "Fetches events across all forks of a specified repository.\n\nThis API endpoint provides a stream of events that occur in any fork\nof the specified repository. It includes actions such as commits,\npull requests, issues, and other activity happening in the forked\nrepositories.\n\nUse this endpoint when you need to monitor the activity not just\nin the original repository, but also in all of its forks. This can\nbe particularly useful for understanding the broader impact or\nactivity surrounding a popular project that has been forked multiple\ntimes.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetRepoEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "networks",
          "get_events",
          "getNetworkRepoEvents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 레포 포크한 사람들 조회해줘"
        ]
      }
    },
    "/connector/github/users/get-events": {
      "patch": {
        "summary": "List events for the authenticated user.",
        "description": "List events for the authenticated user\n\nThis API endpoint retrieves a stream of events related to the authenticated user,\nincluding activities such as issues, pull requests, commits, and repository actions\nthat the user has participated in or been mentioned in. The events reflect the user's\ninteractions across all repositories they have access to, both public and private (if\nthe user has appropriate permissions).\n\nThis is useful for tracking a user's activity on GitHub, allowing you to see a\npersonalized feed of their involvement in various projects and interactions with\nother users.\n\nIf you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.\nIt looks up users' public events. Username should be your own nickname because you can usually only see your own events.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "users",
          "get_events",
          "getUserEvents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 내 개인 계정의 이벤트 조회해줘"
        ]
      }
    },
    "/connector/github/users/get-organizations": {
      "patch": {
        "summary": "List organizations for a user",
        "description": "List organizations for a user\n\nLook up the user's organization list, but since you can't look up the user's private organization here,\nyou can't really conclude that there isn't an empty array.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserOrganizationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetUserOrganizationOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "users",
          "get_organizations",
          "getUserOrganizations"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이 유저가 속한 Organization 조회해줘"
        ]
      }
    },
    "/connector/github/get-events": {
      "patch": {
        "summary": "List public events.",
        "description": "List public events\n\nThis API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.\nWhen I look up the events, they may not be of much value to the user because they are events that occurred on github.\n\nIt's looking up public events, and it's looking at events that occur on github regardless of the specific user.\nTherefore, it may not be of much use unless it is a special case.\nIf you want to get your information, it would be more advantageous to use the 'user/get-events' connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_events",
          "getEvents"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/get-activities": {
      "patch": {
        "summary": "Get Repository' activities",
        "description": "Get repository activities\n\nYou can use it to see how active your contribution is to the repository\nbecause it looks up all the activities that have occurred in the repository.\n\nThe types of activities that can be viewed here are as follows, and you can also find out by which user it was operated.\npush, force_push, branch_creation, branch_deletion, pr_merge, merge_queue_merge",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetRepositoryActivityInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetRepositoryActivityOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "get_activities",
          "getRepositoryActivities"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 레포의 최근 이력 좀 조회해줘"
        ]
      }
    },
    "/connector/github/repositories/pull-requests": {
      "put": {
        "description": "Update pull request\n\nUse to change the title or body of a PR, or draft status or open-close status.\nIt can also be used for overwriting labels or modifying them.\nIt can also be used to close or reopen pull request.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Update pull request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IUpdatePullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IUpdatePullRequestOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "updatePullRequest"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 수정해줘"
        ]
      },
      "post": {
        "description": "Create pull request\n\nCreates a pull request from a branch to a particular branch.\nIf the branch has already generated a pull request to the base branch, an error of 422 may occur.\nThis error indicates a collision because only one pull request from branch to another branch can exist open at the same time.\n\nIf the user wants to see each PR unit, this connector will be suitable.\n\nWhen creating a PR, be sure to specify the base branch and the head branch, and even if it can be omitted, be sure to include Titles and bodies as much as possible.\nYou can also create a pull request in draft state if necessary.\n\nIn order to create PR, you may need to refer to the PULL_REQUEST_TEMPLATE.md file that you specified in the .github folder in advance, in which case refer to the connector 'POST /connector/github/repos/get-contents'.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Create pull request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreatePullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.ICreatePullRequestOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "createPullRequest"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 생성해줘",
          "Github에서 PR 보내줘"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/get-comments": {
      "patch": {
        "summary": "List pull request comments",
        "description": "List pull request comments\n\nYou can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.\nIn any case, you can also view comments with the number on pull request.\nIssue comments are ordered by ascending ID.\n\nThis is actually the same as connector POST '/connector/github/repositories/issues/get-comments'.\nComments and reviews on PR are separate, you can only see comments on this connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetPullRequestCommentsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetIssueCommentsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "get_comments",
          "getPullRequestComments"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 댓글 보여줘",
          "Github에서 PR 댓글 봐줘"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/comments": {
      "post": {
        "summary": "Create an pull request comment",
        "description": "Create an pull request comment",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateIssueCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IssueComment"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "comments",
          "createPullRequestComments"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 댓글 좀 달아줘",
          "Github에서 PR 댓글 생성해줘"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/get-requested-reviewers": {
      "patch": {
        "summary": "Get all requested reviewers for a pull request",
        "description": "Get all requested reviewers\n\nGets the users or teams whose review is requested for a pull request.\nOnce a requested reviewer submits a review, they are no longer considered a requested reviewer.\nTheir review will instead be returned by the List reviews for a pull request operation.\n\nThe requested_reviewers are the ones who have been asked to review, but not yet.\nSo when you see someone who has reviewed a PR, if that person is someone who has already finished a review, he/she will be part of the reviewers, not the requested_reviewers.\nTherefore, when you look at a reviewer, you should look at it separately between someone who has not yet reviewed it and one person who has reviewed it, which you should also call other features to see together.\nRefer to connector `:post /connector/github/repositories/pull-requests/get-reviews`.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReadPullRequestRequestedReviewerOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "get_requested_reviewers",
          "readPullRequestRequestedReviewers"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이 PR 리뷰어 누구야?"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/requested-reviewers": {
      "delete": {
        "summary": "Remove requested reviewers from a pull request",
        "description": "Removes review requests from a pull request for a given set of users and/or teams\n\nYou should check the person who has already been requested as a reviewer, i.e., requested_reviewers, and then send out the delete request.\nEven if you don't do that, there will be no error, but it doesn't mean anything if you delete the person who hasn't been requested as a reviewer.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IRequestReviewerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "requested_reviewers",
          "removeRequestedReviewers"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이 PR에 리뷰어 해제해줘"
        ]
      },
      "post": {
        "summary": "Request reviewers for a pull request",
        "description": "Request reviewers for a pull request\n\nRequests reviews for a pull request from a given set of users and/or teams. This endpoint triggers notifications.\nYou can specify a reviewer by the user's name alone, but not by anyone, so use a connector that looks up collaborators first.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IRequestReviewerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "requested_reviewers",
          "requestReviewers"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이 PR에 리뷰어 지정해줘"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/reviews/get-comments": {
      "patch": {
        "summary": "List comments for a pull request review",
        "description": "List comments for a pull request review\n\nLists comments for a specific pull request review.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetReviewCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetReviewCommentOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "reviews",
          "get_comments",
          "readReviewComments"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 리뷰에 달린 답글 좀 보여줘"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/get-reviews": {
      "patch": {
        "summary": "List reviews for a pull request",
        "description": "List reviews for a pull request\n\nPull Request Reviews are groups of pull request review comments on a pull request, grouped together with a state and optional body comment.\nLists all reviews for a specified pull request. The list of reviews returns in chronological order.\nSince github distinguishes requested_reviewers from those who have already completed the review,\nif you want to see a review for any PR, you should look up both of these connectors.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestReviewInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReadPullRequestReviewOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "get_reviews",
          "readReviews"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 리뷰 조회해줘",
          "Github에서 PR에 리뷰 있어?"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/reviews": {
      "post": {
        "summary": "Create a review for a pull request",
        "description": "Create a review for a pull request\n\nPull request reviews created in the PENDING state are not submitted and therefore do not include the submitted_at property in the response. To create a pending review for a pull request, leave the event parameter blank.\nThe position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReviewPullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReviewPullRequestOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "reviews",
          "reviewPullRequest"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR에 리뷰 좀 달아줘"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/get-files": {
      "patch": {
        "summary": "List pull requests files",
        "description": "List pull requests files\n\nThis is useful to see what files are contained in that PR.\nEach file's patch contains the entire format of the file.\nHowever, if you want to know the changes, you should look up diff, which is implemented with a different connector, so you'd better refer to it.\n\nIf the user wants to see each PR unit, this connector will be suitable.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReadPullRequestFileOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "get_files",
          "readPullRequestFiles"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 파일 좀 조회해봐"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/get-commits": {
      "patch": {
        "description": "List commits on a pull request\n\nLists a maximum of 250 commits for a pull request.\nTo receive a complete commit list for pull requests with more than 250 commits, use the List commits endpoint.\n\nIf the user wants to see each PR unit, this connector will be suitable.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestCommitInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReadPullRequestCommitOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "get_commits",
          "readPullRequestCommits"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 커밋 목록 가져와봐"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/get-diff": {
      "patch": {
        "summary": "Get a diff of pull request",
        "description": "Get a diff of pull-request info\n\nThis is the same as PR's ability to query files,\nbut the format that this function returns is a string, which is more suitable for identifying changes to each file than viewing each file object,\nand in github, this is called the application/vnd.github.diff format.\nThis helps you see at a glance what codes have disappeared and been added in a form suitable for code review.\n\nIf the user wants to see each PR unit, this connector will be suitable.\n\nIf there are too many changes, the connector can export a 406 error.\nIn this case, it may be difficult to determine each change, but it is recommended to use the List pull requests connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "object",
                      "properties": {
                        "message": {
                          "type": "string",
                          "title": "Error Message"
                        },
                        "errors": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "resource": {
                                "const": "PullRequest"
                              },
                              "field": {
                                "const": "diff"
                              },
                              "code": {
                                "const": "too_large"
                              }
                            },
                            "required": [
                              "resource",
                              "field",
                              "code"
                            ]
                          },
                          "minItems": 1,
                          "maxItems": 1,
                          "title": "error objects"
                        },
                        "status": {
                          "type": "string",
                          "title": "error code"
                        }
                      },
                      "required": [
                        "message",
                        "errors",
                        "status"
                      ]
                    }
                  ]
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "get_diff",
          "readPullRequestDiff"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR의 변경점이 뭐야?"
        ]
      }
    },
    "/connector/github/repositories/pull-requests/get-detail": {
      "patch": {
        "summary": "Get a pull request",
        "description": "Get a deatiled pull-request info\n\nYou can view detailed PR information using the PR number.\nHere, you can see the branch to be merged and the information on the branch it points to, and you can see information such as the status of the PR, the time of each state, and the person who created the PR.\nHowever, it should be used with other connectors because it provides information close to the header of PR and does not provide information about each file or commit of PR.\n\nIf the user wants to see each PR unit, this connector will be suitable.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.PullRequest"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "pull_requests",
          "get_detail",
          "readPullRequestDetail"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이 PR에 대해 상세히 알려줘"
        ]
      }
    },
    "/connector/github/repositories/get-pull-requests": {
      "patch": {
        "summary": "Get Repository' pull request",
        "description": "List repository pull requests\n\nQuery pool requests to specific repositories.\nHere, you can filter issues and see only pool requests, and you can sort them by creation and inquiry dates, or filter by open or closed status.\nThe content of the body is omitted, so if you want to see it, you should use the detailed lookup connector.\nIf the user wants to see the body property, '/connector/github/repositories/pull-requests/get-detail' connector must be called.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IFetchRepositoryPullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IFetchRepositoryPullRequestOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "get_pull_requests",
          "getRepositoryPullRequest"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 PR 목록 좀 조회해줘"
        ]
      }
    },
    "/connector/github/repositories/issues/get-detail": {
      "patch": {
        "summary": "Get a issue",
        "description": "Get a deatiled issue info\n\nUnlike the body omitted from the issue list inquiry, it is suitable for viewing details as it can inquire all the contents.\nHowever, this connector alone cannot see all the comments or timelines inside, and other connectors must be used.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetIssueDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.DetailedIssue"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "issues",
          "get_detail",
          "getIssueDetail"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 레포 이슈 상세 내용을 조회해줘"
        ]
      }
    },
    "/connector/github/repositories/issues/get-comments": {
      "patch": {
        "summary": "List issue comments",
        "description": "List issue comments\n\nYou can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.\nIn any case, you can also view comments with the number on pull request.\nIssue comments are ordered by ascending ID.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetIssueCommentsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetIssueCommentsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "issues",
          "get_comments",
          "getIssueComments"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github 레포 이슈에 달린 댓글을 조회해줘"
        ]
      }
    },
    "/connector/github/repositories/issues/comments": {
      "post": {
        "summary": "Create an issue comment",
        "description": "Create an issue comment\n\nAdd a comment. If you put an issue number, you can add a comment to the issue, where the issue number is also the number of PR.\nIn other words, both issue and PR can add a comment through this connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateIssueCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IssueComment"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "issues",
          "comments",
          "createIssueComments"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github, 이 레포 이슈에 댓글 달아줘"
        ]
      }
    },
    "/connector/github/repositories/get-issues": {
      "patch": {
        "summary": "List repository issues",
        "description": "List repository issues\n\nList issues in a repository.\nThis connector is perfect if you want to see the issue of the repository because it can be viewed without being authenticated.\nInformation on the issue comes out, but only 10 people and labels attached to the issue are provided.\nTherefore, if you want more detailed information, it's a good idea to look at it with a connector that looks at the details of the issue.\nWhen looking up an issue, you can view open and closed issues and sort them by creation time, correction time, comment count, and reaction count.\nFor more information, you should check the properties part of the request type.\n\nThe content of the body is omitted, so if you want to see it, you should use the detailed lookup connector.\nIf the user wants to see the body property, '/connector/github/repositories/issues/get-detail' connector must be called.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IFetchRepositoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IFetchRepositoryOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "repositories",
          "get_issues",
          "getRepositoryIssues"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이 레포 이슈 목록 좀 가져와줘",
          "Github에서 레포에서 이슈 좀 찾아줄래?"
        ]
      }
    },
    "/connector/github/get-users": {
      "patch": {
        "summary": "Search for users by keyword in github",
        "description": "Search for users by keyword in github",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ISearchUserInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "list of user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.ISearchUserOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_users",
          "searchUser"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 Github 유저 검색해줘"
        ]
      }
    },
    "/connector/github/get-user-profile": {
      "patch": {
        "summary": "Look up the user's detailed profile",
        "description": "Look up the user's detailed profile",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserProfileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "detailed profile",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetUserProfileOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_user_profile",
          "getUserProfile"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 Github 유저 상세 보여줘"
        ]
      }
    },
    "/connector/github/get-organizations": {
      "patch": {
        "summary": "List organizations for the authenticated user",
        "description": "List organizations for the authenticated user\n\nInquire the user's repository.\nHere, the user is an authenticated user, which means a user of that token.\nIf a user does not select an organization at login or ask the organization's admin to link it,\nthe resource might not be viewed even if the token scope has permissions.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetAuthenticatedUserOrganizationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetAuthenticatedUserOrganizationOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_organizations",
          "getAuthenticatedUserOrganizations"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 내 Organization 조회해줘"
        ]
      }
    },
    "/connector/github/get-branches": {
      "patch": {
        "summary": "Inquire the user's branch",
        "description": "Inquire the user's branch\n\nYou can look up a list of branches in a specific repository.\nBecause it says what the last commit is, and when and to whom it was made,\nyou can see which of the branches is the latest and managed.\n\nYou shouldn't call the main branch arbitrarily because there may be people who use the master branch.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetBranchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetBranchOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_branches",
          "getRepositoryBranches"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 레포에서 브랜치 좀 조회해줘"
        ]
      }
    },
    "/connector/github/branches": {
      "post": {
        "summary": "Create branch",
        "description": "Create branch\n\nCreates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.\nYou need to know the sha of the commit, so if you want to create a branch, you should first call another connector that looks up the commit list or header commitments to find out the sha value.\nIf you want to copy the branch, you should also look up the commit history of the branch and then retrieve the sha value from the branch's HEAD commit.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateBranchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.ICreateBranchOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "branches",
          "createBranches"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 브랜치 생성해줘"
        ]
      }
    },
    "/connector/github/get-pull-requests-associated-with-a-commit": {
      "patch": {
        "summary": "get pull requests associated with a commit",
        "description": "List pull requests associated with a commit\n\nFetches the pull requests (PRs) associated with a specific commit in a GitHub repository.\nThis API endpoint retrieves a list of pull requests that include the specified commit.\nThis can be useful for tracking where and how a particular change was merged into a branch.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetPullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "pull requests associated with a commit",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StrictOmitIGithub.PullRequestcommentsmaintainer_can_modifymergeablerebaseablemergeable_statemerged_byreview_commentscommitsadditionsdeletionschanged_files"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_pull_requests_associated_with_a_commit",
          "getPullRequestAssociatedWithACommit"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-commit-heads": {
      "patch": {
        "summary": "Lists all branches that contain the HEAD commit",
        "description": "Lists all branches that contain the HEAD commit of a GitHub repository.\n\nThis function utilizes the GitHub API to retrieve a list of branches where the current\nHEAD commit (the latest commit on the checked-out branch) is included. This is useful for\ndetermining which branches contain the most recent changes.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCommitHeadInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A promise that resolves to an array of branch names that include the specified commit.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetCommitHeadOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_commit_heads",
          "getCommitHeads"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-commit": {
      "patch": {
        "summary": "Inquire the commit details of the user",
        "description": "Inquire the commit details of the user\nIt contains all the history of how the file changed, so you can see the details of a single commit node.\nIf you do not deliver ref, look up based on default_branch.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCommitInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "detailed commit history",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetCommitOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_commit",
          "getCommit"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 커밋 상세 보여줘"
        ]
      }
    },
    "/connector/github/get-commit-diff": {
      "patch": {
        "summary": "Inquire the commit diff of the user",
        "description": "Inquire the commit diff of the user\ndiff is Github's own content type specification that allows you to identify changes per commit on the Github homepage.\nIf you do not deliver ref, look up based on default_branch.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCommitInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "commit diff",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_commit_diff",
          "getCommitDiff"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 커밋 상세 보여주되 달라진 diff를 알려줘"
        ]
      }
    },
    "/connector/github/get-commit-list": {
      "patch": {
        "summary": "Look up the list of commitments for a specific repo, a specific branch",
        "description": "Look up the list of commitments for a specific repo, a specific branch\n\nThis function can be used in general because it sees the commit list in units of branches, but if the user wants to see it in units of PR, it is better to use another connector.\nIf the user specifies to view in PR units, use other connectors because there are connectors for viewing files, commit lists, and changes in PR units elsewhere.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCommitListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "list of commit",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetCommitListOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_commit_list",
          "getCommitList"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 커밋 목록 보여줘"
        ]
      }
    },
    "/connector/github/get-followers": {
      "patch": {
        "summary": "Inquire the followers of the user",
        "description": "Inquire the followers of the user\n\nThis value can be viewed by about 100 people at a time because it is a page-nated result.\nIf you have someone you're looking for, it's important to keep looking for the next page, even if you haven't found the value on the first page.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetFollowerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetFollowerOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_followers",
          "getFollowers"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 내 github 팔로워 보여줘"
        ]
      }
    },
    "/connector/github/get-followees": {
      "patch": {
        "summary": "Inquire the followees of the user",
        "description": "Inquire the followees of the user\n\nThis value can be viewed by about 100 people at a time because it is a page-nated result.\nIf you have someone you're looking for, it's important to keep looking for the next page, even if you haven't found the value on the first page.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetFolloweeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetFolloweeOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_followees",
          "getFollowees"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 내가 github에서 팔로우한 사람 보여줘"
        ]
      }
    },
    "/connector/github/get-labels": {
      "patch": {
        "summary": "List labels for a repository",
        "description": "List labels for a repository\n\nView a list of issues created and used in that repository.\nEach issue will only have labels that are already registered in this repository.\nOf course, it doesn't necessarily mean that you have to use only the labels here when creating issues,\nbut it would be beneficial to assign them by referring to the labels here.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetLabelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetLabelOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "get_labels",
          "getLabels"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이 레포에 사용 가능한 issue 라벨 보여줘"
        ]
      }
    },
    "/connector/github/issues": {
      "put": {
        "summary": "Update an issue",
        "description": "Update an issue in the repository\n\nUpdate an issue, where you can enter labels and assignes together.\nThe information you must enter is who will create the issue in the owner's repository and under what title.\nThe information in the text should follow the markdown grammar allowed by github.\n\nIn some cases, if you are not the owner of this repository, you may not be able to make any marking on issues such as labels, assignees, milestones, etc.\nIt can also be used to close or reopen issues.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IUpdateIssueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.Issue"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "issues",
          "updateIssue"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이슈 수정해줘"
        ]
      },
      "post": {
        "summary": "Create an issue",
        "description": "Leave an issue in the repository\n\nCreate an issue, where you can enter labels and assignes together.\nThe information you must enter is who will create the issue in the owner's repository and under what title.\nThe information in the text should follow the markdown grammar allowed by github.\n\nIn some cases, if you are not the owner of this repository, you may not be able to make any marking on issues such as labels, assignees, milestones, etc.\n\nIn order to create issue, you may need to refer to the issue template files that you specified in the .github folder in advance, in which case refer to the connector 'POST /connector/github/repos/get-contents'.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateIssueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.Issue"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "github",
          "issues",
          "createIssue"
        ],
        "x-samchon-controller": "GithubController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg",
        "x-wrtn-function-select-benchmarks": [
          "Github에서 이슈 생성해줘"
        ]
      }
    },
    "/connector/marp/convert-to-ppt": {
      "post": {
        "summary": "Convert Marp markdown to PPT",
        "description": "Convert Marp markdown to PPT and store in S3\n\nWhen you write a markdown according to marp grammar, you convert it to create an html file that contains all of that content.\nBecause users won't know the markdown and marp grammar, this should be automatically generated by LLM, and users just need to provide the format, image, text, etc. they want.\nSo, instead of asking the user to provide marp or markdown grammar, ask for hints on how to organize the template and how to deploy it.\nAsking the user to write according to the Marp grammar directly can be difficult, even if the other person is the developer!\nAll tasks such as making presentation materials or organizing contents with slides, such as pptx, google slides, html, markdown (marp), and hanshow, may have to go through a connector that changes marp to this pptx.\n\nWarning: If you put too much content on a single slide, the content may be cut out and invisible. Split the content into several slides.",
        "tags": [
          "Marp",
          "pptx",
          "hanshow",
          "ppt",
          "powerpoint",
          "markdown",
          "marp"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The Marp markdown string",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMarp.IConvertInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The S3 link of the converted PPT",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMarp.IConvertOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "marp",
          "convert_to_ppt",
          "convertToPpt"
        ],
        "x-samchon-controller": "MarpController"
      }
    },
    "/connector/x/get-users": {
      "patch": {
        "summary": "Get User Information",
        "description": "Get User Information by username",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "username",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IX.IUserInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "user information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IX.IUserOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "x",
          "get_users",
          "getUsers"
        ],
        "x-samchon-controller": "XController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/X_full.svg"
      }
    },
    "/connector/x/get-influencers": {
      "patch": {
        "summary": "Get information on celebrities.",
        "description": "Get X user information of celebrities. Useful for understanding trends in various fields such as world affairs and IT.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "username",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IX.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "user information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IX.IUserOutput"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "x",
          "get_influencers",
          "getPreDefinedInfluencers"
        ],
        "x-samchon-controller": "XController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/X_full.svg"
      }
    },
    "/connector/x/prepare-summarize": {
      "post": {
        "summary": "Prepare Tweet Summary",
        "description": "Fetches and indexes the tweets of given users requested.\n\nBefore executing fetches and indexes the tweets, you must call the /get-users or /get-influencers endpoint to get user information.\n\nYou should put as many users as you want to fetch tweets from.\n\nThis endpoint is designed to handle multiple users efficiently.\n\nIt already get information from multiple user's, you must not make multiple requests to this endpoint to fetch tweets from multiple users. you must use the results from a single request.\n\nFor example, if you are fetch tweets from multiple users and have a summary request, you must use the results from only one request to summarize the tweets for each user.\n\nYou must use the /summarize endpoint to proceed with the summary after fetching the tweet, do not allow this endpoint to be used just for summarization.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "user information, secretKey, query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IX.IPrePareSummarizeTweetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IX.IPrePareSummarizeTweetOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "x",
          "prepare_summarize",
          "prepareSummary"
        ],
        "x-samchon-controller": "XController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/X_full.svg"
      }
    },
    "/connector/x/summarize": {
      "post": {
        "summary": "Tweet Summary",
        "description": "Summarizes the tweets of those requested them.\n\nNote that this endpoint is intended to be used for a single keyword or subject.\n\nIf you need to summarize multiple keywords or subjects, you must make multiple requests for each keyword or subject no exceptions.\n\nFor example, if you want to summarize tweets about \"Elon Musk\" and \"AI\", make two requests, one for \"Elon Musk\" and one for \"AI\".\n\nYou must assume that the results may contain irrelevant tweets against the query. You must filter the results based on the query. Do your best to cherry-pick the relevant tweets only.\n\nAny tweet that are not relevant to the query must be ignored, even if that tweet is related to the user request, not the query.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "user information, secretKey, query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IX.ISummarizeTweetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IX.IGetChunkDocumentOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "x",
          "summarize",
          "summarizeTweet"
        ],
        "x-samchon-controller": "XController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/X_full.svg"
      }
    },
    "/connector/x/general-search": {
      "patch": {
        "summary": "General Search Tweets",
        "description": "Search for tweets based on search query requested by the user.\n\nYou need to analyze the user's request and retrieve tweets through natural language queries (search terms).\n\nFor example, when a user requests \"Search for books that are trending on Twitter these days,\" the query (search term) should be natural language, not a keyword, such as \"trending books.\"",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IX.IGeneralSearchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IX.IGeneralSearchResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "x",
          "general_search",
          "generalSearch"
        ],
        "x-samchon-controller": "XController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/X_full.svg"
      }
    },
    "/connector/reddit/get-hot-posts": {
      "patch": {
        "summary": "Get hot posts from Reddit",
        "description": "Retrieves hot posts from Reddit.\n\nThis API fetches the most popular posts currently trending on Reddit.\nThe input requires a subreddit name and optional parameters for filtering.\nThe output provides a list of hot posts with details such as title, author, and score.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetHotPostsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetHotPostsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_hot_posts",
          "getHotPosts"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-new-posts": {
      "patch": {
        "summary": "Get new posts from Reddit",
        "description": "Retrieves new posts from Reddit.\n\nThis API fetches the latest posts from a specified subreddit.\nThe input requires a subreddit name and optional parameters for pagination.\nThe output provides a list of new posts with details such as title, author, and timestamp.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetNewPostsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetNewPostsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_new_posts",
          "getNewPosts"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-top-posts": {
      "patch": {
        "summary": "Get top posts from Reddit",
        "description": "Retrieves top posts from Reddit.\n\nThis API fetches the highest-rated posts from a specified subreddit over a given time period.\nThe input requires a subreddit name and a time filter (e.g., day, week, month).\nThe output provides a list of top posts with details such as title, author, and score.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetTopPostsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetTopPostsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_top_posts",
          "getTopPosts"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-comments": {
      "patch": {
        "summary": "Get comments from a Reddit post",
        "description": "Retrieves comments from a Reddit post.\n\nThis API fetches comments for a specific Reddit post.\nThe input requires the post ID and subreddit name.\nThe output provides a list of comments with details such as author, content, and score.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetCommentsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetArticleAndCommentsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_comments",
          "getComments"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-user-about": {
      "patch": {
        "summary": "Get information about a Reddit user",
        "description": "Retrieves information about a Reddit user.\n\nThis API fetches profile information for a specified Reddit user.\nThe input requires the username.\nThe output provides user details such as karma, account age, and recent activity.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetUserAboutInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetUserAboutOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_user_about",
          "getUserAbout"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-user-submitted": {
      "patch": {
        "summary": "Get posts submitted by a Reddit user",
        "description": "Retrieves posts submitted by a Reddit user.\n\nThis API fetches posts submitted by a specified Reddit user.\nThe input requires the username.\nThe output provides a list of submitted posts with details such as title, subreddit, and score.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetUserSubmittedInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetUserSubmittedOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_user_submitted",
          "getUserSubmitted"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-user-comments": {
      "patch": {
        "summary": "Get comments made by a Reddit user",
        "description": "Retrieves comments made by a Reddit user.\n\nThis API fetches comments made by a specified Reddit user.\nThe input requires the username.\nThe output provides a list of comments with details such as content, subreddit, and score.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetUserCommentsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IFlattenCommentsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_user_comments",
          "getUserComments"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/search-subreddits": {
      "patch": {
        "summary": "Search for subreddits on Reddit",
        "description": "Searches for subreddits on Reddit.\n\nThis API allows searching for subreddits based on a query string.\nThe input requires a search query.\nThe output provides a list of subreddits matching the query with details such as name and subscriber count.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.ISearchSubredditsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.ISearchSubredditsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "search_subreddits",
          "searchSubreddits"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-subreddit-about": {
      "patch": {
        "summary": "Get information about a subreddit",
        "description": "Retrieves information about a subreddit.\n\nThis API fetches detailed information about a specified subreddit.\nThe input requires the subreddit name.\nThe output provides details such as description, subscriber count, and rules.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetSubredditAboutInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetSubredditAboutOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_subreddit_about",
          "getSubredditAbout"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-popular-subreddits": {
      "patch": {
        "summary": "Get popular subreddits",
        "description": "Retrieves popular subreddits.\n\nThis API fetches a list of currently popular subreddits.\nThe output provides details such as subreddit name and subscriber count.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetPopularSubredditsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetPopularSubredditsOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_popular_subreddits",
          "getPopularSubreddits"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/reddit/get-best-content": {
      "patch": {
        "summary": "Get the best content from Reddit",
        "description": "Retrieves the best content from Reddit.\n\nThis API fetches the best-rated content from Reddit.\nThe output provides a list of top-rated posts with details such as title, author, and score.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IReddit.IGetBestContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IReddit.IGetBestContentOutput"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "reddit",
          "get_best_content",
          "getBestContent"
        ],
        "x-samchon-controller": "RedditController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/reddit_full.svg"
      }
    },
    "/connector/crawler/get-web-content": {
      "patch": {
        "summary": "Get HTML content from the URL",
        "description": "Get HTML content from the URL\n\nThis API accepts a URL as input and returns the HTML content of the body of the corresponding web page.\nIt fetches only the <body> element, excluding the head and other parts of the HTML structure, providing developers\nwith a streamlined way to access the main content of a web page for further processing or analysis.\n\nThe API includes a \"Wait For Selector\" option, allowing it to wait for a specific CSS selector\nto be present in the DOM before returning the content.\nThis is useful for ensuring that dynamic elements or data are fully loaded.",
        "tags": [
          "Web Crawler"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IWebCrawler.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IWebCrawler.IResponse"
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "crawler",
          "get_web_content",
          "getWebContent"
        ],
        "x-samchon-controller": "WebCrawlerController"
      }
    },
    "/connector/google-image": {
      "patch": {
        "summary": "Search Google Image",
        "description": "Search Google for images based on the search terms you enter",
        "tags": [
          "Google Image"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Image Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleImage.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Image search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleImage.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-samchon-accessor": [
          "connector",
          "google_image",
          "search"
        ],
        "x-samchon-controller": "GoogleImageController",
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleImage_full.svg",
        "x-wrtn-function-select-benchmarks": [
          "구글에서 이미지 좀 검색해줘"
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "IArticle.ISync.ToDevToOutput": {
        "type": "object",
        "properties": {
          "isSuccess": {
            "type": "boolean",
            "title": "response",
            "description": "Indicates whether synchronization is successful or not"
          },
          "article": {
            "$ref": "#/components/schemas/StrictOmitIArticleIArticle.ISnapshotpassword",
            "title": "article information"
          }
        },
        "required": [
          "isSuccess",
          "article"
        ]
      },
      "StrictOmitIArticleIArticle.ISnapshotpassword": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of article",
            "description": "The most recent snapshot made is the higher version,\nand in fact, this time value can serve as the version."
          },
          "external_user_id": {
            "type": "string",
            "format": "uuid",
            "title": "External User ID"
          },
          "snapshots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IArticle.ISnapshot"
            },
            "minItems": 1,
            "title": "List of snapshot contents",
            "description": "It is created for the first time when an article is created, and is\naccumulated every time the article is modified."
          },
          "deleted_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "Deletion time of article"
          }
        },
        "required": [
          "id",
          "created_at",
          "external_user_id",
          "snapshots",
          "deleted_at"
        ]
      },
      "IArticle.ISnapshot": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of snapshot record",
            "description": "In other words, creation time or update time or article"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IAttachmentFile"
            },
            "title": "List of attachment files"
          },
          "bbs_article_exports": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IArticleExport"
            },
            "title": "History of this snapshot being exported",
            "description": "If it has been exported,\nthe location of the export will be recorded in the properties."
          },
          "title": {
            "type": "string",
            "title": "Title of article",
            "description": "Title of article."
          },
          "format": {
            "const": "md",
            "title": "format",
            "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
          },
          "body": {
            "type": "string",
            "title": "Content body of article",
            "description": "Content body of article."
          }
        },
        "required": [
          "id",
          "created_at",
          "files",
          "bbs_article_exports",
          "title",
          "format",
          "body"
        ]
      },
      "IAttachmentFile": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key",
            "description": "Primary Key."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "date time for creation of this file"
          },
          "name": {
            "type": "string",
            "maxLength": 255,
            "title": "File name",
            "description": "File name, except extension.\n\nPossible to make empty string like `.gitignore` case."
          },
          "extension": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "minLength": 1,
                "maxLength": 8
              }
            ],
            "title": "File extension",
            "description": "Extension.\n\nPossible to omit like `README` case.\nExtensions must exclude dot characters."
          },
          "url": {
            "type": "string",
            "format": "uri",
            "title": "File url",
            "description": "URL path of the real file.\n\nIn addition to the case of attaching a file,\nit is recommended to attach the URL address of the file when linking within the markdown document."
          }
        },
        "required": [
          "id",
          "created_at",
          "name",
          "extension",
          "url"
        ],
        "title": "Attachment File"
      },
      "IArticleExport": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "bbs_article_snapshot_id": {
            "type": "string",
            "format": "uuid",
            "title": "Snapshot ID"
          },
          "provider": {
            "type": "string",
            "title": "provider name",
            "description": "It means the name of the service from which the article was exported,\nand if the service name is motion,\nit means that the same article is posted in the corresponding url of the provider service."
          },
          "uid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Unique Document ID in external service"
          },
          "url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "URL",
            "description": "This is a redirect link that allows you to locate the exported document,\nwhich is stored at export time."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of {@link IArticleExport}"
          },
          "deleted_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "Deletion time ot {@link IArticleExport}"
          }
        },
        "required": [
          "id",
          "bbs_article_snapshot_id",
          "provider",
          "uid",
          "url",
          "created_at",
          "deleted_at"
        ]
      },
      "IArticle.ISync.ToDevToInput": {
        "type": "object",
        "properties": {
          "dev_to": {
            "type": "object",
            "properties": {
              "secretKey": {
                "type": "string",
                "x-wrtn-secret-key": "dev_to",
                "x-wrtn-secret-scopes": [],
                "title": "Dev.to API Key for synchronization"
              }
            },
            "required": [
              "secretKey"
            ],
            "title": "Dev.to API Key for synchronization"
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "from": {
                "type": "string",
                "format": "uuid",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "ID of the snapshot to be previously synchronized",
                "description": "The user synchronizes the text associated with that snapshot.\n\nFor example, when you have v1 and v2,\nif you pass v1 by ID,\nyou replace the exported document in snapshot v1 with the exported document\nin v2 and update the properties,\nincluding the title and content of the exported document.\n\nIf you want to synchronize the notion documents linked to the snapshot at once,\nplease only forward the snapshot's ID (=`from` property).\nIf you want to synchronize only some of the documents exported from that snapshot, pass only the ID of bbs_article_exports.\nbbs_article_exports is the point of connection between snapshots and documents exported from those snapshots."
              },
              "to": {
                "type": "string",
                "format": "uuid",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "The ID of the snapshot that will be after synchronization"
              },
              "article_snapshot_exports": {
                "type": "object",
                "properties": {
                  "ids": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "uuid"
                    },
                    "minItems": 1,
                    "title": "IDs of IArticleExport",
                    "description": "IDs of {@link IArticleExport bbs_article_exports}\n\nIf you want to synchronize the notion documents linked to the snapshot at once,\nplease only forward the snapshot's ID (=`from` property).\nIf you want to synchronize only some of the documents exported from that snapshot, pass only the ID of bbs_article_exports.\nbbs_article_exports is the point of connection between snapshots and documents exported from those snapshots.\n\nIf it is to be specified, it must be an array of at least one size."
                  }
                },
                "required": [],
                "title": "Exported Document's information"
              }
            },
            "required": [
              "from",
              "to"
            ],
            "title": "snapshot information for synchronization"
          }
        },
        "required": [
          "dev_to",
          "snapshot"
        ]
      },
      "IArticle.ISync.ToGoogleDocsOutput": {
        "type": "object",
        "properties": {
          "isSuccess": {
            "type": "boolean",
            "title": "response",
            "description": "Indicates whether synchronization is successful or not"
          },
          "article": {
            "$ref": "#/components/schemas/StrictOmitIArticleIArticle.ISnapshotpassword",
            "title": "article information"
          }
        },
        "required": [
          "isSuccess",
          "article"
        ]
      },
      "IArticle.ISync.ToGoogleDocsInput": {
        "type": "object",
        "properties": {
          "google_docs": {
            "type": "object",
            "properties": {
              "secretKey": {
                "type": "string",
                "x-wrtn-secret-key": "google",
                "x-wrtn-secret-scopes": [
                  "https://www.googleapis.com/auth/drive.file"
                ],
                "title": "Google Docs Secret Key for synchronization"
              }
            },
            "required": [
              "secretKey"
            ],
            "title": "Google Docs SecretKey for synchronization"
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "from": {
                "type": "string",
                "format": "uuid",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "ID of the snapshot to be previously synchronized",
                "description": "The user synchronizes the text associated with that snapshot.\n\nFor example, when you have v1 and v2,\nif you pass v1 by ID,\nyou replace the exported document in snapshot v1 with the exported document\nin v2 and update the properties,\nincluding the title and content of the exported document.\n\nIf you want to synchronize the notion documents linked to the snapshot at once,\nplease only forward the snapshot's ID (=`from` property).\nIf you want to synchronize only some of the documents exported from that snapshot, pass only the ID of bbs_article_exports.\nbbs_article_exports is the point of connection between snapshots and documents exported from those snapshots."
              },
              "to": {
                "type": "string",
                "format": "uuid",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "The ID of the snapshot that will be after synchronization"
              },
              "article_snapshot_exports": {
                "type": "object",
                "properties": {
                  "ids": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "uuid"
                    },
                    "minItems": 1,
                    "title": "IDs of IArticleExport",
                    "description": "IDs of {@link IArticleExport bbs_article_exports}\n\nIf you want to synchronize the notion documents linked to the snapshot at once,\nplease only forward the snapshot's ID (=`from` property).\nIf you want to synchronize only some of the documents exported from that snapshot, pass only the ID of bbs_article_exports.\nbbs_article_exports is the point of connection between snapshots and documents exported from those snapshots.\n\nIf it is to be specified, it must be an array of at least one size."
                  }
                },
                "required": [],
                "title": "Exported Document's information"
              }
            },
            "required": [
              "from",
              "to"
            ],
            "title": "snapshot information for synchronization"
          }
        },
        "required": [
          "google_docs",
          "snapshot"
        ]
      },
      "IArticle.ISync.ToNotionOutput": {
        "type": "object",
        "properties": {
          "isSuccess": {
            "type": "boolean",
            "title": "response",
            "description": "Indicates whether synchronization is successful or not"
          },
          "article": {
            "$ref": "#/components/schemas/StrictOmitIArticleIArticle.ISnapshotpassword",
            "title": "article information"
          }
        },
        "required": [
          "isSuccess",
          "article"
        ]
      },
      "IArticle.ISync.ToNotionInput": {
        "type": "object",
        "properties": {
          "notion": {
            "type": "object",
            "properties": {
              "secretKey": {
                "type": "string",
                "x-wrtn-secret-key": "notion",
                "title": "Notion Secret Key for synchronization"
              }
            },
            "required": [
              "secretKey"
            ],
            "title": "Notion SecretKey for synchronization"
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "from": {
                "type": "string",
                "format": "uuid",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "ID of the snapshot to be previously synchronized",
                "description": "The user synchronizes the text associated with that snapshot.\n\nFor example, when you have v1 and v2,\nif you pass v1 by ID,\nyou replace the exported document in snapshot v1 with the exported document\nin v2 and update the properties,\nincluding the title and content of the exported document.\n\nIf you want to synchronize the notion documents linked to the snapshot at once,\nplease only forward the snapshot's ID (=`from` property).\nIf you want to synchronize only some of the documents exported from that snapshot, pass only the ID of bbs_article_exports.\nbbs_article_exports is the point of connection between snapshots and documents exported from those snapshots."
              },
              "to": {
                "type": "string",
                "format": "uuid",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "The ID of the snapshot that will be after synchronization"
              },
              "article_snapshot_exports": {
                "type": "object",
                "properties": {
                  "ids": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "uuid"
                    },
                    "minItems": 1,
                    "title": "IDs of IArticleExport",
                    "description": "IDs of {@link IArticleExport bbs_article_exports}\n\nIf you want to synchronize the notion documents linked to the snapshot at once,\nplease only forward the snapshot's ID (=`from` property).\nIf you want to synchronize only some of the documents exported from that snapshot, pass only the ID of bbs_article_exports.\nbbs_article_exports is the point of connection between snapshots and documents exported from those snapshots.\n\nIf it is to be specified, it must be an array of at least one size."
                  }
                },
                "required": [],
                "title": "Exported Document's information"
              }
            },
            "required": [
              "from",
              "to"
            ],
            "title": "snapshot information for synchronization"
          }
        },
        "required": [
          "notion",
          "snapshot"
        ]
      },
      "IArticle.IExport.ToDevToOutput": {
        "type": "object",
        "properties": {
          "dev_to": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "Created dev.to Article ID"
              },
              "title": {
                "type": "string",
                "title": "Title of Created dev.to Article"
              },
              "link": {
                "type": "string",
                "title": "File URL"
              }
            },
            "required": [
              "id",
              "title",
              "link"
            ],
            "title": "About the google doc that was successfully exported"
          },
          "article_snapshot_exports": {
            "$ref": "#/components/schemas/StrictOmitIArticleExportdeleted_at",
            "title": "Exporting infomation"
          }
        },
        "required": [
          "dev_to",
          "article_snapshot_exports"
        ]
      },
      "StrictOmitIArticleExportdeleted_at": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "title": "provider name",
            "description": "It means the name of the service from which the article was exported,\nand if the service name is motion,\nit means that the same article is posted in the corresponding url of the provider service."
          },
          "url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "URL",
            "description": "This is a redirect link that allows you to locate the exported document,\nwhich is stored at export time."
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of {@link IArticleExport}"
          },
          "bbs_article_snapshot_id": {
            "type": "string",
            "format": "uuid",
            "title": "Snapshot ID"
          },
          "uid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Unique Document ID in external service"
          }
        },
        "required": [
          "provider",
          "url",
          "id",
          "created_at",
          "bbs_article_snapshot_id",
          "uid"
        ]
      },
      "IArticle.IExport.ToDevToInput": {
        "type": "object",
        "properties": {
          "dev_to": {
            "$ref": "#/components/schemas/StrictOmitIDevTo.ICreateInputarticle",
            "title": "dev.to Secret Key and information to create file"
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "Snapshot ID of the article you want to export to another service"
              }
            },
            "required": [
              "id"
            ],
            "title": "snapshot information to export"
          }
        },
        "required": [
          "dev_to",
          "snapshot"
        ],
        "title": "Conditions and secret keys for exporting to dev.to"
      },
      "StrictOmitIDevTo.ICreateInputarticle": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "dev_to",
            "x-wrtn-secret-scopes": [],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IArticle.IExport.ToGoogleDocsOutput": {
        "type": "object",
        "properties": {
          "google_docs": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "Created Google Docs File ID"
              },
              "title": {
                "type": "string",
                "title": "Title of Created Google Docs File"
              },
              "link": {
                "type": "string",
                "title": "File URL"
              }
            },
            "required": [
              "id",
              "title",
              "link"
            ],
            "title": "About the google doc that was successfully exported"
          },
          "article_snapshot_exports": {
            "$ref": "#/components/schemas/StrictOmitIArticleExportdeleted_at",
            "title": "Exporting infomation"
          }
        },
        "required": [
          "google_docs",
          "article_snapshot_exports"
        ]
      },
      "IArticle.IExport.ToGoogleDocsInput": {
        "type": "object",
        "properties": {
          "google_docs": {
            "$ref": "#/components/schemas/StrictOmitIGoogleDocs.IRequestnamemarkdown",
            "title": "Google Docs Secret Key and information to create file"
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "Snapshot ID of the article you want to export to another service"
              }
            },
            "required": [
              "id"
            ],
            "title": "snapshot information to export"
          }
        },
        "required": [
          "google_docs",
          "snapshot"
        ],
        "title": "Conditions and secret keys for exporting to Google Docs"
      },
      "StrictOmitIGoogleDocs.IRequestnamemarkdown": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "folderId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-drive/get/folders",
              "jmesPath": "data[].{value:id, label:name}"
            },
            "title": "Google Drive Folder ID",
            "description": "Folder id that will contain the file to be created in the drive"
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IArticle.IExport.ToNotionOutput": {
        "type": "object",
        "properties": {
          "notion": {
            "$ref": "#/components/schemas/INotion.ICreatePageOutput",
            "title": "About the notion page that was successfully exported"
          },
          "article_snapshot_exports": {
            "$ref": "#/components/schemas/StrictOmitIArticleExportdeleted_at",
            "title": "Exporting infomation"
          }
        },
        "required": [
          "notion",
          "article_snapshot_exports"
        ],
        "title": "Conditions and secret keys for exporting to Notion"
      },
      "INotion.ICreatePageOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "page id",
            "description": "Unique id of the generated page"
          },
          "title": {
            "type": "string",
            "title": "tilte\n\nTitle of the document you just created"
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "page link"
          }
        },
        "required": [
          "id",
          "title",
          "link"
        ],
        "title": "Page creation result"
      },
      "IArticle.IExport.ToNotionInput": {
        "type": "object",
        "properties": {
          "notion": {
            "type": "object",
            "properties": {
              "secretKey": {
                "type": "string",
                "x-wrtn-secret-key": "notion",
                "title": "Notion Secret Key for exporting"
              },
              "parentPageId": {
                "oneOf": [
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/notion/get/page",
                      "jmesPath": "[].{value:pageId, label:title}"
                    },
                    "x-wrtn-placeholder": "부모 페이지를 선택하세요."
                  },
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/notion/page",
                      "jmesPath": "[].{value:id, label:id}"
                    },
                    "x-wrtn-placeholder": "부모 페이지를 선택하세요."
                  }
                ],
                "title": "Parent Page ID for exporting"
              }
            },
            "required": [
              "secretKey",
              "parentPageId"
            ],
            "title": "Notion SecretKey and Parent Page ID to export"
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/articles/:id",
                  "jmesPath": "snapshot[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "Snapshot ID of the article you want to export to another service"
              }
            },
            "required": [
              "id"
            ],
            "title": "snapshot information to export"
          }
        },
        "required": [
          "notion",
          "snapshot"
        ]
      },
      "IArticle.IUpdate": {
        "type": "object",
        "properties": {
          "props": {
            "$ref": "#/components/schemas/IArticle.ICreate",
            "title": "props"
          }
        },
        "required": [
          "props"
        ],
        "title": "Article to update"
      },
      "IArticle.ICreate": {
        "type": "object",
        "properties": {
          "format": {
            "const": "md",
            "title": "format",
            "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
          },
          "title": {
            "type": "string",
            "title": "Title of article",
            "description": "Title of article."
          },
          "body": {
            "type": "string",
            "title": "Content body of article",
            "description": "Content body of article."
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IAttachmentFile.ICreate"
            },
            "title": "List of attachment files",
            "description": "List of attachment files."
          }
        },
        "required": [
          "format",
          "title",
          "body"
        ],
        "title": "Article to write"
      },
      "IAttachmentFile.ICreate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "title": "File name",
            "description": "File name, except extension.\n\nPossible to make empty string like `.gitignore` case."
          },
          "extension": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "minLength": 1,
                "maxLength": 8
              }
            ],
            "title": "File extension",
            "description": "Extension.\n\nPossible to omit like `README` case.\nExtensions must exclude dot characters."
          },
          "url": {
            "type": "string",
            "format": "uri",
            "title": "File url",
            "description": "URL path of the real file.\n\nIn addition to the case of attaching a file,\nit is recommended to attach the URL address of the file when linking within the markdown document."
          }
        },
        "required": [
          "name",
          "extension",
          "url"
        ]
      },
      "IPageIArticle.ISummary": {
        "type": "object",
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/IPage.IPagination",
            "description": "Page information"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IArticle.ISummary"
            },
            "description": "List of records"
          }
        },
        "required": [
          "pagination",
          "data"
        ],
        "description": "A page\n\nCollection of records with pagination indformation"
      },
      "IPage.IPagination": {
        "type": "object",
        "properties": {
          "current": {
            "type": "integer",
            "description": "Current page number"
          },
          "limit": {
            "type": "integer",
            "description": "Limitation of records per a page"
          },
          "records": {
            "type": "integer",
            "description": "Count of total records in database"
          },
          "pages": {
            "type": "integer",
            "description": "Number of total pages\n\nEqual to {@link records} / {@link limit} with ceiling."
          }
        },
        "required": [
          "current",
          "limit",
          "records",
          "pages"
        ],
        "description": "Page information"
      },
      "IArticle.ISummary": {
        "type": "object",
        "properties": {
          "snapshot": {
            "$ref": "#/components/schemas/StrictOmitISnapshotbodybodystringMaxLength100",
            "title": "Last Snapshot"
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of article",
            "description": "The most recent snapshot made is the higher version,\nand in fact, this time value can serve as the version."
          }
        },
        "required": [
          "snapshot",
          "id",
          "created_at"
        ]
      },
      "StrictOmitISnapshotbodybodystringMaxLength100": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title of article",
            "description": "Title of article."
          },
          "bbs_article_exports": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IArticleExport"
            },
            "title": "History of this snapshot being exported",
            "description": "If it has been exported,\nthe location of the export will be recorded in the properties."
          },
          "format": {
            "const": "md",
            "title": "format",
            "description": "Format of body.\n\nSame meaning with extension like `html`, `md`, `txt`."
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of snapshot record",
            "description": "In other words, creation time or update time or article"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IAttachmentFile"
            },
            "title": "List of attachment files"
          },
          "body": {
            "type": "string",
            "maxLength": 100,
            "title": "Summarized Body",
            "description": "Summarized Body Content\n\nThis is the content of the text that has been omitted so that only 100 characters appear.\nIf you want to see the whole thing, use the detailed lookup connector."
          }
        },
        "required": [
          "title",
          "bbs_article_exports",
          "format",
          "id",
          "created_at",
          "files",
          "body"
        ]
      },
      "IArticle.IRequest": {
        "type": "object",
        "properties": {
          "search": {
            "$ref": "#/components/schemas/IArticle.IRequest.ISearch",
            "title": "search"
          },
          "sort": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "-created_at"
                },
                {
                  "const": "-snapshot.created_at"
                },
                {
                  "const": "-snapshot.title"
                },
                {
                  "const": "+created_at"
                },
                {
                  "const": "+snapshot.created_at"
                },
                {
                  "const": "+snapshot.title"
                }
              ]
            },
            "title": "sort"
          },
          "page": {
            "type": "integer",
            "title": "Page number",
            "description": "Page number."
          },
          "limit": {
            "type": "integer",
            "title": "Limitation of records per a page",
            "description": "Limitation of records per a page."
          }
        },
        "required": [],
        "title": "Query Condition"
      },
      "IArticle.IRequest.ISearch": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "title": "Article IDs",
            "description": "Article IDs, not Article Snapshot ID\n\nIt is Article's ID, Not Article Snapshot ID and {@link IArticleExport bbs_article_exports} ID."
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "format": {
                "const": "md",
                "title": "Format of article"
              },
              "title": {
                "type": "string",
                "title": "Title of article",
                "description": "This property is not a complete match, but a feature\nthat allows user to search for a title that contains that character.\nThis property should be undefined unless the user wants to see his or her writing\nand only wants to find a title that contains a particular text.\n\nIf user want to search for something that contains a specific title,\nuser can put the keyword user want in it.\nYou must put keywords that must be included.\nIf user don't have anything to search for,\nuser can put in or not empty characters."
              }
            },
            "required": [],
            "title": "Last Snapshot"
          }
        },
        "required": [],
        "title": "Search Conditions",
        "description": "If an attribute exists,\nit returns only the result of 'AND' calculations of all the attributes.\nFor example, if the format is 'md' and 'title' is 'swal',\nit will only look up the case where it is marked down and 'swal' is included in the title."
      },
      "ISpreadsheet.IExport.ToGoogleSheetsToOutput": {
        "type": "object",
        "properties": {
          "google_sheets": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "Created google sheets spreadsheet ID"
              },
              "title": {
                "type": "string",
                "title": "Title of Created google sheets spreadsheet"
              },
              "link": {
                "type": "string",
                "title": "File URL"
              }
            },
            "required": [
              "id",
              "title",
              "link"
            ]
          },
          "spreadsheet_exports": {
            "$ref": "#/components/schemas/StrictOmitISpreadsheetExportdeleted_at",
            "title": "Exporting infomation"
          }
        },
        "required": [
          "google_sheets",
          "spreadsheet_exports"
        ]
      },
      "StrictOmitISpreadsheetExportdeleted_at": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "title": "provider name",
            "description": "It means the name of the service from which the post was exported,\nand if the service name is motion,\nit means that the same post is posted in the corresponding url of the provider service."
          },
          "url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "URL",
            "description": "This is a redirect link that allows you to locate the exported spreadsheet,\nwhich is stored at export time."
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of {@link ISpreadsheetExport}"
          },
          "uid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Unique spreadsheet ID in external service"
          },
          "spreadsheet_snapshot_id": {
            "type": "string",
            "format": "uuid",
            "title": "Snapshot ID"
          }
        },
        "required": [
          "provider",
          "url",
          "id",
          "created_at",
          "uid",
          "spreadsheet_snapshot_id"
        ]
      },
      "ISpreadsheet.IExport.ToGoogleSheetsToInput": {
        "type": "object",
        "properties": {
          "google_sheets": {
            "type": "object",
            "properties": {
              "secret": {
                "type": "string",
                "x-wrtn-secret-key": "google",
                "x-wrtn-secret-scopes": [
                  "https://www.googleapis.com/auth/spreadsheets",
                  "https://www.googleapis.com/auth/drive.file"
                ]
              }
            },
            "required": [
              "secret"
            ]
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/spreadsheets/:id",
                  "jmesPath": "data[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "Snapshot ID of the spreadsheet you want to export to another service"
              }
            },
            "required": [
              "id"
            ],
            "title": "snapshot information to export"
          }
        },
        "required": [
          "google_sheets",
          "snapshot"
        ]
      },
      "ISpreadsheet.IExport.ToExcelToOutput": {
        "type": "object",
        "properties": {
          "excel": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "Created excel spreadsheet ID"
              },
              "title": {
                "type": "string",
                "title": "Title of Created excel spreadsheet"
              },
              "link": {
                "type": "string",
                "title": "File URL"
              }
            },
            "required": [
              "id",
              "title",
              "link"
            ]
          },
          "spreadsheet_exports": {
            "$ref": "#/components/schemas/StrictOmitISpreadsheetExportdeleted_at",
            "title": "Exporting infomation"
          }
        },
        "required": [
          "excel",
          "spreadsheet_exports"
        ]
      },
      "ISpreadsheet.IExport.SnapshotInput": {
        "type": "object",
        "properties": {
          "snapshot": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "patch",
                  "path": "/connector/swal/spreadsheets/:id",
                  "jmesPath": "data[].{ value: id, label: ['created_at ', created_at].join(':', @) }"
                },
                "title": "Snapshot ID of the spreadsheet you want to export to another service"
              }
            },
            "required": [
              "id"
            ],
            "title": "snapshot information to export"
          }
        },
        "required": [
          "snapshot"
        ]
      },
      "ISpreadsheetISpreadsheet.ISnapshot": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "external_user_id": {
            "type": "string",
            "format": "uuid",
            "title": "External User ID"
          },
          "spreadsheet_cells": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitISpreadsheetCellspreadsheet_id"
            },
            "title": "cells"
          },
          "snapshots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISpreadsheet.ISnapshot"
            },
            "minItems": 1,
            "title": "List of snapshot contents",
            "description": "It is created for the first time when an spreadsheet is created, and is\naccumulated every time the spreadsheet is modified."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of spreadsheet",
            "description": "The most recent snapshot made is the higher version,\nand in fact, this time value can serve as the version."
          },
          "deleted_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "Deletion time of spreadsheet"
          },
          "total_cell_count": {
            "type": "integer",
            "title": "Total count of cells"
          }
        },
        "required": [
          "id",
          "external_user_id",
          "spreadsheet_cells",
          "snapshots",
          "created_at",
          "deleted_at",
          "total_cell_count"
        ]
      },
      "StrictOmitISpreadsheetCellspreadsheet_id": {
        "type": "object",
        "properties": {
          "spreadsheet_cell_snapshots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISpreadsheetCell.ISnapshotvalueidcreated_attype"
            },
            "title": "Snapshots",
            "description": "All Snapshot of Cell"
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of spreadsheet cell"
          },
          "column": {
            "type": "integer",
            "minimum": 1,
            "maximum": 26,
            "title": "Column Number",
            "description": "It counts from 1"
          },
          "row": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "title": "Row Number",
            "description": "It counts from 1"
          },
          "mv_last": {
            "type": "object",
            "properties": {
              "snapshot": {
                "$ref": "#/components/schemas/MyPickISpreadsheetCell.ISnapshotvaluecreated_attype"
              }
            },
            "required": [
              "snapshot"
            ],
            "title": "Last Snapshot"
          }
        },
        "required": [
          "spreadsheet_cell_snapshots",
          "id",
          "created_at",
          "column",
          "row",
          "mv_last"
        ]
      },
      "MyPickISpreadsheetCell.ISnapshotvalueidcreated_attype": {
        "type": "object",
        "properties": {
          "value": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "value",
            "description": "If the value of the final cell is in the erased form, null.\nA null value will be stored only when the value of this cell disappears after modification, and other than that, null can never be entered.\nThis is to indicate that the value has been explicitly deleted to prevent the cell value of the previous snapshot from being exposed when a cell is soft-delete."
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of spreadsheet cell snapshot"
          },
          "type": {
            "const": "text",
            "title": "Format type of this cell\n\nFor example, date, datetime, bool, text an so on.\nIf you want add new type, please discuss within our team."
          }
        },
        "required": [
          "value",
          "id",
          "created_at",
          "type"
        ]
      },
      "MyPickISpreadsheetCell.ISnapshotvaluecreated_attype": {
        "type": "object",
        "properties": {
          "value": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "value",
            "description": "If the value of the final cell is in the erased form, null.\nA null value will be stored only when the value of this cell disappears after modification, and other than that, null can never be entered.\nThis is to indicate that the value has been explicitly deleted to prevent the cell value of the previous snapshot from being exposed when a cell is soft-delete."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of spreadsheet cell snapshot"
          },
          "type": {
            "const": "text",
            "title": "Format type of this cell\n\nFor example, date, datetime, bool, text an so on.\nIf you want add new type, please discuss within our team."
          }
        },
        "required": [
          "value",
          "created_at",
          "type"
        ]
      },
      "ISpreadsheet.ISnapshot": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of snapshot record",
            "description": "In other words, creation time or update time or spreadsheet"
          },
          "spreadsheet_exports": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISpreadsheetExport.ISummary"
            },
            "title": "History of this snapshot being exported",
            "description": "If it has been exported,\nthe location of the export will be recorded in the properties."
          },
          "title": {
            "type": "string",
            "title": "title"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description",
            "description": "If user want to export this sheet to an external service,\nthe description may not be exposed depending on the service user want to export.\nHowever, because it may be difficult to find out what this sheet was intended by looking at the title alone,\nan explanatory property is placed."
          }
        },
        "required": [
          "id",
          "created_at",
          "spreadsheet_exports",
          "title"
        ]
      },
      "ISpreadsheetExport.ISummary": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "title": "provider name",
            "description": "It means the name of the service from which the post was exported,\nand if the service name is motion,\nit means that the same post is posted in the corresponding url of the provider service."
          },
          "url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "URL",
            "description": "This is a redirect link that allows you to locate the exported spreadsheet,\nwhich is stored at export time."
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of {@link ISpreadsheetExport}"
          },
          "uid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Unique spreadsheet ID in external service"
          }
        },
        "required": [
          "provider",
          "url",
          "id",
          "created_at",
          "uid"
        ]
      },
      "RequiredPickISpreadsheet.ICreatecells": {
        "type": "object",
        "properties": {
          "cells": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISpreadsheetCell.ICreate"
            },
            "title": "cells"
          }
        },
        "required": [
          "cells"
        ],
        "description": "Make all properties in T required"
      },
      "ISpreadsheetCell.ICreate": {
        "type": "object",
        "properties": {
          "column": {
            "type": "integer",
            "minimum": 1,
            "maximum": 26,
            "title": "Column Number",
            "description": "It counts from 1"
          },
          "row": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "title": "Row Number",
            "description": "It counts from 1"
          },
          "snapshot": {
            "$ref": "#/components/schemas/MyPickISpreadsheetCell.ISnapshot.ICreatevaluetype",
            "title": "Last Snapshot"
          }
        },
        "required": [
          "column",
          "row",
          "snapshot"
        ]
      },
      "MyPickISpreadsheetCell.ISnapshot.ICreatevaluetype": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "title": "value",
            "description": "If the value of the final cell is in the erased form, null.\nA null value will be stored only when the value of this cell disappears after modification, and other than that, null can never be entered.\nThis is to indicate that the value has been explicitly deleted to prevent the cell value of the previous snapshot from being exposed when a cell is soft-delete."
          },
          "type": {
            "const": "text",
            "title": "Format type of this cell\n\nFor example, date, datetime, bool, text an so on.\nIf you want add new type, please discuss within our team."
          }
        },
        "required": [
          "value",
          "type"
        ]
      },
      "IPageISpreadsheet.ISummary": {
        "type": "object",
        "properties": {
          "pagination": {
            "$ref": "#/components/schemas/IPage.IPagination",
            "description": "Page information"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISpreadsheet.ISummary"
            },
            "description": "List of records"
          }
        },
        "required": [
          "pagination",
          "data"
        ],
        "description": "A page\n\nCollection of records with pagination indformation"
      },
      "ISpreadsheet.ISummary": {
        "type": "object",
        "properties": {
          "mv_last": {
            "type": "object",
            "properties": {
              "snapshot": {
                "$ref": "#/components/schemas/ISpreadsheet.ISnapshot"
              }
            },
            "required": [
              "snapshot"
            ]
          },
          "spreadsheet_cells": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitISpreadsheetCellspreadsheet_id"
            },
            "minItems": 0,
            "maxItems": 100,
            "title": "Summarized Cell Contents",
            "description": "It is the summarized cell content, and only up to 100 are searched.\nYou can check the whole thing by searching in detail."
          },
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of spreadsheet",
            "description": "The most recent snapshot made is the higher version,\nand in fact, this time value can serve as the version."
          },
          "total_cell_count": {
            "type": "integer",
            "title": "Total count of cells"
          }
        },
        "required": [
          "mv_last",
          "spreadsheet_cells",
          "id",
          "created_at",
          "total_cell_count"
        ]
      },
      "ISpreadsheet.IRequest": {
        "type": "object",
        "properties": {
          "search": {
            "$ref": "#/components/schemas/ISpreadsheet.IRequest.ISearch",
            "title": "Search"
          },
          "sort": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "-created_at"
                },
                {
                  "const": "-snapshot.created_at"
                },
                {
                  "const": "-snapshot.title"
                },
                {
                  "const": "+created_at"
                },
                {
                  "const": "+snapshot.created_at"
                },
                {
                  "const": "+snapshot.title"
                }
              ]
            },
            "title": "Sort"
          },
          "page": {
            "type": "integer",
            "title": "Page number",
            "description": "Page number."
          },
          "limit": {
            "type": "integer",
            "title": "Limitation of records per a page",
            "description": "Limitation of records per a page."
          }
        },
        "required": [],
        "title": "Request"
      },
      "ISpreadsheet.IRequest.ISearch": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uuid"
            },
            "title": "Spreadsheet IDs",
            "description": "Spreadsheet IDs, not Spreadsheet Snapshot ID\nIt is Spreadsheet's ID, Not Spreadsheet Snapshot ID and {@link ISpreadsheetExport spreadsheet_exports} ID."
          },
          "snapshot": {
            "type": "object",
            "properties": {
              "title": {
                "type": "string",
                "title": "Title of spreadsheet",
                "description": "This property is not a complete match, but a feature\nthat allows you to search for a title that contains that character."
              },
              "description": {
                "type": "string",
                "title": "Description of spreadsheet",
                "description": "This property is not a complete match, but a feature\nthat allows you to search for a title that contains that character."
              },
              "minimum_cell_count": {
                "type": "integer",
                "title": "minimum count of cells",
                "description": "It means the number of cells you wish to have at least.\nYou can adjust this value when you want to look up a lot of written sheets."
              }
            },
            "required": [],
            "title": "Last Snapshot"
          }
        },
        "required": [
          "snapshot"
        ],
        "title": "Search Conditions",
        "description": "If an attribute exists,\nit returns only the result of 'AND' calculations of all the attributes."
      },
      "ISpreadsheet.ICreate": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "title"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description",
            "description": "If user want to export this sheet to an external service,\nthe description may not be exposed depending on the service user want to export.\nHowever, because it may be difficult to find out what this sheet was intended by looking at the title alone,\nan explanatory property is placed."
          },
          "cells": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISpreadsheetCell.ICreate"
            },
            "title": "cells"
          }
        },
        "required": [
          "title"
        ]
      },
      "MyPartialIMarketingCopyComponents": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "The title of your marketing copy",
            "description": "The title of your marketing copy."
          },
          "cta": {
            "type": "string",
            "title": "This is the CTA phrase in your marketing copy",
            "description": "This is the CTA phrase in your marketing copy."
          },
          "subtitle": {
            "type": "string",
            "title": "A description of the marketing copy",
            "description": "Here is a description of the marketing copy."
          }
        },
        "required": []
      },
      "IMarketingCopyGenerator.IGenerateMarketingCopyInput": {
        "type": "object",
        "properties": {
          "keyword": {
            "$ref": "#/components/schemas/IKeywordExtraction.IExtractKeywordOutput",
            "title": "Keywords",
            "description": "Overall keywords in your marketing copy"
          },
          "marketingPurpose": {
            "$ref": "#/components/schemas/IMarketingPurpose",
            "title": "Marketing Purpose",
            "description": "Purpose of marketing and product information"
          },
          "distributionChannel": {
            "$ref": "#/components/schemas/IDistributionChannel",
            "title": "Marketing Channel",
            "description": "Channel information for using marketing copy"
          },
          "referenceContent": {
            "$ref": "#/components/schemas/IConnector.IReferenceContent",
            "title": "References",
            "description": "References for Creating Marketing Copy"
          }
        },
        "required": [
          "keyword",
          "marketingPurpose",
          "distributionChannel",
          "referenceContent"
        ],
        "title": "Input for creating marketing copy"
      },
      "IKeywordExtraction.IExtractKeywordOutput": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "description": "Extracted Keywords"
          }
        },
        "required": [
          "keyword"
        ]
      },
      "IMarketingPurpose": {
        "type": "object",
        "properties": {
          "purpose": {
            "oneOf": [
              {
                "const": "sign_up"
              },
              {
                "const": "purchase"
              },
              {
                "const": "visit"
              }
            ],
            "title": "Marketing purpose",
            "description": "The purpose is to do marketing.\n\nOnly three possible values are available: sign_up, purchase, and visit."
          },
          "product_name": {
            "type": "string",
            "title": "This is the product name to be marketed",
            "description": "This is the product name to be marketed."
          },
          "unique_selling_point": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "This is the selling point of the product",
            "description": "This is the selling point of the product."
          },
          "user_benefit": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Benefits of the product you are marketing",
            "description": "Benefits of the product you are marketing."
          }
        },
        "required": [
          "purpose",
          "product_name",
          "unique_selling_point",
          "user_benefit"
        ]
      },
      "IDistributionChannel": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "const": "youtube"
              },
              {
                "const": "facebook"
              },
              {
                "const": "kakao"
              },
              {
                "const": "instagram_feed"
              },
              {
                "const": "instagram_story"
              },
              {
                "const": "naver"
              }
            ],
            "title": "Channels to use marketing copy",
            "description": "Channels to use marketing copy.\n\nOnly 6 possible values are possible: facebook, instagram_feed, instagram_story, youtube, naver, kakao."
          },
          "components": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "title"
                },
                {
                  "const": "cta"
                },
                {
                  "const": "subtitle"
                }
              ]
            },
            "title": "Information to retrieve from the channel where the marketing copy will be used",
            "description": "Information to retrieve from the channel where the marketing copy will be used.\n\nOnly three possible values are possible: title, cta, subtitle."
          }
        },
        "required": [
          "channel",
          "components"
        ]
      },
      "IConnector.IReferenceContent": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "description": "The title of the output"
          },
          "type": {
            "oneOf": [
              {
                "const": "video"
              },
              {
                "const": "image"
              },
              {
                "const": "news_article"
              },
              {
                "const": "research_paper"
              }
            ],
            "title": "Output Type",
            "description": "Video, image, news article, research paper\n\nIt must be one of: video, image, news_article, research_paper"
          },
          "source": {
            "oneOf": [
              {
                "const": "youtube"
              },
              {
                "const": "facebook"
              },
              {
                "const": "instagram"
              },
              {
                "const": "google_search"
              },
              {
                "const": "arxiv"
              },
              {
                "const": "google_news"
              }
            ],
            "title": "Source of output",
            "description": "youtube, facebook, instagram, google_search, arxiv, google_news\n\nIt must be one of: youtube, facebook, instagram, google_search, arxiv, google_news"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "URL address",
            "description": "The URL address of the output"
          },
          "contents": {
            "type": "string",
            "title": "Output Content",
            "description": "Here is the content of the output"
          },
          "image": {
            "type": "string",
            "format": "iri",
            "title": "Output Image URL",
            "description": "The URL address of the image of the output"
          },
          "statistics": {
            "$ref": "#/components/schemas/MyPartialRecordIConnector.MetricTypenumberTypeint32",
            "title": "Output statistics information",
            "description": "Output statistics information\n\nPossible values: view_count, like_count, rank"
          }
        },
        "required": [
          "title",
          "type",
          "source",
          "url"
        ]
      },
      "MyPartialRecordIConnector.MetricTypenumberTypeint32": {
        "type": "object",
        "properties": {
          "view_count": {
            "type": "integer"
          },
          "like_count": {
            "type": "integer"
          },
          "rank": {
            "type": "integer"
          }
        },
        "required": []
      },
      "IMarketingCopyImage": {
        "type": "object",
        "properties": {
          "imageUrl": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Image URL of the generated marketing copy draft",
            "description": "Image URL of the generated marketing copy draft."
          }
        },
        "required": [
          "imageUrl"
        ]
      },
      "IMarketingCopyGenerator.IGenerateMarketingCopyImageInput": {
        "type": "object",
        "properties": {
          "copy": {
            "$ref": "#/components/schemas/MyPartialIMarketingCopyComponents",
            "title": "Marketing Copy Creation Results",
            "description": "Marketing Copy Creation Results Related to Marketing Copy Image"
          },
          "keyword": {
            "$ref": "#/components/schemas/IKeywordExtraction.IExtractKeywordOutput",
            "title": "Keywords",
            "description": "Overall keywords for marketing copy images"
          },
          "marketingPurpose": {
            "$ref": "#/components/schemas/IMarketingPurpose",
            "title": "Marketing Purpose",
            "description": "Purpose of marketing and product information"
          },
          "distributionChannel": {
            "$ref": "#/components/schemas/IDistributionChannel",
            "title": "Marketing Channel",
            "description": "Channel information for using marketing copy"
          },
          "referenceContent": {
            "$ref": "#/components/schemas/IConnector.IReferenceContent",
            "title": "References",
            "description": "References for Creating Marketing Copy"
          }
        },
        "required": [
          "copy",
          "keyword",
          "marketingPurpose",
          "distributionChannel",
          "referenceContent"
        ],
        "title": "Input for generating marketing copy images"
      },
      "IRag.IAnalysisOutput": {
        "type": "object",
        "properties": {
          "chatId": {
            "type": "string",
            "title": "chat id",
            "description": "Chat id required for RAG generation results.\nReturns the chat id for the analyzed file to generate chat results for the file analyzed by RAG.\nThe same chat id is required to analyze multiple files and generate results for multiple files in the same chat."
          }
        },
        "required": [
          "chatId"
        ],
        "title": "RAG analysis results"
      },
      "IRag.IAnalyzeInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "application/pdf, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.hancom.hwp, text/plain, text/html"
            },
            "title": "Knowledge that the chatbot will use to answer",
            "description": "Knowledge that the chatbot will use to answer"
          }
        },
        "required": [
          "url"
        ],
        "title": "Knowledge that the chatbot will use to answer"
      },
      "IRag.IGenerateOutput": {
        "type": "object",
        "properties": {
          "answer": {
            "type": "string",
            "title": "Response to utterance",
            "description": "Response to RAG-based creation request."
          }
        },
        "required": [
          "answer"
        ],
        "title": "Chat results via RAG"
      },
      "IRag.IGenerateInput": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "title": "User utterance",
            "description": "This is a user utterance."
          }
        },
        "required": [
          "query"
        ],
        "title": "Information required for chatting via RAG"
      },
      "IHwp.IParseOutput": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "text",
            "description": "Text of the parsed hwp file"
          }
        },
        "required": [
          "text"
        ],
        "title": "hwp file parsing result"
      },
      "IHwp.IParseInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.hancom.hwp",
            "title": "hwp file",
            "description": "hwp file to parse."
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "Information for parsing hwp files"
      },
      "IExcel.IReadExcelInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Excel file",
            "description": "Excel file to read"
          },
          "sheetName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "Sheet1"
              }
            ],
            "title": "sheet name",
            "description": "Sheet name to read"
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "file information"
      },
      "IExcel.IReadExcelOutput": {
        "type": "object",
        "properties": {
          "headers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "headers of this sheet"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IExcel.IReadExcelRowData"
            },
            "title": "Excel sheet data"
          }
        },
        "required": [
          "headers",
          "data"
        ],
        "title": "Excel file reading result"
      },
      "IExcel.IReadExcelRowData": {
        "type": "object",
        "properties": {},
        "required": [],
        "title": "Read Excel row data",
        "additionalProperties": {}
      },
      "IExcel.IWorksheetListOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "sheetName": {
                  "type": "string",
                  "title": "sheet name",
                  "description": "Name of the imported worksheet"
                },
                "id": {
                  "type": "number",
                  "title": "sheet id",
                  "description": "The id of the imported worksheet."
                }
              },
              "required": [
                "sheetName",
                "id"
              ]
            },
            "title": "sheet list data"
          }
        },
        "required": [
          "data"
        ],
        "title": "List of imported worksheets"
      },
      "IExcel.IGetWorksheetListInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Excel file",
            "description": "File to import list of Excel worksheets"
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "file information"
      },
      "IExcel.IExportExcelFileOutput": {
        "type": "object",
        "properties": {
          "fileId": {
            "type": "string",
            "title": "S3 path of file"
          },
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Generated Excel file url"
          }
        },
        "required": [
          "fileId",
          "fileUrl"
        ],
        "title": "Excel row addition result"
      },
      "IExcel.IInsertExcelRowByUploadInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "엑셀 파일",
            "description": "엑셀 행을 추가할 파일\n\nIf you have this address, take an Excel file from that path and modify it.\nThe modified file is saved as a new link and does not modify the original file in this path.\nIf this address does not exist, create a new file immediately."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISpreadsheetCell.ICreate"
            },
            "title": "Cell informations",
            "description": "The type of data and coordinates of each row and column"
          },
          "sheetName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "maxLength": 31,
                "x-wrtn-placeholder": "Sheet1"
              }
            ],
            "title": "Excel sheet name",
            "description": "Sheet name to add Excel rows to\nIf no input is entered, the first sheet is used as the default."
          }
        },
        "required": [
          "data"
        ],
        "title": "Information for adding data"
      },
      "IExcel.IInsertExcelRowInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "iri",
            "title": "엑셀 파일",
            "description": "엑셀 행을 추가할 파일\n\nIf you have this address, take an Excel file from that path and modify it.\nThe modified file is saved as a new link and does not modify the original file in this path.\nIf this address does not exist, create a new file immediately."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISpreadsheetCell.ICreate"
            },
            "title": "Cell informations",
            "description": "The type of data and coordinates of each row and column"
          },
          "sheetName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "maxLength": 31,
                "x-wrtn-placeholder": "Sheet1"
              }
            ],
            "title": "Excel sheet name",
            "description": "Sheet name to add Excel rows to\nIf no input is entered, the first sheet is used as the default."
          }
        },
        "required": [
          "data"
        ],
        "title": "Information for adding data"
      },
      "IExcel.ICreateSheetInput": {
        "type": "object",
        "properties": {
          "sheetName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "maxLength": 31,
                "x-wrtn-placeholder": "Sheet1"
              }
            ],
            "title": "Excel sheet name",
            "description": "Sheet name to add Excel rows to\nIf no input is entered, the first sheet is used as the default."
          }
        },
        "required": []
      },
      "IGoogleDocs.IResponse": {
        "type": "object",
        "properties": {
          "markdown": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "Created Markdown File ID"
              }
            },
            "required": [
              "id"
            ]
          },
          "googleDocs": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "Created Google Docs File ID"
              },
              "url": {
                "type": "string",
                "format": "iri",
                "title": "File URL"
              }
            },
            "required": [
              "id",
              "url"
            ]
          }
        },
        "required": [
          "markdown",
          "googleDocs"
        ]
      },
      "IGoogleDocs.IRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Google drive file name",
            "description": "File name to be created in drive"
          },
          "folderId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-drive/get/folders",
              "jmesPath": "data[].{value:id, label:name}"
            },
            "title": "Google Drive Folder ID",
            "description": "Folder id that will contain the file to be created in the drive"
          },
          "markdown": {
            "type": "string",
            "title": "markdown",
            "description": "Contents of the file to be created in drive"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "markdown",
          "secretKey"
        ],
        "title": "Information required to create a file in Google Drive"
      },
      "IGoogleDocs.IClearOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Created Google Docs File ID"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "File URL"
          }
        },
        "required": [
          "id",
          "url"
        ],
        "title": "Document ID and URL"
      },
      "IGoogleDocs.IClearInput": {
        "type": "object",
        "properties": {
          "documentId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-docs/get-list",
              "jmesPath": "data[].{value:id, label:title}"
            },
            "title": "ID of Google Docs File",
            "description": "ID when you want to erase the entire contents of a file and make it an empty file"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "documentId",
          "secretKey"
        ],
        "title": "Google Drive and Docs Secret Key and information to clear file"
      },
      "IGoogleDocs.ICreateEmptyFileOutput": {
        "type": "object",
        "properties": {
          "isEmpty": {
            "const": true,
            "title": "Property that specifies that this file is empty"
          },
          "message": {
            "const": "the content is empty; you can now fill content in there",
            "title": "Message",
            "description": "State it's empty because it's a file you just created."
          },
          "id": {
            "type": "string",
            "title": "Generated docs id",
            "description": "The ID of the generated docs."
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url"
          }
        },
        "required": [
          "isEmpty",
          "message",
          "id",
          "url"
        ],
        "title": "Creation Response of Empty Google Docs File"
      },
      "IGoogleDocs.ICreateGoogleDocsInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Google docs title",
            "description": "The title of the docs to be generated."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Information required to create Google docs"
      },
      "IGoogleDocs.IPermissionGoogleDocsInput": {
        "type": "object",
        "properties": {
          "documentId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-docs/get-list",
              "jmesPath": "data[].{value:id, label:title}"
            },
            "title": "Google docs id",
            "description": "The id of the Google docs to which you want to grant access."
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IPermission"
            },
            "title": "Here is a list of emails to make accessible and the permissions to grant",
            "description": "Here is a list of emails to make accessible and the permissions to grant."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "documentId",
          "permissions",
          "secretKey"
        ],
        "title": "Information required to grant Google Docs permissions"
      },
      "IPermission": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "The email address of the user to grant permission to",
            "description": "The email address of the user to grant permission to."
          },
          "role": {
            "oneOf": [
              {
                "const": "owner"
              },
              {
                "const": "writer"
              },
              {
                "const": "commenter"
              },
              {
                "const": "reader"
              },
              {
                "const": "organizer"
              },
              {
                "const": "fileOrganizer"
              }
            ],
            "title": "The permission to grant",
            "description": "The type of permission to grant.\n\nowner: Grants owner permissions. Users with this permission can delete files or folders or grant permissions to other users.\norganizer: Grants operator permissions for the drive. Users with this permission can manage the organization of the drive.\nfileOrganizer: Grants operator permissions for files on the drive. Users with this permission can add or delete files.\nwriter: Grants write permissions. Users with this permission can modify or delete files.\ncommenter: Grants comment permissions. Users with this permission can read and comment on files.\nreader: Grants read permissions. Users with this permission can read files.\n\nThere are only six possible values: \"owner\", \"writer\", \"commenter\", \"reader\", \"organizer\", \"fileOrganizer\"."
          },
          "type": {
            "oneOf": [
              {
                "const": "group"
              },
              {
                "const": "user"
              },
              {
                "const": "domain"
              },
              {
                "const": "anyone"
              }
            ],
            "title": "The type of permission to grant",
            "description": "The type of permission to grant.\n\nuser - a specific user, in this case you must specify the email address of the user to grant the permission to in the emailAddress field.\ngroup - a specific group, in this case you must specify the email address of the group to grant the permission to in the emailAddress field.\ndomain - a specific domain, in this case you must specify the domain to grant the permission to in the domain field.\nanyone - all users\n\nThere are only four possible values: \"user\", \"group\", \"domain\", \"anyone\"."
          }
        },
        "required": [
          "email",
          "role",
          "type"
        ],
        "title": "Authorization information"
      },
      "IGoogleDocs.IReadGoogleDocsOutput": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/IGoogleDocs",
            "title": "Google docs data",
            "description": "This is data from Google docs that I read."
          }
        },
        "required": [
          "data"
        ],
        "title": "Google Docs search results"
      },
      "IGoogleDocs": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "text information",
            "description": "Here is the text information from Google Docs."
          },
          "table": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "title": "Table Information",
            "description": "Here is the table information from Google Docs."
          }
        },
        "required": []
      },
      "IGoogleDocs.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Authentication Information"
      },
      "IGoogleDocs.ICreateDocByTemplateOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated docs id",
            "description": "The id of the copied docs"
          }
        },
        "required": [
          "id"
        ],
        "title": "Google Docs Duplication Results"
      },
      "IGoogleDocs.ICreateDocByTemplateInput": {
        "type": "object",
        "properties": {
          "templateId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-docs/get-list",
              "jmesPath": "data[].{value:id, label:title}"
            },
            "title": "Google docs to clone",
            "description": "Google docs to clone"
          },
          "title": {
            "type": "string",
            "title": "The title of the docs to be created",
            "description": "The title of the docs to be newly created by duplicating"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "templateId",
          "title",
          "secretKey"
        ],
        "title": "Information needed to duplicate Google Docs"
      },
      "IGoogleDocs.IUpdateOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Updated Google Docs File ID"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "File URL"
          }
        },
        "required": [
          "id",
          "url"
        ]
      },
      "IGoogleDocs.IUpdateTitleInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "title",
            "description": "Title to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Google Docs Secret Key and title to update"
      },
      "IGoogleDocs.IUpdateContentInput": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "string",
            "title": "contents as markdown format",
            "description": "Existing content will be covered with this content,\nso if you want to add content, you should check the previous content and specify what you have added with this parameter."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "contents",
          "secretKey"
        ],
        "title": "Google Docs Secret Key and contents to update"
      },
      "IGoogleDocs.IListGoogleDocsOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google docs id",
                  "description": "The id of the imported Google docs."
                },
                "title": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google docs title",
                  "description": "The title of the imported Google docs."
                }
              },
              "required": []
            },
            "title": "List of Google docs",
            "description": "Here is a list of Google docs that were searched."
          }
        },
        "required": [
          "data"
        ],
        "title": "Google docs list query results"
      },
      "IGoogleDocs.ICreateGoogleDocsOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated docs id",
            "description": "The ID of the generated docs."
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url"
          }
        },
        "required": [
          "id",
          "url"
        ],
        "title": "Google Docs creation result"
      },
      "IGoogleDocs.IAppendTextGoogleDocsInput": {
        "type": "object",
        "properties": {
          "documentId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-docs/get-list",
              "jmesPath": "data[].{value:id, label:title}"
            },
            "title": "Google docs",
            "description": "Select the Google docs you want to add text to."
          },
          "text": {
            "type": "string",
            "title": "text",
            "description": "The text to add\n\nWhen you pass the input of the markdown format, change the markdown to the appropriate format."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "documentId",
          "text",
          "secretKey"
        ],
        "title": "Information needed to add text to Google Docs"
      },
      "IGoogleSheet.IReadGoogleSheetOutput": {
        "type": "object",
        "properties": {
          "data": {
            "title": "Sheet data",
            "description": "This is the data from the read sheet."
          }
        },
        "required": [
          "data"
        ],
        "title": "Google Sheet Reading Results"
      },
      "IGoogleSheet.IReadGoogleSheetHeadersInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "sheet url",
            "description": "The url address of the sheet from which to read the header information."
          },
          "index": {
            "type": "number",
            "title": "Sheet header index",
            "description": "The header index of the sheet to read."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "secretKey"
        ],
        "title": "Information needed to read Google Sheet header"
      },
      "IGoogleSheet.ICreateGoogleSheetOutput": {
        "type": "object",
        "properties": {
          "spreadsheetId": {
            "type": "string",
            "title": "Sheet ID",
            "description": "The ID of the generated Google Spreadsheet."
          },
          "spreadsheetUrl": {
            "type": "string",
            "title": "Sheet URL",
            "description": "The URL of the generated Google Spreadsheet."
          }
        },
        "required": [
          "spreadsheetId",
          "spreadsheetUrl"
        ],
        "title": "Google Spreadsheet Creation Results"
      },
      "IGoogleSheet.IAppendToSheetInput": {
        "type": "object",
        "properties": {
          "spreadSheetId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-sheet/create",
              "jmesPath": "[].{value:spreadsheetId, label:spreadsheetUrl}"
            },
            "title": "The sheet to add",
            "description": "This is the sheet to which you want to add content."
          },
          "values": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  },
                  {
                    "type": "boolean"
                  }
                ]
              }
            },
            "title": "These are the values to add",
            "description": "These are the values to add."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "spreadSheetId",
          "values",
          "secretKey"
        ]
      },
      "IGoogleSheet.ICreateGoogleSheetInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Sheet Title",
            "description": "Please enter a title for the Google Spreadsheet you want to create."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Information needed to create a Google Spreadsheet"
      },
      "IGoogleSheet.IPermissionInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "iri",
            "title": "sheet url",
            "description": "The url of the sheet to grant permission to."
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IPermission.o1"
            },
            "title": "Here is a list of emails to make accessible and permissions to grant",
            "description": "Here is a list of emails to make accessible and permissions to grant."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "permissions",
          "secretKey"
        ],
        "title": "Information required to grant Google Sheets permissions"
      },
      "IPermission.o1": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "The email address of the user to grant permission to",
            "description": "The email address of the user to grant permission to."
          },
          "role": {
            "oneOf": [
              {
                "const": "owner"
              },
              {
                "const": "writer"
              },
              {
                "const": "commenter"
              },
              {
                "const": "reader"
              }
            ],
            "title": "The permission to grant",
            "description": "The type of permission to grant.\n\nowner: Grants owner permission. Users with this permission can delete files or folders, or grant permission to other users.\nwriter: Grants write permission. Users with this permission can modify or delete files.\ncommenter: Grants comment permission. Users with this permission can read files and post comments.\nreader: Grants read permission. Users with this permission can read files.\n\nThere are only four possible values: \"owner\", \"writer\", \"commenter\", and \"reader\"."
          }
        },
        "required": [
          "email",
          "role"
        ],
        "title": "Permissions Information"
      },
      "IGoogleSheet.IWriteGoogleSheetHeadersInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "sheet url",
            "description": "The url of the sheet to which you want to add the header."
          },
          "index": {
            "type": "number",
            "title": "sheet index",
            "description": "The index of the header to add."
          },
          "headerNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "A list of headers to add to the sheet",
            "description": "A list of headers to add to the sheet."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "headerNames",
          "secretKey"
        ],
        "title": "Information needed to add a Google Sheet header"
      },
      "IGoogleSheet.IGetWorkSheetOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "List of worksheet titles",
            "description": "Here is a list of titles for the sheets you've read."
          }
        },
        "required": [
          "data"
        ],
        "title": "Worksheet query results"
      },
      "IGoogleSheet.IGetWorkSheetInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "sheet url",
            "description": "The url of the sheet to read."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "secretKey"
        ],
        "title": "Information required to view worksheets"
      },
      "IGoogleSheet.IReadGoogleSheetRowsOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetRowData"
            },
            "title": "This is the read Google Sheet row data",
            "description": "This is the read Google Sheet row data."
          }
        },
        "required": [
          "data"
        ],
        "title": "Google Sheets Row Reading Results"
      },
      "IGoogleSheet.IReadGoogleSheetRowData": {
        "type": "object",
        "properties": {},
        "required": [],
        "title": "Google Sheets Row Data Information",
        "additionalProperties": {}
      },
      "IGoogleSheet.IReadGoogleSheetRowsInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "sheet url",
            "description": "The url of the sheet from which to read the rows."
          },
          "workSheetTitle": {
            "type": "string",
            "title": "The title of the sheet to work on",
            "description": "The title of the sheet to work on."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "workSheetTitle",
          "secretKey"
        ],
        "title": "Information needed to read Google Sheet rows"
      },
      "IGoogleCalendar.IGoogleCalendarOutput": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Calendar id",
            "description": "The id of the generated calendar."
          },
          "summary": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Calendar name",
            "description": "The name of the generated calendar."
          }
        },
        "required": [],
        "title": "Calendar creation result"
      },
      "IGoogleCalendar.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Authentication Information"
      },
      "IGoogleCalendar.ICreateCalendarInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "The title of the calendar to be created",
            "description": "The title of the calendar to be created."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Information for creating a calendar"
      },
      "IGoogleCalendar.IReadGoogleCalendarEventOutput": {
        "type": "object",
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent"
            },
            "title": "Event List",
            "description": "Here is a list of calendar events that were found."
          }
        },
        "required": [
          "events"
        ],
        "title": "Calendar Event Search Results"
      },
      "IGoogleCalendar.IGoogleCalendarEvent": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "event id",
            "description": "The unique id of the event."
          },
          "htmlLink": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Event Link",
            "description": "Here is the event link."
          },
          "color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event color",
            "description": "Event color."
          },
          "createdDate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The event creation date",
            "description": "The event creation date."
          },
          "updatedDate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event update date",
            "description": "Event update date."
          },
          "title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event title",
            "description": "This is the event title."
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event description",
            "description": "Event description."
          },
          "location": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event Location",
            "description": "This is the event location."
          },
          "organizer": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IOrganizer"
              }
            ],
            "title": "Event Organizer",
            "description": "Here is the information for the event organizer."
          },
          "creator": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.ICreator"
              }
            ],
            "title": "Event Creator",
            "description": "Information about the event creator."
          },
          "startDate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "dateTime": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "Event start date",
                    "description": "Event start date."
                  },
                  "timeZone": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "Event start date time zone",
                    "description": "Event start date time zone."
                  }
                },
                "required": []
              }
            ],
            "title": "Event Start Date\n\nThe start date information for the event."
          },
          "endDate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "dateTime": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "The event ends on this date",
                    "description": "The event ends on this date."
                  },
                  "timeZone": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "Event End Date Timezone",
                    "description": "Event End Date Timezone."
                  }
                },
                "required": []
              }
            ],
            "title": "Event end date",
            "description": "This is the event end date information."
          },
          "recurrence": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "Event repeat information",
            "description": "Event repeat information."
          },
          "transparency": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event busy/free status",
            "description": "Event busy/free status."
          },
          "guestsCanModify": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the inviter has permission to edit the event",
            "description": "Whether the inviter has permission to edit the event."
          },
          "reminders": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IReminders"
              }
            ],
            "title": "Event notification information",
            "description": "Event notification information."
          },
          "attendees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IAttendees"
                }
              }
            ],
            "title": "Event Attendee",
            "description": "Here is the event attendee information."
          },
          "attachments": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IAttachments"
                }
              }
            ],
            "title": "Attachment information",
            "description": "Event attachment information."
          },
          "hangoutLink": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Google Meet link",
            "description": "Here is the Google Meet link."
          },
          "visibility": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The event is open",
            "description": "The event is open."
          }
        },
        "required": [],
        "title": "Google Calendar Event Information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IOrganizer": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event organizer profile id",
            "description": "Event organizer profile id."
          },
          "displayName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The name of the event organizer",
            "description": "The name of the event organizer."
          },
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "This is the event organizer's email",
            "description": "This is the event organizer's email."
          },
          "self": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the event copy corresponds to the calendar on which it is displayed",
            "description": "Whether the event copy corresponds to the calendar on which it is displayed."
          }
        },
        "required": [],
        "title": "Host Information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.ICreator": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event Creator Profile Id",
            "description": "The event creator profile id."
          },
          "displayName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The event creator name",
            "description": "The event creator name."
          },
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The event creator email",
            "description": "The event creator email."
          },
          "self": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the event copy corresponds to the calendar on which it is displayed",
            "description": "Whether the event copy corresponds to the calendar on which it is displayed."
          }
        },
        "required": [],
        "title": "Event creator information",
        "description": "Event creator information."
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IReminders": {
        "type": "object",
        "properties": {
          "useDefault": {
            "type": "boolean",
            "title": "Whether to default notification",
            "description": "Whether to default notification."
          },
          "overrides": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IRemindersOverrides"
            },
            "title": "Notification settings information",
            "description": "Here is the notification settings information."
          }
        },
        "required": [],
        "title": "Notification information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IRemindersOverrides": {
        "type": "object",
        "properties": {
          "method": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Notification method",
            "description": "This is the notification method."
          },
          "minutes": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "It's time to send notifications",
            "description": "It's time to send notifications."
          }
        },
        "required": [],
        "title": "Notification settings information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IAttendees": {
        "type": "object",
        "properties": {
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event attendee email",
            "description": "This is the event attendee email."
          },
          "organizer": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the event attendee is the host",
            "description": "Whether the event attendee is the host."
          },
          "self": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the calendar that the schedule copy is displayed on is indicated",
            "description": "Whether the calendar that the schedule copy is displayed on is indicated."
          },
          "responseStatus": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attendee's attendance response status",
            "description": "Attendee's attendance response status."
          }
        },
        "required": [],
        "title": "Attendee Information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IAttachments": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "file url",
            "description": "This is the event attachment file url."
          },
          "title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "File title",
            "description": "This is the title of the attached file."
          },
          "mimeType": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Internet Media Type",
            "description": "Internet Media Type."
          },
          "iconLink": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "File icon link",
            "description": "Attachment file icon link."
          },
          "fileId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "file id",
            "description": "This is the id of the attached file."
          }
        },
        "required": [],
        "title": "Attachment file information"
      },
      "IGoogleCalendar.IReadGoogleCalendarEventInput": {
        "type": "object",
        "properties": {
          "time_max": {
            "type": "string",
            "format": "date-time",
            "title": "Information about the last date from which events will be fetched",
            "description": "Events after that date will not be fetched.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "time_min": {
            "type": "string",
            "format": "date-time",
            "title": "Information on the start date from which events will be retrieved",
            "description": "Events prior to that date will not be retrieved.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "max_results": {
            "type": "integer",
            "title": "How many results to return",
            "description": "Sets the maximum number of events to retrieve."
          },
          "orderBy": {
            "oneOf": [
              {
                "const": "startTime"
              },
              {
                "const": "updated"
              }
            ],
            "title": "The order in which the events will be received",
            "description": "The order in which the calendar events are sorted.\n\n- startTime: The start time of the event.\n- updated: The date the event was updated.\n\nOnly two possible values are possible: \"startTime\" and \"updated\"."
          },
          "query": {
            "type": "string",
            "title": "Event search terms",
            "description": "You can search for events that contain your search terms.\n\nYou can search for events that contain your search terms in the title, description, location, attendees, etc."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "time_max",
          "time_min",
          "secretKey"
        ],
        "title": "Information needed to search for events"
      },
      "IGoogleCalendar.ICreateQuickEventInput": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "This is the text for creating a quick calendar event",
            "description": "This is the text for creating a quick calendar event."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "text",
          "secretKey"
        ],
        "title": "Information needed to create a quick event"
      },
      "IGoogleCalendar.IEventRequestBodyInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Event title",
            "description": "The title of the event to be generated."
          },
          "description": {
            "type": "string",
            "title": "Event description",
            "description": "Description of the event to be generated."
          },
          "location": {
            "type": "string",
            "title": "Event Location",
            "description": "This is the event location to be created."
          },
          "start": {
            "type": "string",
            "format": "date-time",
            "title": "Event start date",
            "description": "The start date of the event to be created.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "end": {
            "type": "string",
            "format": "date-time",
            "title": "Event end date",
            "description": "The end date of the event to be created.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "attendeesEmail": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Attendee Email",
            "description": "This is the event attendee email."
          },
          "repeatFrequency": {
            "oneOf": [
              {
                "const": "DAILY"
              },
              {
                "const": "WEEKLY"
              },
              {
                "const": "MONTHLY"
              },
              {
                "const": "YEARLY"
              }
            ],
            "title": "The event repeat cycle",
            "description": "The event repeat cycle.\n\n- DAILY: Daily\n- WEEKLY: Weekly\n- MONTHLY: Monthly\n- YEARLY: Yearly\n\nOnly 4 possible values are possible: \"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\"."
          },
          "repeatNum": {
            "type": "number",
            "title": "The number of times the event is repeated",
            "description": "The number of times the event is repeated."
          },
          "repeatUntil": {
            "type": "string",
            "format": "date-time",
            "title": "Event repeat deadline",
            "description": "Event repeat deadline.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "isBusy": {
            "type": "boolean",
            "title": "Whether the event is busy or not",
            "description": "Whether the event is busy or not."
          },
          "isUseDefaultReminder": {
            "type": "boolean",
            "title": "Whether to use the default calendar notifications",
            "description": "Whether to use the default calendar notifications."
          },
          "remindersType": {
            "oneOf": [
              {
                "const": "email"
              },
              {
                "const": "popup"
              }
            ],
            "title": "Event notification type",
            "description": "Event notification type.\n\n- popup: Popup notification\n- email: Email notification\n\nOnly two possible values are possible: \"popup\" and \"email\"."
          },
          "minutesBeforeReminders": {
            "type": "number",
            "title": "It's time to set a notification before the schedule starts",
            "description": "It's time to set a notification before the schedule starts."
          },
          "isConferencing": {
            "type": "boolean",
            "title": "Whether to create a Google Meet",
            "description": "Whether to create a Google Meet."
          },
          "visibility": {
            "oneOf": [
              {
                "const": "default"
              },
              {
                "const": "private"
              },
              {
                "const": "public"
              }
            ],
            "title": "The event's public status",
            "description": "The event's public status.\n\ndefault - The default public status\npublic - The event is public and the event details are visible to all readers of the calendar\nprivate - The event is private and only the event attendees can see the event details\n\nThere are only three possible values: \"default\", \"public\", \"private\"."
          },
          "colorId": {
            "type": "string",
            "title": "Event Color",
            "description": "Event Color."
          },
          "isGuestCanModify": {
            "type": "boolean",
            "title": "Whether guest events can be modified",
            "description": "Whether guest events can be modified."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "start",
          "end",
          "secretKey"
        ],
        "title": "Information required to create an event"
      },
      "IGoogleCalendar.IAddAttendeesToEventInput": {
        "type": "object",
        "properties": {
          "attendeesEmail": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "The email address of the attendee you wish to add",
            "description": "The email address of the attendee you wish to add."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "attendeesEmail",
          "secretKey"
        ],
        "title": "Information required to add attendees"
      },
      "IGoogleDrive.IFolderListGoogleDriveOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google drive folder id",
                  "description": "Google drive folder id."
                },
                "name": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google drive folder name",
                  "description": "Google drive folder name."
                }
              },
              "required": []
            },
            "title": "Google Drive Folder Data",
            "description": "List of folder data in Google Drive."
          }
        },
        "required": [
          "data"
        ],
        "title": "Folder list information in Google Drive"
      },
      "IGoogleDrive.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Authentication Information"
      },
      "IGoogleDrive.IFileListGoogleDriveOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google drive file id",
                  "description": "Google drive file id."
                },
                "name": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google drive file name",
                  "description": "The name of the Google drive file."
                },
                "webContentLink": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string",
                      "format": "iri"
                    }
                  ],
                  "title": "webContentLink"
                }
              },
              "required": []
            },
            "title": "Google Drive File Data",
            "description": "List of file data in Google Drive."
          }
        },
        "required": [
          "data"
        ],
        "title": "File list information in Google Drive"
      },
      "IGoogleDrive.IFileListGoogleDriveInput": {
        "type": "object",
        "properties": {
          "folderId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-drive/get/folders",
              "jmesPath": "data[].{value:id, label:name}"
            },
            "title": "Google Drive Folder",
            "description": "Folder to load files from"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Information for loading a list of files in Google Drive"
      },
      "IGoogleDrive.ICreateFolderGoogleDriveOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated drive id",
            "description": "Generated drive folder id."
          }
        },
        "required": [
          "id"
        ],
        "title": "Google Drive Folder Creation Results"
      },
      "IGoogleDrive.ICreateFolderGoogleDriveInput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Google drive folder name",
            "description": "Drive folder name to be created."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "secretKey"
        ],
        "title": "Information required to create a Google Drive folder"
      },
      "IGoogleDrive.ICreateFileGoogleDriveOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated drive file id",
            "description": "Generated drive file id."
          }
        },
        "required": [
          "id"
        ],
        "title": "Result of creating a file in Google Drive"
      },
      "IGoogleDrive.IUploadFileInput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Google drive file name",
            "description": "File name to be created in drive."
          },
          "folderIds": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-drive/get/folders",
                "jmesPath": "data[].{value:id, label:name}"
              }
            },
            "minItems": 1,
            "title": "Google drive folder ids",
            "description": "A list of folder ids that will contain the files to be created in the drive."
          },
          "fileUrl": {
            "type": "string",
            "format": "iri",
            "title": "fileToUpload"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "folderIds",
          "fileUrl",
          "secretKey"
        ],
        "title": "Information required to create a file in Google Drive"
      },
      "IGoogleDrive.IPermissionGoogleDriveInput": {
        "type": "object",
        "properties": {
          "fileId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-drive/get/files",
              "jmesPath": "data[].{value:id, label:name}"
            },
            "title": "Google drive file id",
            "description": "The drive file id to grant access to."
          },
          "folderId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-drive/get/folders",
              "jmesPath": "data[].{value:id, label:name}"
            },
            "title": "Google drive folder id",
            "description": "Drive folder id to grant access to."
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleDrive.IPermission"
            },
            "title": "Here is a list of emails to make accessible and permissions to grant",
            "description": "Here is a list of emails to make accessible and permissions to grant."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive.file"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "permissions",
          "secretKey"
        ],
        "title": "Information required for Google Drive access permission"
      },
      "IGoogleDrive.IPermission": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "The email address of the user to whom you wish to grant access",
            "description": "The email address of the user to whom you wish to grant access to Google Drive.\nRequired only when the type is a user type."
          },
          "role": {
            "oneOf": [
              {
                "const": "owner"
              },
              {
                "const": "writer"
              },
              {
                "const": "commenter"
              },
              {
                "const": "reader"
              },
              {
                "const": "organizer"
              },
              {
                "const": "fileOrganizer"
              }
            ],
            "title": "The permission to grant",
            "description": "The type of permission to grant.\n\nowner: Grants owner permissions. Users with this permission can delete files or folders or grant permissions to other users.\norganizer: Grants operator permissions for the drive. Users with this permission can manage the organization of the drive.\nfileOrganizer: Grants operator permissions for files on the drive. Users with this permission can add or delete files.\nwriter: Grants write permissions. Users with this permission can modify or delete files.\ncommenter: Grants comment permissions. Users with this permission can read and comment on files.\nreader: Grants read permissions. Users with this permission can read files.\n\nThere are only six possible values: \"owner\", \"organizer\", \"fileOrganizer\", \"writer\", \"commenter\", \"reader\"."
          },
          "type": {
            "oneOf": [
              {
                "const": "group"
              },
              {
                "const": "user"
              },
              {
                "const": "domain"
              },
              {
                "const": "anyone"
              }
            ],
            "title": "The type of permission to grant",
            "description": "The type of permission to grant.\n\nuser - a specific user, in this case you must specify the email address of the user to grant the permission to in the emailAddress field.\ngroup - a specific group, in this case you must specify the email address of the group to grant the permission to in the emailAddress field.\ndomain - a specific domain, in this case you must specify the domain to grant the permission to in the domain field.\nanyone - all users\n\nThere are only four possible values: \"user\", \"group\", \"domain\", \"anyone\"."
          }
        },
        "required": [
          "role",
          "type"
        ],
        "title": "Access Rights Information"
      },
      "IGoogleDrive.IGetFileOutput": {
        "type": "object",
        "properties": {
          "userPermission": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "id"
              },
              "type": {
                "oneOf": [
                  {
                    "const": "group"
                  },
                  {
                    "const": "user"
                  },
                  {
                    "const": "domain"
                  },
                  {
                    "const": "anyone"
                  }
                ],
                "title": "type"
              },
              "role": {
                "oneOf": [
                  {
                    "const": "owner"
                  },
                  {
                    "const": "writer"
                  },
                  {
                    "const": "commenter"
                  },
                  {
                    "const": "reader"
                  },
                  {
                    "const": "organizer"
                  },
                  {
                    "const": "fileOrganizer"
                  }
                ],
                "title": "role"
              },
              "pendingOwner": {
                "type": "boolean",
                "title": "pendingOwner"
              }
            },
            "required": [
              "id",
              "type",
              "role",
              "pendingOwner"
            ],
            "title": "userPermission"
          },
          "fileExtension": {
            "type": "string",
            "title": "fileExtension"
          },
          "ownerNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "ownerNames"
          },
          "lastModifyingUserName": {
            "type": "string",
            "title": "lastModifyingUserName"
          },
          "editable": {
            "type": "boolean",
            "title": "editable"
          },
          "writersCanShare": {
            "type": "boolean",
            "title": "writersCanShare"
          },
          "mimeType": {
            "type": "string",
            "title": "mimeType"
          },
          "parents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "title": "id: string;"
                },
                "isRoot": {
                  "type": "boolean",
                  "title": "isRoot"
                }
              },
              "required": [
                "id",
                "isRoot"
              ]
            },
            "title": "parents"
          },
          "thumbnailLink": {
            "type": "string",
            "format": "iri",
            "title": "thumbnailLink"
          },
          "appDataContents": {
            "type": "boolean",
            "title": "appDataContents"
          },
          "shared": {
            "type": "boolean",
            "title": "shared"
          },
          "lastModifyingUser": {
            "$ref": "#/components/schemas/IGoogleDrive.User",
            "title": "lastModifyingUser"
          },
          "owners": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleDrive.User"
            },
            "title": "owners"
          },
          "copyable": {
            "type": "boolean",
            "title": "copyable"
          },
          "alternateLink": {
            "type": "string",
            "format": "iri",
            "title": "alternateLink\nA link to view the file in Google Drive's preview mode."
          },
          "embedLink": {
            "type": "string",
            "format": "iri",
            "title": "embedLink\nA link to embed the file in a webpage via an iframe."
          },
          "webContentLink": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "webContentLink\nA link to directly access or download the file content."
          },
          "fileSize": {
            "type": "string",
            "title": "fileSize"
          },
          "copyRequiresWriterPermission": {
            "type": "boolean",
            "title": "copyRequiresWriterPermission"
          },
          "spaces": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "spaces"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "title": {
            "type": "string",
            "title": "title(filename)"
          },
          "labels": {
            "type": "object",
            "properties": {
              "viewed": {
                "type": "boolean",
                "title": "viewed"
              },
              "restricted": {
                "type": "boolean",
                "title": "restricted"
              },
              "starred": {
                "type": "boolean",
                "title": "starred"
              },
              "hidden": {
                "type": "boolean",
                "title": "hidden"
              },
              "trashed": {
                "type": "boolean",
                "title": "trashed"
              }
            },
            "required": [
              "viewed",
              "restricted",
              "starred",
              "hidden",
              "trashed"
            ],
            "title": "labels"
          },
          "explicitlyTrashed": {
            "type": "boolean",
            "title": "explicitlyTrashed"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time",
            "title": "createdDate"
          },
          "modifiedDate": {
            "type": "string",
            "format": "date-time",
            "title": "modifiedDate"
          },
          "modifiedByMeDate": {
            "type": "string",
            "format": "date-time",
            "title": "modifiedByMeDate"
          },
          "lastViewedByMeDate": {
            "type": "string",
            "format": "date-time",
            "title": "lastViewedByMeDate"
          },
          "markedViewedByMeDate": {
            "type": "string",
            "format": "date-time",
            "title": "markedViewedByMeDate"
          },
          "quotaBytesUsed": {
            "type": "string",
            "title": "quotaBytesUsed"
          },
          "version": {
            "type": "string",
            "title": "version"
          },
          "originalFilename": {
            "type": "string",
            "title": "originalFilename"
          },
          "capabilities": {
            "type": "object",
            "properties": {
              "canEdit": {
                "type": "boolean",
                "title": "canEdit"
              },
              "canCopy": {
                "type": "boolean",
                "title": "canCopy"
              }
            },
            "required": [
              "canEdit",
              "canCopy"
            ],
            "title": "capabilities"
          }
        },
        "required": [
          "userPermission",
          "ownerNames",
          "lastModifyingUserName",
          "editable",
          "writersCanShare",
          "mimeType",
          "parents",
          "appDataContents",
          "shared",
          "lastModifyingUser",
          "owners",
          "copyable",
          "alternateLink",
          "embedLink",
          "copyRequiresWriterPermission",
          "spaces",
          "id",
          "title",
          "labels",
          "explicitlyTrashed",
          "createdDate",
          "modifiedDate",
          "quotaBytesUsed",
          "version",
          "capabilities"
        ]
      },
      "IGoogleDrive.User": {
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string",
            "title": "displayName"
          },
          "isAuthenticatedUser": {
            "type": "boolean",
            "title": "isAuthenticatedUser"
          },
          "permissionId": {
            "type": "string",
            "title": "permissionId"
          },
          "emailAddress": {
            "type": "string",
            "format": "email",
            "title": "emailAddress"
          },
          "picture": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url"
              }
            },
            "required": [
              "url"
            ],
            "title": "picture"
          }
        },
        "required": [
          "displayName",
          "isAuthenticatedUser",
          "permissionId",
          "emailAddress",
          "picture"
        ]
      },
      "IGmail.ISendMailOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "The ID of the sent email",
            "description": "The ID of the sent email."
          }
        },
        "required": [
          "id"
        ],
        "title": "Mail transmission result"
      },
      "IGmail.ICreateMailInput": {
        "type": "object",
        "properties": {
          "to": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Recipient's email address",
            "description": "The email address of the recipient."
          },
          "subject": {
            "type": "string",
            "title": "Email subject",
            "description": "Subject of the email to be sent."
          },
          "body": {
            "type": "string",
            "title": "Email body.</a>",
            "description": "The body of the email to be sent. It must be written in html. Otherwise, the body may not be displayed properly. Please apply the CSS format applicable to gmail. Please write the html length so that it is not too long. If it is too long, it may not be sent. If there is a link or url <a>, be sure to use the title attribute of the html tag to provide a link."
          },
          "cc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Email address of the person to be referenced",
            "description": "Email address of the person to be referenced."
          },
          "Bcc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Bcc email address",
            "description": "Bcc email address."
          },
          "files": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "filename": {
                  "type": "string",
                  "title": "filename"
                },
                "fileUrl": {
                  "type": "string",
                  "format": "iri",
                  "title": "file uri"
                }
              },
              "required": [
                "filename",
                "fileUrl"
              ]
            },
            "title": "files"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "to",
          "subject",
          "body",
          "secretKey"
        ],
        "title": "Information required to send email"
      },
      "IGmail.IReplyInput": {
        "type": "object",
        "properties": {
          "replyText": {
            "type": "string",
            "title": "Phrase to reply",
            "description": "Phrase to reply."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "replyText",
          "secretKey"
        ],
        "title": "Information required to reply to email"
      },
      "IGmail.IFindGmailOutput": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Email id",
            "description": "Unique id of the email."
          },
          "labelIds": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "Email Label id",
            "description": "Label id assigned to the email."
          },
          "from": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Sender Email",
            "description": "The email address of the person who sent the email."
          },
          "subject": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Subject",
            "description": "The subject of the email."
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Summary of the body",
            "description": "Summary of the body of the email."
          },
          "attachments": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGmail.IAttachmentOutput"
                }
              }
            ],
            "title": "Attachments",
            "description": "List of files attached to the email."
          }
        },
        "required": [],
        "title": "Email search results"
      },
      "IGmail.IAttachmentOutput": {
        "type": "object",
        "properties": {
          "partId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The immutable ID of the message part",
            "description": "The immutable ID of the message part."
          },
          "mimeType": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The MIME type of the message part",
            "description": "The MIME type of the message."
          },
          "filename": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attachment name",
            "description": "This message part will only be displayed if it indicates an attachment."
          },
          "headers": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGmail.IAttachmentHeader"
                }
              }
            ],
            "title": "Attachment header information",
            "description": "The top-level message portion, which represents the entire message payload, contains standard RFC 2822 email headers such as To, From, and Subject."
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGmail.IAttachmentBody"
              }
            ],
            "title": "Attachment header body information",
            "description": "The body of the message part of this section, which may be empty for container MIME message parts."
          }
        },
        "required": [],
        "title": "Attachment file information"
      },
      "IGmail.IAttachmentHeader": {
        "type": "object",
        "properties": {
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attachment header type",
            "description": "Attachment header type."
          },
          "value": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attachment header value",
            "description": "Attachment header value."
          }
        },
        "required": [],
        "title": "Attachment file header information"
      },
      "IGmail.IAttachmentBody": {
        "type": "object",
        "properties": {
          "attachmentId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attachment file id",
            "description": "The unique ID of the attached file."
          },
          "size": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "The number of bytes in the attachment data",
            "description": "The number of bytes in the attachment data."
          }
        },
        "required": [],
        "title": "Attached file body information"
      },
      "IGmail.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Authentication Information"
      },
      "IGmail.IFindGmailListOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGmail.IFindGmailOutput"
            },
            "title": "gmail search data information",
            "description": "Searched gmail data information."
          }
        },
        "required": [
          "data"
        ],
        "title": "Email list search results"
      },
      "IGmail.IFindEmailListInput": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "title": "The email of the sender",
            "description": "The email address of the sender of the email."
          },
          "to": {
            "type": "string",
            "title": "The email address of the recipient",
            "description": "The email address of the recipient."
          },
          "subject": {
            "type": "string",
            "title": "Email Subject",
            "description": "Email Subject."
          },
          "after": {
            "type": "string",
            "title": "After a specific date",
            "description": "Returns only emails after a given date."
          },
          "before": {
            "type": "string",
            "title": "Before a specific date",
            "description": "Returns only emails before a given date."
          },
          "label": {
            "type": "string",
            "title": "Label assigned to the email",
            "description": "Label assigned to the email."
          },
          "maxResults": {
            "type": "number",
            "maximum": 500,
            "minimum": 1,
            "title": "Maximum number of returned mails",
            "description": "Number of returned mails."
          },
          "labelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "A list of labels to filter by",
            "description": "A list of labels to return only emails with labels that all match the specified label ID."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Information needed to search email lists"
      },
      "IGmail.ILabelOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated label id",
            "description": "The id of the generated label."
          }
        },
        "required": [
          "id"
        ],
        "title": "Label Creation Result"
      },
      "IGmail.ILabelInput": {
        "type": "object",
        "properties": {
          "labelName": {
            "type": "string",
            "title": "Label name",
            "description": "The name of the label to create."
          },
          "labelListVisibility": {
            "oneOf": [
              {
                "const": "labelHide"
              },
              {
                "const": "labelShow"
              },
              {
                "const": "labelShowIfUnread"
              }
            ],
            "title": "Visibility status of the label",
            "description": "Visibility status of the label to be created.\n\nHidden / Visible / Visible when unread\n\n- labelHide: Hidden\n- labelShow: Visible\n- labelShowIfUnread: Visible when unread\n\nOnly three possible values are available: labelHide, labelShow, and labelShowIfUnread."
          },
          "messageListVisibility": {
            "oneOf": [
              {
                "const": "hide"
              },
              {
                "const": "show"
              }
            ],
            "title": "The visibility status of the labeled mail",
            "description": "The visibility status of the generated labeled mail.\n\nHidden / Visible\n\n- hide: hidden\n- show: visible\n\nThere are only two possible values: hide and show."
          },
          "color": {
            "$ref": "#/components/schemas/IGmail.ILabelColor",
            "title": "Label Color",
            "description": "Color of the mail label to be generated"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "labelName",
          "secretKey"
        ],
        "title": "Information required to create a label"
      },
      "IGmail.ILabelColor": {
        "type": "object",
        "properties": {
          "textColor": {
            "type": "string",
            "title": "Label text color",
            "description": "Label text color."
          },
          "backgroundColor": {
            "type": "string",
            "title": "Label background color",
            "description": "Label background color."
          }
        },
        "required": [
          "textColor",
          "backgroundColor"
        ],
        "title": "label color"
      },
      "IGmail.IMailLabelOperationInput": {
        "type": "object",
        "properties": {
          "labelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "A list of labels",
            "description": "A list of labels to assign or remove."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "labelIds",
          "secretKey"
        ],
        "title": "Information required to assign a label"
      },
      "IGmail.IDeleteMailListInput": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Email IDs to delete",
            "description": "Please select the emails to delete."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "ids",
          "secretKey"
        ]
      },
      "IHancell.IUpsertSheetOutput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "title": "New Hansel File Link"
          }
        },
        "required": [
          "fileUrl"
        ]
      },
      "IHancell.IUpsertSheetInput": {
        "type": "object",
        "properties": {
          "sheetName": {
            "type": "string",
            "title": "Sheet name",
            "description": "If the sheet does not exist, it will be added, and if it does exist, it will be modified."
          },
          "cells": {
            "$ref": "#/components/schemas/IHancell.Cells",
            "title": "Sheet Information",
            "description": "Information contained in each cell of the sheet."
          },
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Excel file",
            "description": "Excel file to read"
          }
        },
        "required": [
          "sheetName",
          "cells",
          "fileUrl"
        ]
      },
      "IHancell.Cells": {
        "type": "object",
        "properties": {},
        "required": [],
        "title": "Information contained in the cell",
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "IHancell.IReadHancellOutput": {
        "type": "object",
        "properties": {},
        "required": [],
        "title": "Hansel Read Response",
        "additionalProperties": {
          "$ref": "#/components/schemas/IHancell.Cells"
        }
      },
      "IHancell.IReadHancellInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Excel file",
            "description": "Excel file to read"
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "Hansel reading conditions"
      },
      "IKakaoMap.SearchByKeywordOutput": {
        "type": "object",
        "properties": {
          "documents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoMap.Document"
            },
            "title": "Search Results List"
          },
          "meta": {
            "$ref": "#/components/schemas/IKakaoMap.Meta",
            "title": "meta information"
          }
        },
        "required": [
          "documents",
          "meta"
        ],
        "title": "Search Results"
      },
      "IKakaoMap.Document": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Location ID"
          },
          "place_name": {
            "type": "string",
            "title": "Place name, company name"
          },
          "category_name": {
            "type": "string",
            "title": "Category Name"
          },
          "category_group_code": {
            "oneOf": [
              {
                "const": "MT1"
              },
              {
                "const": "CS2"
              },
              {
                "const": "PS3"
              },
              {
                "const": "SC4"
              },
              {
                "const": "AC5"
              },
              {
                "const": "PK6"
              },
              {
                "const": "OL7"
              },
              {
                "const": "SW8"
              },
              {
                "const": "BK9"
              },
              {
                "const": "CT1"
              },
              {
                "const": "AG2"
              },
              {
                "const": "PO3"
              },
              {
                "const": "AT4"
              },
              {
                "const": "AD5"
              },
              {
                "const": "FD6"
              },
              {
                "const": "CE7"
              },
              {
                "const": "HP8"
              },
              {
                "const": "PM9"
              },
              {
                "const": ""
              }
            ],
            "title": "Category group code that groups only important categories"
          },
          "category_group_name": {
            "oneOf": [
              {
                "const": "대형마트"
              },
              {
                "const": "편의점"
              },
              {
                "const": "어린이집,유치원"
              },
              {
                "const": "학교"
              },
              {
                "const": "학원"
              },
              {
                "const": "주차장"
              },
              {
                "const": "주유소, 충전소"
              },
              {
                "const": "지하철역"
              },
              {
                "const": "은행"
              },
              {
                "const": "문화시설"
              },
              {
                "const": "중개업소"
              },
              {
                "const": "공공기관"
              },
              {
                "const": "관광명소"
              },
              {
                "const": "숙박"
              },
              {
                "const": "음식점"
              },
              {
                "const": "카페"
              },
              {
                "const": "병원"
              },
              {
                "const": "약국"
              },
              {
                "const": ""
              }
            ],
            "title": "Category group name that groups only important categories"
          },
          "phone": {
            "type": "string",
            "title": "phone number"
          },
          "address_name": {
            "type": "string",
            "title": "Full street address"
          },
          "road_address_name": {
            "type": "string",
            "title": "Full road name address"
          },
          "x": {
            "type": "string",
            "title": "X coordinate value",
            "description": "longitude (longitude) in case of latitude and longitude"
          },
          "y": {
            "type": "string",
            "title": "Y coordinate value",
            "description": "latitude in case of longitude and latitude"
          },
          "place_url": {
            "type": "string",
            "format": "iri",
            "title": "Location details page URL"
          },
          "distance": {
            "type": "string",
            "title": "Distance to the center coordinate",
            "description": "(only exists when x,y parameters are given) Unit meter"
          }
        },
        "required": [
          "id",
          "place_name",
          "category_name",
          "category_group_code",
          "category_group_name",
          "phone",
          "address_name",
          "road_address_name",
          "x",
          "y",
          "place_url",
          "distance"
        ],
        "title": "Search Results"
      },
      "IKakaoMap.Meta": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "title": "Number of documents found for search term"
          },
          "pageable_count": {
            "type": "integer",
            "maximum": 45,
            "title": "Number of documents displayed at once"
          },
          "is_end": {
            "type": "boolean",
            "title": "Whether the current page is the last page",
            "description": "If the value is false, the page value can be increased for the next request to request the next page."
          },
          "same_name": {
            "type": "object",
            "properties": {
              "keyword": {
                "type": "string",
                "title": "Keyword excluding local information from query language",
                "description": "If you search for 'Jungang-ro Restaurant', the value extracted from the part corresponding to 'Restaurant'"
              },
              "region": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "List of regions recognized in the query",
                "description": "If you search for 'Jungang-ro restaurant', the value extracted from the part corresponding to 'Jungang-ro'"
              },
              "selected_region": {
                "type": "string",
                "title": "Local information used in search"
              }
            },
            "required": [
              "keyword",
              "region",
              "selected_region"
            ]
          }
        },
        "required": [
          "total_count",
          "pageable_count",
          "is_end"
        ],
        "title": "meta information"
      },
      "IKakaoMap.SearchByKeywordInput": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "x-wrtn-placeholder": "종로구 맛집",
            "title": "Search Keyword",
            "description": "Search Keyword\n\nThe simpler the search term, the better.\nIt is a good idea to search for a specific area name\nand the type you are looking for.\nFor example, it can be 'Seoul Cafe'.\nIf you search by composing only these clear words,\nyou will provide the search results\nthat are best suited to the keyword inside the Kakao server.\nIf adjectives or words decorating places, such as 'popular cafes',\nare included, the search quality may be lowered or nothing may be searched,\nso put the search word as plain as possible."
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "maximum": 45,
            "default": 1,
            "title": "Results page number"
          },
          "size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 15,
            "default": 15,
            "title": "Number of documents per page"
          }
        },
        "required": [
          "query"
        ],
        "title": "Search Conditions"
      },
      "IDallE3.IResponse": {
        "type": "object",
        "properties": {
          "imgUrl": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Generated image Url",
            "description": "Generated image url"
          }
        },
        "required": [
          "imgUrl"
        ],
        "title": "Image creation result"
      },
      "IDallE3.IRequest": {
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "title": "prompt",
            "description": "Prompt to create an image"
          },
          "image_ratio": {
            "oneOf": [
              {
                "const": "square"
              },
              {
                "const": "landscape"
              },
              {
                "const": "portrait"
              }
            ],
            "title": "Image Size",
            "description": "Preset image size to generate.\n\nOnly three possible values are available: \"square\", \"landscape\", and \"portrait\"."
          }
        },
        "required": [
          "prompt",
          "image_ratio"
        ],
        "title": "Information for image creation"
      },
      "IGoogleSearch.IResponse": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Search Results Title"
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Search Results Link"
          },
          "snippet": {
            "type": "string",
            "title": "Search Results Summary"
          },
          "thumbnail": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Search Results thumbnail"
          }
        },
        "required": [
          "title",
          "link"
        ],
        "title": "Search Results"
      },
      "IGoogleSearch.IRequest": {
        "type": "object",
        "properties": {
          "andKeywords": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "뤼튼"
            },
            "title": "Must-include keywords",
            "description": "Set keywords that must be included in search results."
          },
          "orKeywords": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "스튜디오"
            },
            "title": "Good keywords to enter",
            "description": "Set good keywords to enter the search results."
          },
          "notKeywords": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "폭력"
            },
            "title": "Keywords that should not be included",
            "description": "Set keywords that should not be included in search results."
          },
          "max_results": {
            "type": "integer",
            "title": "Number of search results",
            "description": "Set the number of search results."
          }
        },
        "required": [
          "andKeywords",
          "max_results"
        ],
        "title": "Conditions for searching"
      },
      "IGoogleShopping.IResponse": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Product name"
          },
          "link": {
            "oneOf": [
              {
                "const": "#"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Product Link"
          },
          "price": {
            "type": "string",
            "title": "Product Price",
            "description": "₩57,600 Format"
          },
          "source": {
            "type": "string",
            "title": "Product Source"
          },
          "deliveryCost": {
            "type": "string",
            "title": "Shipping fee"
          },
          "thumbnail": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Product Image"
          },
          "rating": {
            "type": "number",
            "title": "Product Rating"
          }
        },
        "required": [
          "title",
          "link",
          "price",
          "thumbnail"
        ],
        "title": "Product search results"
      },
      "IGoogleShopping.IRequestStandAlone": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "title": "Search term",
            "description": "Enter the keyword you want to search for."
          },
          "lang": {
            "type": "string",
            "title": "Language Setting",
            "description": "Choose which language you want to use as your search term.\n\nYou can only pass a single BCP 47 language identifier.\n\nex) You want to setting korean language, you can pass \"ko\"."
          },
          "max_results": {
            "type": "integer",
            "title": "Number of search results",
            "description": "Set the number of search results."
          }
        },
        "required": [
          "keyword",
          "lang",
          "max_results"
        ],
        "title": "Product search conditions"
      },
      "IConnector.ISearchOutput": {
        "type": "object",
        "properties": {
          "references": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IConnector.IReferenceContent"
            },
            "title": "Output Information",
            "description": "Contains output information for search results"
          }
        },
        "required": [
          "references"
        ],
        "title": "Search Results"
      },
      "IConnector.ISearchInput": {
        "type": "object",
        "properties": {
          "num_results": {
            "type": "integer",
            "x-wrtn-placeholder": "10",
            "title": "Number of search results",
            "description": "Sets how many search results to retrieve"
          },
          "from_date": {
            "type": "string",
            "format": "date",
            "title": "Start date for search results",
            "description": "Set the start date for search results"
          },
          "to_date": {
            "type": "string",
            "format": "date",
            "title": "End date for the search results",
            "description": "Set the end date for the search results"
          },
          "and_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "biology"
            },
            "title": "Must be included keywords",
            "description": "Keywords that must be included in search results"
          },
          "or_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "ecosystem"
            },
            "title": "Keywords that you would like to see included",
            "description": "Keywords that you would like to see included in your search results"
          },
          "not_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "pollution"
            },
            "title": "Keywords that should not be included",
            "description": "Keywords that should not be included in search results"
          }
        },
        "required": [
          "and_keywords"
        ],
        "title": "Search criteria",
        "description": "Enter your search criteria"
      },
      "IDaum.IBlogDaumOutput": {
        "type": "object",
        "properties": {
          "meta": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "title": "Number of searched contents",
                "description": "Total number of documents searched."
              },
              "pageableCount": {
                "type": "number",
                "title": "The number of content that can be exposed among the searched documents",
                "description": "The number of content that can be exposed among the searched documents."
              },
              "isEnd": {
                "type": "boolean",
                "title": "Whether the current page is the last page",
                "description": "If the value is false, you can request the next page by incrementing page."
              }
            },
            "required": [
              "totalCount",
              "pageableCount",
              "isEnd"
            ],
            "title": "meta"
          },
          "documents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "title": "The title of the document",
                  "description": "The title of the document searched."
                },
                "contents": {
                  "type": "string",
                  "title": "Part of the text of the document",
                  "description": "This is part of the text of the document that was searched."
                },
                "url": {
                  "type": "string",
                  "title": "Document URL",
                  "description": "The URL of the document being searched."
                },
                "blogName": {
                  "type": "string",
                  "title": "The name of the blog",
                  "description": "The name of the blog searched."
                },
                "thumbnail": {
                  "type": "string",
                  "contentMediaType": "image/*",
                  "title": "Thumbnail image URL",
                  "description": "Representative preview image URL extracted from the search system."
                },
                "dateTime": {
                  "type": "string",
                  "title": "Document Creation Time",
                  "description": "The time the document was created."
                }
              },
              "required": [
                "title",
                "contents",
                "url",
                "blogName",
                "thumbnail",
                "dateTime"
              ]
            },
            "title": "documents"
          }
        },
        "required": [
          "meta",
          "documents"
        ],
        "title": "Next blog search results"
      },
      "IDaum.ISearchDaumInput": {
        "type": "object",
        "properties": {
          "andKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "뤼튼",
            "title": "Must-include keywords",
            "description": "Set keywords that must be included in the following search results."
          },
          "orKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "스튜디오",
            "title": "Good keywords to enter",
            "description": "Set good keywords to enter the following search results."
          },
          "notKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "폭력",
            "title": "Keywords that should not be included",
            "description": "Set keywords that should not be included in the following search results."
          },
          "sort": {
            "oneOf": [
              {
                "const": "accuracy"
              },
              {
                "const": "recency"
              }
            ],
            "title": "Sorting method for result documents",
            "description": "- accuracy: accuracy order (default)\n- recency: most recent order"
          },
          "page": {
            "type": "number",
            "minimum": 1,
            "maximum": 50,
            "default": 1,
            "title": "Results page number",
            "description": "The number of the results page."
          },
          "size": {
            "type": "number",
            "minimum": 1,
            "maximum": 50,
            "default": 10,
            "title": "The number of documents to be displayed on one page",
            "description": "The number of documents to be displayed on one page."
          }
        },
        "required": [
          "andKeywords"
        ],
        "title": "Information needed for the next search"
      },
      "IDaum.ICafeDaumOutput": {
        "type": "object",
        "properties": {
          "meta": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "title": "Number of searched cafe contents",
                "description": "Total number of searched cafes."
              },
              "pageableCount": {
                "type": "number",
                "title": "The number of contents that can be exposed among the searched cafe contents",
                "description": "The number of contents that can be exposed among the searched cafe contents."
              },
              "isEnd": {
                "type": "boolean",
                "title": "Whether the current page is the last page",
                "description": "If the value is false, you can request the next page by incrementing page."
              }
            },
            "required": [
              "totalCount",
              "pageableCount",
              "isEnd"
            ],
            "title": "metadata"
          },
          "documents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "title": "The title of the document",
                  "description": "The title of the document searched."
                },
                "contents": {
                  "type": "string",
                  "title": "Part of the text of the document",
                  "description": "This is part of the text of the document that was searched."
                },
                "url": {
                  "type": "string",
                  "title": "Document URL",
                  "description": "The URL of the document being searched."
                },
                "cafeName": {
                  "type": "string",
                  "title": "Cafe Name",
                  "description": "The following cafe name is searched."
                },
                "thumbnail": {
                  "type": "string",
                  "contentMediaType": "image/*",
                  "title": "Thumbnail image URL",
                  "description": "Representative preview image URL extracted from the search system."
                },
                "dateTime": {
                  "type": "string",
                  "title": "Document Creation Time",
                  "description": "The time the document was created."
                }
              },
              "required": [
                "title",
                "contents",
                "url",
                "cafeName",
                "thumbnail",
                "dateTime"
              ]
            },
            "title": "documents"
          }
        },
        "required": [
          "meta",
          "documents"
        ],
        "title": "Next Cafe Search Results"
      },
      "INaver.ICafeNaverOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "properties": {
              "lastBuildDate": {
                "type": "string",
                "title": "The time the search results were generated",
                "description": "The time the search results were generated."
              },
              "total": {
                "type": "number",
                "title": "Total number of search results",
                "description": "Total number of search results."
              },
              "start": {
                "type": "number",
                "title": "The starting position of the search",
                "description": "The starting position of the search results."
              },
              "display": {
                "type": "number",
                "title": "The number of search results to display at one time",
                "description": "The number of search results to display at one time."
              },
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/INaver.ICafeNaverItemOutput"
                },
                "title": "Individual search results",
                "description": "Individual search results."
              }
            },
            "required": [
              "lastBuildDate",
              "total",
              "start",
              "display",
              "items"
            ],
            "title": "Naver Cafe search result data",
            "description": "Naver Cafe search result data."
          }
        },
        "required": [
          "data"
        ],
        "title": "Naver Cafe Search Results"
      },
      "INaver.ICafeNaverItemOutput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Post title",
            "description": "Title of Naver Cafe post."
          },
          "link": {
            "type": "string",
            "title": "Post link",
            "description": "Link to Naver Cafe post."
          },
          "description": {
            "type": "string",
            "title": "Summary of post",
            "description": "Summary of Naver Cafe post."
          },
          "cafename": {
            "type": "string",
            "title": "The name of the cafe where the post is located",
            "description": "The name of the cafe where the Naver Cafe post is located."
          },
          "cafeurl": {
            "type": "string",
            "title": "Link to the cafe where the post is located",
            "description": "Link to the cafe where the Naver Cafe post is located."
          }
        },
        "required": [
          "title",
          "link",
          "description",
          "cafename",
          "cafeurl"
        ],
        "title": "Naver Cafe Search Data"
      },
      "INaver.INaverKeywordInput": {
        "type": "object",
        "properties": {
          "andKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "뤼튼",
            "title": "Must-include keywords",
            "description": "Keywords that must be included in search results."
          },
          "orKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "스튜디오",
            "title": "Keywords that would be good to include",
            "description": "Keywords that you would like to see included in the search results."
          },
          "notKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "폭력",
            "title": "Keywords that should not be included",
            "description": "Keywords that should not be included in search results."
          },
          "display": {
            "type": "number",
            "minimum": 1,
            "maximum": 100,
            "default": 10,
            "x-wrtn-placeholder": "10",
            "title": "Number to search",
            "description": "Set how many search results to retrieve.\nMinimum 1, maximum 100, default 10."
          },
          "sort": {
            "oneOf": [
              {
                "const": "sim"
              },
              {
                "const": "date"
              }
            ],
            "title": "Sort by",
            "description": "Indicates how to sort.\n\n- sim: Sort by accuracy descending (default).\n- date: Sort by date descending."
          }
        },
        "required": [
          "andKeywords"
        ],
        "title": "Search Conditions"
      },
      "INaver.IBlogNaverOutput": {
        "type": "object",
        "properties": {
          "lastBuildDate": {
            "type": "string",
            "title": "The time the search results were generated",
            "description": "The time the search results were generated."
          },
          "total": {
            "type": "number",
            "title": "Total number of search results",
            "description": "Total number of search results."
          },
          "start": {
            "type": "number",
            "title": "The starting position of the search",
            "description": "The starting position of the search results."
          },
          "display": {
            "type": "number",
            "title": "The number of search results to display at one time",
            "description": "The number of search results to display at one time."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/INaver.IBlogNaverItemOutput"
            },
            "title": "Individual search results",
            "description": "Individual search results."
          }
        },
        "required": [
          "lastBuildDate",
          "total",
          "start",
          "display",
          "items"
        ],
        "title": "Naver blog search results"
      },
      "INaver.IBlogNaverItemOutput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Post title",
            "description": "Title of Naver blog post."
          },
          "link": {
            "type": "string",
            "title": "Post link",
            "description": "Link to Naver blog post."
          },
          "description": {
            "type": "string",
            "title": "Summary of post",
            "description": "Summary of Naver blog post."
          },
          "bloggername": {
            "type": "string",
            "title": "The name of the blog that contains the blog post",
            "description": "The name of the blog that contains the Naver blog post."
          },
          "bloggerlink": {
            "type": "string",
            "title": "Address of the blog that contains the blog post",
            "description": "Address of the blog that contains the Naver blog post."
          },
          "postdate": {
            "type": "string",
            "title": "The date the blog post was created",
            "description": "The date the Naver blog post was created."
          }
        },
        "required": [
          "title",
          "link",
          "description",
          "bloggername",
          "bloggerlink",
          "postdate"
        ],
        "title": "Naver blog search data"
      },
      "INaver.INewsNaverOutput": {
        "type": "object",
        "properties": {
          "lastBuildDate": {
            "type": "string",
            "title": "The time the search results were generated",
            "description": "The time the search results were generated."
          },
          "total": {
            "type": "number",
            "title": "Total number of search results",
            "description": "Total number of search results."
          },
          "start": {
            "type": "number",
            "title": "The starting position of the search",
            "description": "The starting position of the search results."
          },
          "display": {
            "type": "number",
            "title": "The number of search results to display at one time",
            "description": "The number of search results to display at one time."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/INaver.INewsNaverItemOutput"
            },
            "title": "Individual search results",
            "description": "Individual search results."
          }
        },
        "required": [
          "lastBuildDate",
          "total",
          "start",
          "display",
          "items"
        ]
      },
      "INaver.INewsNaverItemOutput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "description": "News Title."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Naver News URL",
            "description": "Naver News URL."
          },
          "originallink": {
            "type": "string",
            "format": "iri",
            "title": "Original URL",
            "description": "Original URL of news article."
          },
          "description": {
            "type": "string",
            "title": "Summary of the news article</b>",
            "description": "The part that matches the search term <b>is wrapped in tags."
          },
          "pubDate": {
            "type": "string",
            "title": "News article publication time",
            "description": "The time the news article was provided to Naver."
          }
        },
        "required": [
          "title",
          "link",
          "originallink",
          "description",
          "pubDate"
        ],
        "title": "Naver News Search Data"
      },
      "IYoutubeSearch.ISearchOutput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "YouTube video title",
            "description": "Title of the YouTube video that appears in the search results."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "YouTube video link",
            "description": "Links to YouTube videos that appear in search results."
          },
          "thumbnail": {
            "type": "string",
            "format": "iri",
            "title": "Thumbnail image for YouTube videos",
            "description": "Thumbnail image for YouTube videos."
          },
          "view_count": {
            "type": "integer",
            "title": "YouTube video views",
            "description": "YouTube video views."
          },
          "channel_name": {
            "type": "string",
            "title": "Channel name",
            "description": "Channel name of YouTube videos that appear in search results."
          },
          "channel_link": {
            "type": "string",
            "format": "iri",
            "title": "Channel link",
            "description": "Link to the YouTube channel that appears in the search results."
          },
          "published_date": {
            "type": "string",
            "title": "YouTube video published date",
            "description": "Date the YouTube video was published.\nex) 1 year ago"
          }
        },
        "required": [
          "title",
          "link",
          "thumbnail",
          "view_count",
          "channel_name",
          "channel_link",
          "published_date"
        ],
        "title": "YouTube search results"
      },
      "IYoutubeSearch.ISearchInput": {
        "type": "object",
        "properties": {
          "and_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "뤼튼"
            },
            "minItems": 1,
            "title": "Must be included keywords",
            "description": "Keywords that must be included in search results."
          },
          "or_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "스튜디오"
            },
            "title": "Keywords that you would like to see included",
            "description": "Keywords that you would like to see included in your search results."
          },
          "not_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "폭력"
            },
            "title": "Keywords that should not be included",
            "description": "Keywords that should not be included in search results."
          }
        },
        "required": [
          "and_keywords"
        ],
        "title": "YouTube search conditions"
      },
      "IGoogleScholar.ISearchOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Unique id of search result data",
            "description": "Unique id of search result data."
          },
          "title": {
            "type": "string",
            "title": "Title of the paper searched",
            "description": "This is the title of the paper searched."
          },
          "link": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Link to the searched paper",
            "description": "Here is the link to the searched paper."
          },
          "snippet": {
            "type": "string",
            "title": "Snippet of the search results",
            "description": "Here is a snippet of the search results."
          },
          "publication_info": {
            "type": "string",
            "title": "Publication Summary Information",
            "description": "Here is the publication summary information for the searched paper."
          },
          "resource": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGoogleScholar.IResource"
                }
              }
            ],
            "title": "Reference information",
            "description": "Here is the reference information for the searched paper."
          },
          "citation_count": {
            "type": "integer",
            "title": "Number of times cited",
            "description": "The number of times the searched paper was cited."
          },
          "related_pages_link": {
            "type": "string",
            "format": "iri",
            "title": "Links to related academic materials",
            "description": "Here are links to academic materials related to the searched paper."
          },
          "version_info": {
            "$ref": "#/components/schemas/IGoogleScholar.IVersion",
            "title": "Version information",
            "description": "Here is the version information for the searched paper."
          }
        },
        "required": [
          "id",
          "title",
          "link",
          "snippet",
          "publication_info",
          "resource",
          "citation_count",
          "related_pages_link",
          "version_info"
        ],
        "title": "Search Results"
      },
      "IGoogleScholar.IResource": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title of the reference material",
            "description": "Title of the reference material."
          },
          "file_format": {
            "type": "string",
            "title": "Reference file format",
            "description": "This is the format of the reference file."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Link to the reference material",
            "description": "Here is a link to the reference material."
          }
        },
        "required": [
          "title",
          "link"
        ],
        "title": "References"
      },
      "IGoogleScholar.IVersion": {
        "type": "object",
        "properties": {
          "version": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Version information",
            "description": "Here is the version information."
          },
          "link": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Version-related links",
            "description": "Here are the version-related links."
          }
        },
        "required": [
          "version",
          "link"
        ],
        "title": "version"
      },
      "IGoogleScholar.ISearchInput": {
        "type": "object",
        "properties": {
          "andKeyword": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "biology"
            },
            "title": "Keywords that must be included",
            "description": "Keywords that must be included in search results."
          },
          "orKeyword": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "ecosystem"
            },
            "title": "Keywords that you would like to see included",
            "description": "Keywords that you would like to see included in your search results."
          },
          "notKeyword": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "pollution"
            },
            "title": "Keywords to exclude",
            "description": "Keywords that should not be included in search results."
          },
          "max_results": {
            "type": "integer",
            "x-wrtn-placeholder": "10",
            "title": "Number of search results",
            "description": "Sets how many search results to retrieve."
          }
        },
        "required": [
          "andKeyword",
          "max_results"
        ],
        "title": "Search Conditions"
      },
      "ICsv.IReadOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {},
              "required": [],
              "additionalProperties": {
                "type": "string"
              }
            },
            "title": "csv data list",
            "description": "Read csv file data."
          }
        },
        "required": [
          "data"
        ],
        "title": "Csv file reading result"
      },
      "ICsv.IReadInput": {
        "type": "object",
        "properties": {
          "s3Url": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "text/csv",
            "title": "file",
            "description": "This is the Csv file to read."
          },
          "delimiter": {
            "type": "string",
            "x-wrtn-placeholder": ",",
            "title": "delimiter",
            "description": "This is the CSV file delimiter to read."
          }
        },
        "required": [
          "s3Url",
          "delimiter"
        ],
        "title": "Csv file information"
      },
      "ICsv.IWriteOutput": {
        "type": "object",
        "properties": {
          "s3Url": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "text/csv",
            "title": "csv file",
            "description": "This is the s3 url of the csv file that was created."
          }
        },
        "required": [
          "s3Url"
        ],
        "title": "Csv file creation result"
      },
      "ICsv.IWriteInput": {
        "type": "object",
        "properties": {
          "fileName": {
            "type": "string",
            "x-wrtn-placeholder": "example.csv",
            "title": "File name",
            "description": "The name of the Csv file to be created."
          },
          "delimiter": {
            "type": "string",
            "x-wrtn-placeholder": ",",
            "title": "delimiter",
            "description": "The Csv file delimiter to be generated."
          },
          "values": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {},
              "required": [],
              "additionalProperties": {
                "type": "string"
              }
            },
            "title": "File data values",
            "description": "These are the data values to be placed in the Csv file to be created."
          }
        },
        "required": [
          "fileName",
          "delimiter",
          "values"
        ],
        "title": "Information required to create a CSV file"
      },
      "ICsv.ICsvToExcelOutput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "text/csv",
            "title": "s3 url",
            "description": "Here is the s3 url of the converted excel file."
          }
        },
        "required": [
          "url"
        ],
        "title": "Csv file to Excel file conversion result"
      },
      "ICsv.ICsvToExcelInput": {
        "type": "object",
        "properties": {
          "s3Url": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "text/csv",
            "title": "file",
            "description": "This is the file to convert from csv to excel."
          },
          "delimiter": {
            "type": "string",
            "x-wrtn-placeholder": ",",
            "title": "delimiter",
            "description": "This is the file delimiter to convert from csv to excel."
          }
        },
        "required": [
          "s3Url",
          "delimiter"
        ],
        "title": "Information needed to convert a Csv file to an Excel file"
      },
      "INotion.IDeleteBlockInput": {
        "type": "object",
        "properties": {
          "block_id": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "block_id",
            "description": "\nIndicates the ID of the page or block within the page to be deleted.\nIf you delete the page, it will go to the trash, so recovery is possible."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "block_id",
          "secretKey"
        ]
      },
      "INotion.IAppendPageByMarkdownOutput": {
        "type": "object",
        "properties": {
          "link": {
            "type": "string",
            "format": "iri",
            "title": "page link"
          },
          "id": {
            "type": "string",
            "title": "page id",
            "description": "Unique id of the generated page"
          }
        },
        "required": [
          "link",
          "id"
        ]
      },
      "INotion.IAppendPageByMarkdownInput": {
        "type": "object",
        "properties": {
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          },
          "markdown": {
            "type": "string",
            "title": "markdown",
            "description": "If you add a markdown string, it will be converted appropriately according to the Notion's block.\nTherefore, you don't have to use Unicode symbols to implement lists or decorate documents using letters.\nOf course, this depends on the user, and there is no problem using the character string you want, such as inserting an emoji as well as Unicode."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "pageId",
          "markdown",
          "secretKey"
        ]
      },
      "INotion.ICreateChildContentTypeFileInput": {
        "type": "object",
        "properties": {
          "file": {
            "type": "object",
            "properties": {
              "external": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "iri",
                    "title": "url\n\nYou can enter the path of the file you want to upload."
                  }
                },
                "required": [
                  "url"
                ],
                "title": "external"
              },
              "name": {
                "type": "string",
                "title": "filename"
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "title": "content"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri",
                              "title": "url"
                            }
                          },
                          "required": [
                            "url"
                          ],
                          "title": "link"
                        }
                      },
                      "required": [
                        "content"
                      ],
                      "title": "text"
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption for this file"
              }
            },
            "required": [
              "external"
            ],
            "title": "file"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "file",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeEmbedInput": {
        "type": "object",
        "properties": {
          "embed": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url\n\nYou can enter the path of the file you want to embed."
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "title": "content"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri",
                              "title": "url"
                            }
                          },
                          "required": [
                            "url"
                          ],
                          "title": "link"
                        }
                      },
                      "required": [
                        "content"
                      ],
                      "title": "text"
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this embed"
              }
            },
            "required": [
              "url"
            ],
            "title": "embed"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "embed",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeBookmarkInput": {
        "type": "object",
        "properties": {
          "bookmark": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url\n\nYou can enter the path of the file you want to bookmark."
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "title": "content"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri",
                              "title": "url"
                            }
                          },
                          "required": [
                            "url"
                          ],
                          "title": "link"
                        }
                      },
                      "required": [
                        "content"
                      ],
                      "title": "text"
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this bookmark"
              }
            },
            "required": [
              "url"
            ],
            "title": "bookmark"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "bookmark",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeImageInput": {
        "type": "object",
        "properties": {
          "image": {
            "type": "object",
            "properties": {
              "external": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "uri",
                    "pattern": ".*\\.(bmp|gif|heic|jpe?g|png|svg|tiff?)(\\?.*)?",
                    "title": "url",
                    "description": "image file's extension is one of: 'bmp', 'gif', 'heic', 'jpg', 'jpeg', 'png', 'svg', 'tif', 'tiff'."
                  }
                },
                "required": [
                  "url"
                ],
                "title": "external"
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "title": "content"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri",
                              "title": "url"
                            }
                          },
                          "required": [
                            "url"
                          ],
                          "title": "link"
                        }
                      },
                      "required": [
                        "content"
                      ],
                      "title": "text"
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this image"
              }
            },
            "required": [
              "external"
            ],
            "title": "image"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "image",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeVideoInput": {
        "type": "object",
        "properties": {
          "video": {
            "type": "object",
            "properties": {
              "external": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "iri",
                    "title": "url",
                    "description": "video file must be one of: 'amv' ,'asf' ,'avi' ,'f4v' ,'flv' ,'gifv' ,'mkv' ,'mov' ,'mpg' ,'mpeg' ,'mpv' ,'mp4' ,'m4v' ,'qt' ,'wmv'\nOR\nYouTube video links that include embed or watch.\nE.g. https://www.youtube.com/watch?v=[id], https://www.youtube.com/embed/[id]"
                  }
                },
                "required": [
                  "url"
                ],
                "title": "external"
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "title": "content"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri",
                              "title": "url"
                            }
                          },
                          "required": [
                            "url"
                          ],
                          "title": "link"
                        }
                      },
                      "required": [
                        "content"
                      ],
                      "title": "text"
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this embed"
              }
            },
            "required": [
              "external"
            ],
            "title": "video"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "video",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypePdfInput": {
        "type": "object",
        "properties": {
          "pdf": {
            "type": "object",
            "properties": {
              "external": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "iri",
                    "pattern": ".*\\.(pdf)(\\?.*)?",
                    "title": "url"
                  }
                },
                "required": [
                  "url"
                ],
                "title": "external"
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "title": "content"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri",
                              "title": "url"
                            }
                          },
                          "required": [
                            "url"
                          ],
                          "title": "link"
                        }
                      },
                      "required": [
                        "content"
                      ],
                      "title": "text"
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this pdf"
              }
            },
            "required": [
              "external"
            ],
            "title": "pdf"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "pdf",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeCodeInput": {
        "type": "object",
        "properties": {
          "code": {
            "type": "object",
            "properties": {
              "language": {
                "oneOf": [
                  {
                    "const": "c"
                  },
                  {
                    "const": "json"
                  },
                  {
                    "const": "diff"
                  },
                  {
                    "const": "html"
                  },
                  {
                    "const": "markdown"
                  },
                  {
                    "const": "r"
                  },
                  {
                    "const": "abap"
                  },
                  {
                    "const": "agda"
                  },
                  {
                    "const": "arduino"
                  },
                  {
                    "const": "assembly"
                  },
                  {
                    "const": "bash"
                  },
                  {
                    "const": "basic"
                  },
                  {
                    "const": "bnf"
                  },
                  {
                    "const": "c#"
                  },
                  {
                    "const": "c++"
                  },
                  {
                    "const": "clojure"
                  },
                  {
                    "const": "coffeescript"
                  },
                  {
                    "const": "coq"
                  },
                  {
                    "const": "css"
                  },
                  {
                    "const": "dart"
                  },
                  {
                    "const": "dhall"
                  },
                  {
                    "const": "docker"
                  },
                  {
                    "const": "ebnf"
                  },
                  {
                    "const": "elixir"
                  },
                  {
                    "const": "elm"
                  },
                  {
                    "const": "erlang"
                  },
                  {
                    "const": "f#"
                  },
                  {
                    "const": "flow"
                  },
                  {
                    "const": "fortran"
                  },
                  {
                    "const": "gherkin"
                  },
                  {
                    "const": "glsl"
                  },
                  {
                    "const": "go"
                  },
                  {
                    "const": "graphql"
                  },
                  {
                    "const": "groovy"
                  },
                  {
                    "const": "haskell"
                  },
                  {
                    "const": "idris"
                  },
                  {
                    "const": "java"
                  },
                  {
                    "const": "javascript"
                  },
                  {
                    "const": "julia"
                  },
                  {
                    "const": "kotlin"
                  },
                  {
                    "const": "latex"
                  },
                  {
                    "const": "less"
                  },
                  {
                    "const": "lisp"
                  },
                  {
                    "const": "livescript"
                  },
                  {
                    "const": "llvm ir"
                  },
                  {
                    "const": "lua"
                  },
                  {
                    "const": "makefile"
                  },
                  {
                    "const": "markup"
                  },
                  {
                    "const": "matlab"
                  },
                  {
                    "const": "mathematica"
                  },
                  {
                    "const": "mermaid"
                  },
                  {
                    "const": "nix"
                  },
                  {
                    "const": "notion formula"
                  },
                  {
                    "const": "objective-c"
                  },
                  {
                    "const": "ocaml"
                  },
                  {
                    "const": "pascal"
                  },
                  {
                    "const": "perl"
                  },
                  {
                    "const": "php"
                  },
                  {
                    "const": "plain text"
                  },
                  {
                    "const": "powershell"
                  },
                  {
                    "const": "prolog"
                  },
                  {
                    "const": "protobuf"
                  },
                  {
                    "const": "purescript"
                  },
                  {
                    "const": "python"
                  },
                  {
                    "const": "racket"
                  },
                  {
                    "const": "reason"
                  },
                  {
                    "const": "ruby"
                  },
                  {
                    "const": "rust"
                  },
                  {
                    "const": "sass"
                  },
                  {
                    "const": "scala"
                  },
                  {
                    "const": "scheme"
                  },
                  {
                    "const": "scss"
                  },
                  {
                    "const": "shell"
                  },
                  {
                    "const": "solidity"
                  },
                  {
                    "const": "sql"
                  },
                  {
                    "const": "swift"
                  },
                  {
                    "const": "toml"
                  },
                  {
                    "const": "typescript"
                  },
                  {
                    "const": "vb.net"
                  },
                  {
                    "const": "verilog"
                  },
                  {
                    "const": "vhdl"
                  },
                  {
                    "const": "visual basic"
                  },
                  {
                    "const": "webassembly"
                  },
                  {
                    "const": "xml"
                  },
                  {
                    "const": "yaml"
                  },
                  {
                    "const": "java/c/c++/c#"
                  }
                ],
                "title": "programming language name"
              },
              "rich_text": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string",
                          "title": "content"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri",
                              "title": "url"
                            }
                          },
                          "required": [
                            "url"
                          ],
                          "title": "link"
                        }
                      },
                      "required": [
                        "content"
                      ],
                      "title": "text"
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "maxItems": 1,
                "title": "rich text for this codebox"
              }
            },
            "required": [
              "language",
              "rich_text"
            ],
            "title": "code"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "code",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeEquationInput": {
        "type": "object",
        "properties": {
          "equation": {
            "type": "object",
            "properties": {
              "expression": {
                "const": "y = 2x",
                "title": "expression\n\nan equation in mathematics"
              }
            },
            "required": [
              "expression"
            ],
            "title": "equation"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "equation",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeDividerInput": {
        "type": "object",
        "properties": {
          "divider": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "divider"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "divider",
          "secretKey",
          "pageId"
        ]
      },
      "Recordstringnever": {
        "type": "object",
        "properties": {},
        "required": [],
        "description": "Construct a type with a set of properties K of type T"
      },
      "INotion.ICreateChildContentTypeTableOfContentsInput": {
        "type": "object",
        "properties": {
          "table_of_contents": {
            "type": "object",
            "properties": {
              "color": {
                "oneOf": [
                  {
                    "const": "default"
                  },
                  {
                    "const": "red"
                  },
                  {
                    "const": "green"
                  },
                  {
                    "const": "blue"
                  },
                  {
                    "const": "gray"
                  },
                  {
                    "const": "brown"
                  },
                  {
                    "const": "orange"
                  },
                  {
                    "const": "yellow"
                  },
                  {
                    "const": "purple"
                  },
                  {
                    "const": "pink"
                  },
                  {
                    "const": "gray_background"
                  },
                  {
                    "const": "brown_background"
                  },
                  {
                    "const": "orange_background"
                  },
                  {
                    "const": "yellow_background"
                  },
                  {
                    "const": "green_background"
                  },
                  {
                    "const": "blue_background"
                  },
                  {
                    "const": "purple_background"
                  },
                  {
                    "const": "pink_background"
                  },
                  {
                    "const": "red_background"
                  }
                ],
                "title": "color",
                "description": "It must be one of :\n\"default\", \"gray\", \"brown\", \"orange\", \"yellow\", \"green\", \"blue\", \"purple\", \"pink\", \"red\", \"gray_background\", \"brown_background\", \"orange_background\", \"yellow_background\", \"green_background\", \"blue_background\", \"purple_background\", \"pink_background\", \"red_background\""
              }
            },
            "required": [
              "color"
            ],
            "title": "table_of_contents"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "table_of_contents",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeLinkToPageInput": {
        "type": "object",
        "properties": {
          "link_to_page": {
            "type": "object",
            "properties": {
              "page_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/notion/get/page",
                      "jmesPath": "[].{value:pageId, label:title}"
                    },
                    "x-wrtn-placeholder": "부모 페이지를 선택하세요."
                  },
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/notion/page",
                      "jmesPath": "[].{value:id, label:id}"
                    },
                    "x-wrtn-placeholder": "부모 페이지를 선택하세요."
                  }
                ],
                "title": "page_id",
                "description": "You can look up the page by passing the page ID as a parameter at the end of the notion link.\nFor example, in the format 'https://www.notion.so/ :pageId'."
              }
            },
            "required": [
              "page_id"
            ],
            "title": "link_to_page"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "link_to_page",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeToggleInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          },
          "toggle": {
            "$ref": "#/components/schemas/rich_textMultipleTextLinecolorApiColorundefinedRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...)",
            "title": "toggle"
          }
        },
        "required": [
          "secretKey",
          "pageId",
          "toggle"
        ]
      },
      "rich_textMultipleTextLinecolorApiColorundefinedRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...)": {
        "type": "object",
        "properties": {
          "rich_text": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "object",
                  "properties": {
                    "content": {
                      "type": "string",
                      "title": "content"
                    },
                    "link": {
                      "type": "object",
                      "properties": {
                        "url": {
                          "type": "string",
                          "format": "iri",
                          "title": "url"
                        }
                      },
                      "required": [
                        "url"
                      ],
                      "title": "link"
                    }
                  },
                  "required": [
                    "content"
                  ],
                  "title": "text"
                }
              },
              "required": [
                "text"
              ]
            },
            "maxItems": 1,
            "title": "rich_text"
          },
          "color": {
            "oneOf": [
              {
                "const": "default"
              },
              {
                "const": "red"
              },
              {
                "const": "green"
              },
              {
                "const": "blue"
              },
              {
                "const": "gray"
              },
              {
                "const": "brown"
              },
              {
                "const": "orange"
              },
              {
                "const": "yellow"
              },
              {
                "const": "purple"
              },
              {
                "const": "pink"
              },
              {
                "const": "gray_background"
              },
              {
                "const": "brown_background"
              },
              {
                "const": "orange_background"
              },
              {
                "const": "yellow_background"
              },
              {
                "const": "green_background"
              },
              {
                "const": "blue_background"
              },
              {
                "const": "purple_background"
              },
              {
                "const": "pink_background"
              },
              {
                "const": "red_background"
              }
            ],
            "title": "color"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/togglerich_textMultipleTextLinecolorApiColorundefinedRecordtoggleRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...)"
            }
          }
        },
        "required": [
          "rich_text",
          "children"
        ]
      },
      "togglerich_textMultipleTextLinecolorApiColorundefinedRecordtoggleRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...)": {
        "type": "object",
        "properties": {
          "toggle": {
            "$ref": "#/components/schemas/rich_textMultipleTextLinecolorApiColorundefinedRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...).o1",
            "title": "toggle"
          }
        },
        "required": [
          "toggle"
        ]
      },
      "rich_textMultipleTextLinecolorApiColorundefinedRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...).o1": {
        "type": "object",
        "properties": {
          "rich_text": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "object",
                  "properties": {
                    "content": {
                      "type": "string",
                      "title": "content"
                    },
                    "link": {
                      "type": "object",
                      "properties": {
                        "url": {
                          "type": "string",
                          "format": "iri",
                          "title": "url"
                        }
                      },
                      "required": [
                        "url"
                      ],
                      "title": "link"
                    }
                  },
                  "required": [
                    "content"
                  ],
                  "title": "text"
                }
              },
              "required": [
                "text"
              ]
            },
            "maxItems": 1,
            "title": "rich_text"
          },
          "color": {
            "oneOf": [
              {
                "const": "default"
              },
              {
                "const": "red"
              },
              {
                "const": "green"
              },
              {
                "const": "blue"
              },
              {
                "const": "gray"
              },
              {
                "const": "brown"
              },
              {
                "const": "orange"
              },
              {
                "const": "yellow"
              },
              {
                "const": "purple"
              },
              {
                "const": "pink"
              },
              {
                "const": "gray_background"
              },
              {
                "const": "brown_background"
              },
              {
                "const": "orange_background"
              },
              {
                "const": "yellow_background"
              },
              {
                "const": "green_background"
              },
              {
                "const": "blue_background"
              },
              {
                "const": "purple_background"
              },
              {
                "const": "pink_background"
              },
              {
                "const": "red_background"
              }
            ],
            "title": "color"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/togglerich_textMultipleTextLinecolorApiColorundefinedRecordtoggleRecordchildrentogglerich_textMultipleTextLinecolorApiColorundefined"
            }
          }
        },
        "required": [
          "rich_text",
          "children"
        ]
      },
      "togglerich_textMultipleTextLinecolorApiColorundefinedRecordtoggleRecordchildrentogglerich_textMultipleTextLinecolorApiColorundefined": {
        "type": "object",
        "properties": {
          "toggle": {
            "$ref": "#/components/schemas/rich_textMultipleTextLinecolorApiColorundefinedRecordchildrentogglerich_textMultipleTextLinecolorApiColorundefined",
            "title": "toggle"
          }
        },
        "required": [
          "toggle"
        ]
      },
      "rich_textMultipleTextLinecolorApiColorundefinedRecordchildrentogglerich_textMultipleTextLinecolorApiColorundefined": {
        "type": "object",
        "properties": {
          "rich_text": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "object",
                  "properties": {
                    "content": {
                      "type": "string",
                      "title": "content"
                    },
                    "link": {
                      "type": "object",
                      "properties": {
                        "url": {
                          "type": "string",
                          "format": "iri",
                          "title": "url"
                        }
                      },
                      "required": [
                        "url"
                      ],
                      "title": "link"
                    }
                  },
                  "required": [
                    "content"
                  ],
                  "title": "text"
                }
              },
              "required": [
                "text"
              ]
            },
            "maxItems": 1,
            "title": "rich_text"
          },
          "color": {
            "oneOf": [
              {
                "const": "default"
              },
              {
                "const": "red"
              },
              {
                "const": "green"
              },
              {
                "const": "blue"
              },
              {
                "const": "gray"
              },
              {
                "const": "brown"
              },
              {
                "const": "orange"
              },
              {
                "const": "yellow"
              },
              {
                "const": "purple"
              },
              {
                "const": "pink"
              },
              {
                "const": "gray_background"
              },
              {
                "const": "brown_background"
              },
              {
                "const": "orange_background"
              },
              {
                "const": "yellow_background"
              },
              {
                "const": "green_background"
              },
              {
                "const": "blue_background"
              },
              {
                "const": "purple_background"
              },
              {
                "const": "pink_background"
              },
              {
                "const": "red_background"
              }
            ],
            "title": "color"
          },
          "children": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "toggle": {
                  "type": "object",
                  "properties": {
                    "rich_text": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "text": {
                            "type": "object",
                            "properties": {
                              "content": {
                                "type": "string",
                                "title": "content"
                              },
                              "link": {
                                "type": "object",
                                "properties": {
                                  "url": {
                                    "type": "string",
                                    "format": "iri",
                                    "title": "url"
                                  }
                                },
                                "required": [
                                  "url"
                                ],
                                "title": "link"
                              }
                            },
                            "required": [
                              "content"
                            ],
                            "title": "text"
                          }
                        },
                        "required": [
                          "text"
                        ]
                      },
                      "maxItems": 1,
                      "title": "rich_text"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "red"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        },
                        {
                          "const": "gray_background"
                        },
                        {
                          "const": "brown_background"
                        },
                        {
                          "const": "orange_background"
                        },
                        {
                          "const": "yellow_background"
                        },
                        {
                          "const": "green_background"
                        },
                        {
                          "const": "blue_background"
                        },
                        {
                          "const": "purple_background"
                        },
                        {
                          "const": "pink_background"
                        },
                        {
                          "const": "red_background"
                        }
                      ],
                      "title": "color"
                    }
                  },
                  "required": [
                    "rich_text"
                  ],
                  "title": "toggle"
                }
              },
              "required": [
                "toggle"
              ]
            }
          }
        },
        "required": [
          "rich_text",
          "children"
        ]
      },
      "INotion.IReadPageContentOutput": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "title": "content",
            "description": "The contents of the page you  read.\n\nThe contents are in Markdown format."
          }
        },
        "required": [
          "content"
        ]
      },
      "INotion.IReadPageContentInput": {
        "type": "object",
        "properties": {
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Indicates the ID of the page.\n\nThe unique ID of the page from which you want to read the content."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "pageId",
          "secretKey"
        ]
      },
      "INotion.IReadPageOutput": {
        "type": "object",
        "properties": {
          "pageId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/notion/get/page",
              "jmesPath": "[].{value:pageId, label:title}"
            },
            "title": "id",
            "description": "페이지 고유 id\n\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here."
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "Page Title"
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "page link"
          }
        },
        "required": [
          "pageId",
          "title",
          "link"
        ],
        "title": "Page list query results"
      },
      "INotion.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "INotion.IUserOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "User unique id"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Username"
          }
        },
        "required": [
          "id",
          "name"
        ],
        "title": "User list query results"
      },
      "INotion.IDatabaseInfo": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "database unique id"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "Database Title"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Database Page URL"
          },
          "properties": {
            "$ref": "#/components/schemas/RecordstringINotion.DatabaseProperty",
            "title": "property",
            "description": "Database property information"
          }
        },
        "required": [
          "id",
          "title",
          "url",
          "properties"
        ],
        "title": "Database Information"
      },
      "RecordstringINotion.DatabaseProperty": {
        "type": "object",
        "properties": {},
        "required": [],
        "description": "Construct a type with a set of properties K of type T",
        "additionalProperties": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/INotion.NumberDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.FormulaDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.SelectDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.MultiSelectDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.StatusDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.RelationDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.RollupDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.TitleDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.RichTextDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.UrlDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.PeopleDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.FilesDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.EmailDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.PhoneNumberDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.DateDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.CheckboxDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.CreatedByDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.CreatedTimeDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.LastEditedByDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.LastEditedTimeDatabaseProperty"
            }
          ],
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "number": "#/components/schemas/INotion.NumberDatabaseProperty",
              "formula": "#/components/schemas/INotion.FormulaDatabaseProperty",
              "select": "#/components/schemas/INotion.SelectDatabaseProperty",
              "multi_select": "#/components/schemas/INotion.MultiSelectDatabaseProperty",
              "status": "#/components/schemas/INotion.StatusDatabaseProperty",
              "relation": "#/components/schemas/INotion.RelationDatabaseProperty",
              "rollup": "#/components/schemas/INotion.RollupDatabaseProperty",
              "title": "#/components/schemas/INotion.TitleDatabaseProperty",
              "rich_text": "#/components/schemas/INotion.RichTextDatabaseProperty",
              "url": "#/components/schemas/INotion.UrlDatabaseProperty",
              "people": "#/components/schemas/INotion.PeopleDatabaseProperty",
              "files": "#/components/schemas/INotion.FilesDatabaseProperty",
              "email": "#/components/schemas/INotion.EmailDatabaseProperty",
              "phone_number": "#/components/schemas/INotion.PhoneNumberDatabaseProperty",
              "date": "#/components/schemas/INotion.DateDatabaseProperty",
              "checkbox": "#/components/schemas/INotion.CheckboxDatabaseProperty",
              "created_by": "#/components/schemas/INotion.CreatedByDatabaseProperty",
              "created_time": "#/components/schemas/INotion.CreatedTimeDatabaseProperty",
              "last_edited_by": "#/components/schemas/INotion.LastEditedByDatabaseProperty",
              "last_edited_time": "#/components/schemas/INotion.LastEditedTimeDatabaseProperty"
            }
          }
        }
      },
      "INotion.NumberDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "number",
            "title": "type"
          },
          "number": {
            "type": "object",
            "properties": {
              "format": {
                "oneOf": [
                  {
                    "const": "number"
                  },
                  {
                    "const": "percent"
                  },
                  {
                    "const": "number_with_commas"
                  },
                  {
                    "const": "dollar"
                  },
                  {
                    "const": "canadian_dollar"
                  },
                  {
                    "const": "singapore_dollar"
                  },
                  {
                    "const": "euro"
                  },
                  {
                    "const": "pound"
                  },
                  {
                    "const": "yen"
                  },
                  {
                    "const": "ruble"
                  },
                  {
                    "const": "rupee"
                  },
                  {
                    "const": "won"
                  },
                  {
                    "const": "yuan"
                  },
                  {
                    "const": "real"
                  },
                  {
                    "const": "lira"
                  },
                  {
                    "const": "rupiah"
                  },
                  {
                    "const": "franc"
                  },
                  {
                    "const": "hong_kong_dollar"
                  },
                  {
                    "const": "new_zealand_dollar"
                  },
                  {
                    "const": "krona"
                  },
                  {
                    "const": "norwegian_krone"
                  },
                  {
                    "const": "mexican_peso"
                  },
                  {
                    "const": "rand"
                  },
                  {
                    "const": "new_taiwan_dollar"
                  },
                  {
                    "const": "danish_krone"
                  },
                  {
                    "const": "zloty"
                  },
                  {
                    "const": "baht"
                  },
                  {
                    "const": "forint"
                  },
                  {
                    "const": "koruna"
                  },
                  {
                    "const": "shekel"
                  },
                  {
                    "const": "chilean_peso"
                  },
                  {
                    "const": "philippine_peso"
                  },
                  {
                    "const": "dirham"
                  },
                  {
                    "const": "colombian_peso"
                  },
                  {
                    "const": "riyal"
                  },
                  {
                    "const": "ringgit"
                  },
                  {
                    "const": "leu"
                  },
                  {
                    "const": "argentine_peso"
                  },
                  {
                    "const": "uruguayan_peso"
                  },
                  {
                    "const": "peruvian_sol"
                  }
                ],
                "title": "format"
              }
            },
            "required": [
              "format"
            ],
            "title": "number"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "number"
        ],
        "title": "Database numeric properties"
      },
      "INotion.FormulaDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "formula",
            "title": "type"
          },
          "formula": {
            "type": "object",
            "properties": {
              "expression": {
                "type": "string",
                "title": "expression"
              }
            },
            "required": [
              "expression"
            ],
            "title": "formula"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "formula"
        ],
        "title": "Database official properties"
      },
      "INotion.SelectDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "select",
            "title": "type"
          },
          "select": {
            "type": "object",
            "properties": {
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "title": "id"
                    },
                    "name": {
                      "type": "string",
                      "title": "name"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "red"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        }
                      ],
                      "title": "color"
                    }
                  },
                  "required": [
                    "id",
                    "name",
                    "color"
                  ]
                },
                "title": "options"
              }
            },
            "required": [
              "options"
            ],
            "title": "select"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "select"
        ],
        "title": "Database Selection Attributes"
      },
      "INotion.MultiSelectDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "multi_select",
            "title": "type"
          },
          "multi_select": {
            "type": "object",
            "properties": {
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "title": "id"
                    },
                    "name": {
                      "type": "string",
                      "title": "name"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "red"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        }
                      ],
                      "title": "color"
                    }
                  },
                  "required": [
                    "id",
                    "name",
                    "color"
                  ]
                },
                "title": "options"
              }
            },
            "required": [
              "options"
            ],
            "title": "multi_select"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "multi_select"
        ],
        "title": "Database Multi-Select Attribute"
      },
      "INotion.StatusDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "status",
            "title": "type"
          },
          "status": {
            "type": "object",
            "properties": {
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "title": "id"
                    },
                    "name": {
                      "type": "string",
                      "title": "name"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "red"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        }
                      ],
                      "title": "color"
                    }
                  },
                  "required": [
                    "id",
                    "name",
                    "color"
                  ]
                },
                "title": "options"
              },
              "groups": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "title": "id"
                    },
                    "name": {
                      "type": "string",
                      "title": "name"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "red"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        }
                      ],
                      "title": "color"
                    },
                    "option_ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "option_ids"
                    }
                  },
                  "required": [
                    "id",
                    "name",
                    "color",
                    "option_ids"
                  ]
                },
                "title": "groups"
              }
            },
            "required": [
              "options",
              "groups"
            ],
            "title": "status"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "status"
        ],
        "title": "Database status properties"
      },
      "INotion.RelationDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "relation",
            "title": "type"
          },
          "relation": {
            "type": "object",
            "properties": {
              "database_id": {
                "type": "string",
                "title": "database_id"
              },
              "synced_property_id": {
                "type": "string",
                "title": "synced_property_id"
              },
              "synced_property_name": {
                "type": "string",
                "title": "synced_property_name"
              }
            },
            "required": [
              "database_id",
              "synced_property_id",
              "synced_property_name"
            ],
            "title": "relation"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "relation"
        ],
        "title": "Database Relationship Properties"
      },
      "INotion.RollupDatabaseProperty": {
        "type": "object",
        "properties": {
          "type": {
            "const": "rollup",
            "title": "type"
          },
          "rollup": {
            "type": "object",
            "properties": {
              "rollup_property_name": {
                "type": "string",
                "title": "rollup_property_name"
              },
              "relation_property_name": {
                "type": "string",
                "title": "relation_property_name"
              },
              "rollup_property_id": {
                "type": "string",
                "title": "rollup_property_id"
              },
              "relation_property_id": {
                "type": "string",
                "title": "relation_property_id"
              },
              "function": {
                "oneOf": [
                  {
                    "const": "date_range"
                  },
                  {
                    "const": "count"
                  },
                  {
                    "const": "range"
                  },
                  {
                    "const": "average"
                  },
                  {
                    "const": "unique"
                  },
                  {
                    "const": "count_values"
                  },
                  {
                    "const": "empty"
                  },
                  {
                    "const": "not_empty"
                  },
                  {
                    "const": "show_unique"
                  },
                  {
                    "const": "percent_empty"
                  },
                  {
                    "const": "percent_not_empty"
                  },
                  {
                    "const": "sum"
                  },
                  {
                    "const": "median"
                  },
                  {
                    "const": "min"
                  },
                  {
                    "const": "max"
                  },
                  {
                    "const": "earliest_date"
                  },
                  {
                    "const": "latest_date"
                  },
                  {
                    "const": "checked"
                  },
                  {
                    "const": "unchecked"
                  },
                  {
                    "const": "percent_checked"
                  },
                  {
                    "const": "percent_unchecked"
                  },
                  {
                    "const": "count_per_group"
                  },
                  {
                    "const": "percent_per_group"
                  },
                  {
                    "const": "show_original"
                  }
                ],
                "title": "function"
              }
            },
            "required": [
              "rollup_property_name",
              "relation_property_name",
              "rollup_property_id",
              "relation_property_id",
              "function"
            ],
            "title": "rollup"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          }
        },
        "required": [
          "type",
          "rollup",
          "id",
          "name"
        ],
        "title": "Database Aggregate Properties"
      },
      "INotion.TitleDatabaseProperty": {
        "type": "object",
        "properties": {
          "type": {
            "const": "title",
            "title": "type"
          },
          "title": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "title"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          }
        },
        "required": [
          "type",
          "title",
          "id",
          "name"
        ],
        "title": "Database title property"
      },
      "INotion.RichTextDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "rich_text",
            "title": "type"
          },
          "rich_text": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "rich_text"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "rich_text"
        ],
        "title": "database text property"
      },
      "INotion.UrlDatabaseProperty": {
        "type": "object",
        "properties": {
          "type": {
            "const": "url",
            "title": "type"
          },
          "url": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "url"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          }
        },
        "required": [
          "type",
          "url",
          "id",
          "name"
        ],
        "title": "Database Url property"
      },
      "INotion.PeopleDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "people",
            "title": "type"
          },
          "people": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "people"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "people"
        ],
        "title": "database people properties"
      },
      "INotion.FilesDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "files",
            "title": "type"
          },
          "files": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "files"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "files"
        ],
        "title": "Database File Properties"
      },
      "INotion.EmailDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "email",
            "title": "type"
          },
          "email": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "email"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "email"
        ],
        "title": "Database Email Attributes"
      },
      "INotion.PhoneNumberDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "phone_number",
            "title": "type"
          },
          "phone_number": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "phone_number"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "phone_number"
        ],
        "title": "Database Phone Number Attribute"
      },
      "INotion.DateDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "date",
            "title": "type"
          },
          "date": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "date"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "date"
        ],
        "title": "Database Date Attribute"
      },
      "INotion.CheckboxDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "checkbox",
            "title": "type"
          },
          "checkbox": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "checkbox"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "checkbox"
        ],
        "title": "Database Checkbox Properties"
      },
      "INotion.CreatedByDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "created_by",
            "title": "type"
          }
        },
        "required": [
          "id",
          "name",
          "type"
        ],
        "title": "Database Creator Attributes"
      },
      "INotion.CreatedTimeDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "created_time",
            "title": "type"
          },
          "created_time": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "created_time"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "created_time"
        ],
        "title": "Database Creation Time Attribute"
      },
      "INotion.LastEditedByDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "last_edited_by",
            "title": "type"
          },
          "last_edited_by": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "last_edited_by"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "last_edited_by"
        ],
        "title": "Database Last Modified Attribute"
      },
      "INotion.LastEditedTimeDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "type": {
            "const": "last_edited_time",
            "title": "type"
          },
          "last_edited_time": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "last_edited_time"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "last_edited_time"
        ],
        "title": "Database Modification Time Attribute"
      },
      "INotion.IFindPageByTitleOutput": {
        "type": "object",
        "properties": {
          "parent": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "title": "Type",
                "description": "Parent Page Object Type"
              },
              "workspace": {
                "type": "boolean",
                "title": "Whether the workspace is",
                "description": "Whether the parent page is a workspace"
              }
            },
            "required": [
              "type"
            ],
            "title": "Parent Page",
            "description": "Parent Page Information"
          },
          "properties": {
            "$ref": "#/components/schemas/INotion.IFindPageProperty",
            "title": "property",
            "description": "Page Properties Information"
          },
          "object": {
            "oneOf": [
              {
                "const": "user"
              },
              {
                "const": "page"
              },
              {
                "const": "list"
              },
              {
                "const": "comment"
              },
              {
                "const": "database"
              },
              {
                "const": "block"
              },
              {
                "const": "property_item"
              }
            ],
            "title": "Object Type",
            "description": "Type of page object"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Page url"
          },
          "id": {
            "type": "string",
            "title": "page id",
            "description": "Unique id of the generated page"
          },
          "created_time": {
            "type": "string",
            "title": "Date created",
            "description": "Date the page was created"
          },
          "last_edited_time": {
            "type": "string",
            "title": "Last modified",
            "description": "Date the page was last modified"
          },
          "created_by": {
            "type": "object",
            "properties": {
              "object": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "page"
                  },
                  {
                    "const": "list"
                  },
                  {
                    "const": "comment"
                  },
                  {
                    "const": "database"
                  },
                  {
                    "const": "block"
                  },
                  {
                    "const": "property_item"
                  }
                ],
                "title": "Object Type",
                "description": "The type of the object that created the page"
              },
              "id": {
                "type": "string",
                "title": "id",
                "description": "Unique id of the person who created the page"
              }
            },
            "required": [
              "object",
              "id"
            ],
            "title": "Created by",
            "description": "Information about who created the page"
          },
          "last_edited_by": {
            "type": "object",
            "properties": {
              "object": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "page"
                  },
                  {
                    "const": "list"
                  },
                  {
                    "const": "comment"
                  },
                  {
                    "const": "database"
                  },
                  {
                    "const": "block"
                  },
                  {
                    "const": "property_item"
                  }
                ],
                "title": "Object Type",
                "description": "The type of object that last modified the page"
              },
              "id": {
                "type": "string",
                "title": "id",
                "description": "Unique id of the last person to edit the page"
              }
            },
            "required": [
              "object",
              "id"
            ],
            "title": "Last modified by",
            "description": "Information about who last modified the page"
          },
          "cover": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IPageCover"
              }
            ],
            "title": "Background Image",
            "description": "Page Background Image Information"
          },
          "icon": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IPageIcon"
              }
            ],
            "title": "Icon",
            "description": "Page Icon Information"
          },
          "archived": {
            "type": "boolean",
            "title": "Whether to archive the page",
            "description": "Whether to archive the page"
          },
          "public_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "public url",
            "description": "Page public url"
          }
        },
        "required": [
          "parent",
          "properties",
          "object",
          "url",
          "id",
          "created_time",
          "last_edited_time",
          "created_by",
          "last_edited_by",
          "cover",
          "icon",
          "archived",
          "public_url"
        ]
      },
      "INotion.IFindPageProperty": {
        "type": "object",
        "properties": {
          "title": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "id",
                "description": "Page property id"
              },
              "type": {
                "type": "string",
                "title": "Property Type",
                "description": "Page Property Type"
              },
              "title": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/INotion.IFindPageTitleProperty"
                },
                "title": "Title Attribute",
                "description": "Page Title Attribute Information"
              }
            },
            "required": [
              "id",
              "type",
              "title"
            ],
            "title": "Title attribute",
            "description": "Information about the title attribute"
          }
        },
        "required": [
          "title"
        ],
        "title": "Page property information"
      },
      "INotion.IFindPageTitleProperty": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "title": "type",
            "description": "Title property type"
          },
          "text": {
            "$ref": "#/components/schemas/INotion.IPageTitleText",
            "title": "Text Information",
            "description": "Page Title Text Information"
          },
          "annotations": {
            "$ref": "#/components/schemas/INotion.IPageTitleAnnotation",
            "title": "Additional Information",
            "description": "Page Title Additional Information"
          },
          "plain_text": {
            "type": "string",
            "title": "Original",
            "description": "Page Title Original Text"
          },
          "href": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Link",
            "description": "Page Link"
          }
        },
        "required": [
          "type",
          "text",
          "annotations",
          "plain_text",
          "href"
        ],
        "title": "Page title attribute"
      },
      "INotion.IPageTitleText": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "title": "Content",
            "description": "Title Text Content"
          },
          "link": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Link",
            "description": "Page Title Link"
          }
        },
        "required": [
          "content",
          "link"
        ],
        "title": "Page title text information"
      },
      "INotion.IPageTitleAnnotation": {
        "type": "object",
        "properties": {
          "bold": {
            "type": "boolean",
            "title": "Bold",
            "description": "Title Text Bold"
          },
          "italic": {
            "type": "boolean",
            "title": "italicized",
            "description": "Title text italicized"
          },
          "strikethrough": {
            "type": "boolean",
            "title": "strikethrough",
            "description": "Title text strikethrough"
          },
          "underline": {
            "type": "boolean",
            "title": "underline",
            "description": "Title text underline"
          },
          "code": {
            "type": "boolean",
            "title": "Whether the title text is wrapped in code",
            "description": "Whether the title text is wrapped in code"
          },
          "color": {
            "type": "string",
            "title": "Color",
            "description": "Title Text Color"
          }
        },
        "required": [
          "bold",
          "italic",
          "strikethrough",
          "underline",
          "code",
          "color"
        ],
        "title": "Page title Additional information"
      },
      "INotion.IPageCover": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "description": "Image Type"
          },
          "external": {
            "$ref": "#/components/schemas/INotion.IExternalImage",
            "title": "Image",
            "description": "Image information"
          }
        },
        "required": [
          "type",
          "external"
        ],
        "title": "Page background image information"
      },
      "INotion.IExternalImage": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "image url"
          }
        },
        "required": [
          "url"
        ],
        "title": "External image information"
      },
      "INotion.IPageIcon": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "file"
              },
              {
                "const": "emoji"
              },
              {
                "const": "external"
              }
            ],
            "title": "Type",
            "description": "Icon Type"
          },
          "emoji": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Emoji icon",
            "description": "Icon information when the icon type is emoji"
          },
          "external": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IExternalImage"
              }
            ],
            "title": "Icon",
            "description": "Icon information when the icon type is icon"
          },
          "file": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url",
                "description": "file url"
              },
              "expiry_time": {
                "type": "string",
                "title": "expiration time",
                "description": "Image file expiration time"
              }
            },
            "required": [
              "url",
              "expiry_time"
            ],
            "title": "Icon file",
            "description": "Icon information when the icon type is file"
          }
        },
        "required": [
          "type"
        ],
        "title": "Page Icon Information"
      },
      "INotion.IFindPageOrDatabaseItemInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "description": "Page Title"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Information needed to search the page"
      },
      "INotion.IDatabaseItemOutput": {
        "type": "object",
        "properties": {
          "parent": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "title": "type",
                "description": "Parent database item object type"
              },
              "database_id": {
                "type": "string",
                "title": "database id",
                "description": "database item parent id"
              }
            },
            "required": [
              "type",
              "database_id"
            ],
            "title": "Parent Database Item",
            "description": "Parent Database Item Information"
          },
          "properties": {
            "title": "Property",
            "description": "Database Item Properties"
          },
          "object": {
            "oneOf": [
              {
                "const": "user"
              },
              {
                "const": "page"
              },
              {
                "const": "list"
              },
              {
                "const": "comment"
              },
              {
                "const": "database"
              },
              {
                "const": "block"
              },
              {
                "const": "property_item"
              }
            ],
            "title": "Object Type",
            "description": "Type of page object"
          },
          "created_time": {
            "type": "string",
            "title": "Date created",
            "description": "Date the page was created"
          },
          "last_edited_time": {
            "type": "string",
            "title": "Last modified",
            "description": "Date the page was last modified"
          },
          "created_by": {
            "type": "object",
            "properties": {
              "object": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "page"
                  },
                  {
                    "const": "list"
                  },
                  {
                    "const": "comment"
                  },
                  {
                    "const": "database"
                  },
                  {
                    "const": "block"
                  },
                  {
                    "const": "property_item"
                  }
                ],
                "title": "Object Type",
                "description": "The type of the object that created the page"
              },
              "id": {
                "type": "string",
                "title": "id",
                "description": "Unique id of the person who created the page"
              }
            },
            "required": [
              "object",
              "id"
            ],
            "title": "Created by",
            "description": "Information about who created the page"
          },
          "last_edited_by": {
            "type": "object",
            "properties": {
              "object": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "page"
                  },
                  {
                    "const": "list"
                  },
                  {
                    "const": "comment"
                  },
                  {
                    "const": "database"
                  },
                  {
                    "const": "block"
                  },
                  {
                    "const": "property_item"
                  }
                ],
                "title": "Object Type",
                "description": "The type of object that last modified the page"
              },
              "id": {
                "type": "string",
                "title": "id",
                "description": "Unique id of the last person to edit the page"
              }
            },
            "required": [
              "object",
              "id"
            ],
            "title": "Last modified by",
            "description": "Information about who last modified the page"
          },
          "cover": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IPageCover"
              }
            ],
            "title": "Background Image",
            "description": "Page Background Image Information"
          },
          "icon": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IPageIcon"
              }
            ],
            "title": "Icon",
            "description": "Page Icon Information"
          },
          "archived": {
            "type": "boolean",
            "title": "Whether to archive the page",
            "description": "Whether to archive the page"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Page url"
          },
          "public_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "public url",
            "description": "Page public url"
          },
          "id": {
            "type": "string",
            "title": "page id",
            "description": "Unique id of the generated page"
          },
          "title": {
            "type": "string",
            "title": "tilte\n\nTitle of the document you just created"
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "page link"
          }
        },
        "required": [
          "parent",
          "properties",
          "object",
          "created_time",
          "last_edited_time",
          "created_by",
          "last_edited_by",
          "cover",
          "icon",
          "archived",
          "url",
          "public_url",
          "id",
          "title",
          "link"
        ],
        "title": "Database item creation result"
      },
      "INotion.IFindDatabaseItemInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "description": "The title of the item in the database item"
          },
          "number": {
            "type": "integer",
            "title": "Number",
            "description": "Number in database item"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "url in database item"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email address",
            "description": "Email address in database item"
          },
          "rich_text": {
            "type": "string",
            "title": "text",
            "description": "Text in database item"
          },
          "phone_number": {
            "type": "string",
            "title": "Phone number",
            "description": "Phone number in database item"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Information needed to find an item in the database",
        "additionalProperties": {}
      },
      "INotion.ICreatePageByMarkdownInput": {
        "type": "object",
        "properties": {
          "parentPageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "parentPageId"
          },
          "title": {
            "type": "string",
            "x-wrtn-placeholder": "테스트 페이지.",
            "title": "Page title",
            "description": "New page title to be created"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "markdown": {
            "type": "string",
            "title": "markdown",
            "description": "If you add a markdown string, it will be converted appropriately according to the Notion's block.\nTherefore, you don't have to use Unicode symbols to implement lists or decorate documents using letters.\nOf course, this depends on the user, and there is no problem using the character string you want, such as inserting an emoji as well as Unicode."
          }
        },
        "required": [
          "parentPageId",
          "title",
          "secretKey",
          "markdown"
        ]
      },
      "INotion.IUpdateNotionTitleInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title of Page",
            "description": "It means title to update this page"
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "Page ID to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "pageId",
          "secretKey"
        ]
      },
      "INotion.ICreateGalleryDatabaseOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "Database id"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "Title of database"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Page url of database"
          }
        },
        "required": [
          "id",
          "title",
          "url"
        ],
        "title": "Information created a gallery view database"
      },
      "INotion.ICreateGalleryDatabaseInput": {
        "type": "object",
        "properties": {
          "parentPageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "parentPageId"
          },
          "title": {
            "type": "string",
            "title": "databaseTitle"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "parentPageId",
          "title",
          "secretKey"
        ],
        "title": "Information needed to create a gallery view database"
      },
      "INotion.ICreateGalleryDatabaseItemOutput": {
        "type": "object",
        "properties": {
          "pageId": {
            "type": "string",
            "title": "pageId",
            "description": "Created item database id"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "page url",
            "description": "Created item page url"
          }
        },
        "required": [
          "pageId",
          "url"
        ],
        "title": "Information created a gallery view database item"
      },
      "INotion.ICreateGalleryDatabaseItemInput": {
        "type": "object",
        "properties": {
          "databaseId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/notion/get/database-info",
              "jmesPath": "[].{value:id, label:title}"
            },
            "title": "databaseId",
            "description": "Database Id what you want to add a item.\n\nIf the database is not created, you can create a database using the `Create Gallery Database` function first.\nThe endpoint is POST: /connector/notion/create-gallery-database."
          },
          "info": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/INotion.ICreateGalleryDatabaseItemInfo"
            },
            "title": "informations",
            "description": "Information needed to create a gallery database items.\n\nYou can add multiple items at once.\nIf you need to add multiple database items, you should add each piece of information to the info as an array.\nYou should not make multiple calls when you need to add multiple items."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "databaseId",
          "info",
          "secretKey"
        ],
        "title": "Information needed to create a gallery view database items"
      },
      "INotion.ICreateGalleryDatabaseItemInfo": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "title",
            "description": "Database Item Title.\nThe title of the item to be added to the database."
          },
          "markdown": {
            "type": "string",
            "title": "markdown",
            "description": "If you add a markdown string, it will be converted appropriately according to the Notion's block.\nTherefore, you don't have to use Unicode symbols to implement lists or decorate documents using letters.\nOf course, this depends on the user, and there is no problem using the character string you want, such as inserting an emoji as well as Unicode."
          }
        },
        "required": [
          "title",
          "markdown"
        ],
        "title": "Information created a gallery view database item"
      },
      "INotion.IUpdatePageContentInput": {
        "type": "object",
        "properties": {
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId",
            "description": "Page id what you want to update."
          },
          "markdown": {
            "type": "string",
            "title": "markdown",
            "description": "If you add a markdown string, it will be converted appropriately according to the Notion's block.\nTherefore, you don't have to use Unicode symbols to implement lists or decorate documents using letters.\nOf course, this depends on the user, and there is no problem using the character string you want, such as inserting an emoji as well as Unicode."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "pageId",
          "markdown",
          "secretKey"
        ],
        "title": "Information needed to update the page content"
      },
      "INotion.ICreateDatabaseOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "Database id"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "Database title"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Database page url"
          }
        },
        "required": [
          "id",
          "title",
          "url"
        ],
        "title": "Information created a notion database"
      },
      "INotion.ICreateDatabaseInput": {
        "type": "object",
        "properties": {
          "parentPageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "parentPageId"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "Database Title"
          },
          "properties": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/INotion.IDatabaseSchema"
            },
            "description": "Database Properties Schema"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "parentPageId",
          "title",
          "properties",
          "secretKey"
        ],
        "title": "Information needed to create a notion database"
      },
      "INotion.IDatabaseSchema": {
        "type": "object",
        "properties": {},
        "required": [],
        "title": "Database Schema",
        "additionalProperties": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/INotion.IRichTextProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.ITitleProperty"
            }
          ]
        }
      },
      "INotion.IRichTextProperty": {
        "type": "object",
        "properties": {
          "rich_text": {
            "type": "object",
            "properties": {},
            "required": []
          }
        },
        "required": [
          "rich_text"
        ],
        "title": "Notion Database rich_text property",
        "description": "This property is used when adding a text property to the database.\nThe text property can only accept text.\nThis is a property for creating items that should be expressed as text.\nFor example, when creating an English vocabulary list, if you need three properties: word, meaning, and idiom, you should be able to create the meaning and idiom as rich_text properties."
      },
      "INotion.ITitleProperty": {
        "type": "object",
        "properties": {
          "title": {
            "type": "object",
            "properties": {},
            "required": []
          }
        },
        "required": [
          "title"
        ],
        "title": "Notion Database title property",
        "description": "This property is used when adding a title property to a database.\nThis property must be added when creating a database.\nIt must never be omitted.\nThe title property can only accept text.\nItems added to that property can be used as pages, and content can also be added to the pages.\nThis is a property for creating items that should be expressed as topics or titles.\nFor example, when creating an English vocabulary list, if you need three properties: word, meaning, and idiom, you should be able to create words as title properties because words can be used as topics or titles."
      },
      "INotion.IAddDatabasePropertyOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "Database id"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "Database title"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Database page url"
          }
        },
        "required": [
          "id",
          "title",
          "url"
        ],
        "title": "Information database for added property"
      },
      "INotion.IAddDatabasePropertyInput": {
        "type": "object",
        "properties": {
          "databaseId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/notion/get/database-info",
              "jmesPath": "[].{value:id, label:title}"
            },
            "title": "databaseId",
            "description": "Database Id what you want to delete property."
          },
          "property": {
            "$ref": "#/components/schemas/INotion.IDatabaseSchema",
            "title": "property",
            "description": "Database Properties Schema what want to add"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "databaseId",
          "property",
          "secretKey"
        ],
        "title": "Information needed to add a property to the database"
      },
      "INotion.IDeleteDatabasePropertyOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "Database id"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "Database title"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Database page url"
          }
        },
        "required": [
          "id",
          "title",
          "url"
        ],
        "title": "Information database for deleted property"
      },
      "INotion.IDeleteDatabasePropertyInput": {
        "type": "object",
        "properties": {
          "databaseId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/notion/get/database-info",
              "jmesPath": "[].{value:id, label:title}"
            },
            "title": "databaseId",
            "description": "Database Id what you want to delete property."
          },
          "propertyName": {
            "type": "string",
            "title": "propertyName",
            "description": "The name of the property want to delete"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "databaseId",
          "propertyName",
          "secretKey"
        ],
        "title": "Information needed to delete a property to the database"
      },
      "INotion.IAddItemsToDatabaseOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "Database id"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "Database title"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Database page url"
          }
        },
        "required": [
          "id",
          "title",
          "url"
        ],
        "title": "Information database for added items"
      },
      "INotion.IAddItemsToDatabaseInput": {
        "type": "object",
        "properties": {
          "databaseId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/notion/get/database-info",
              "jmesPath": "[].{value:id, label:title}"
            },
            "title": "databaseId",
            "description": "Database Id what you want to add a item.\n\nIf the database is not created, you can create a database using the `Create Database` function first.\nThe endpoint is POST: /connector/notion/create-database."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/INotion.ICreateDatabaseItem"
            },
            "title": "Items to create",
            "description": "These are the item combinations to be created in the database.\nEach item combination is created for each row in the database."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "databaseId",
          "items",
          "secretKey"
        ],
        "title": "Information needed to add an items to the database"
      },
      "INotion.ICreateDatabaseItem": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "title value",
            "description": "The value to be filled in the title property."
          },
          "rich_text": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "propertyName": {
                  "type": "string"
                },
                "value": {
                  "type": "string"
                }
              },
              "required": [
                "propertyName",
                "value"
              ]
            },
            "title": "rich_text value",
            "description": "The values to be filled in the rich_text property."
          },
          "date": {
            "type": "string",
            "format": "date-time",
            "title": "date value",
            "description": "The value to be filled in the date property.\nYou must specify the date-time at the time the input was filled in."
          },
          "markdown": {
            "type": "string",
            "title": "page content",
            "description": "If you add a markdown string, it will be converted appropriately according to the Notion's block.\nTherefore, you don't have to use Unicode symbols to implement lists or decorate documents using letters.\nOf course, this depends on the user, and there is no problem using the character string you want, such as inserting an emoji as well as Unicode.\nThis Markdown string is used to add content to the page of each database row."
          }
        },
        "required": [
          "title",
          "rich_text",
          "date"
        ],
        "title": "Information about the item added to the database",
        "description": "This combination of items is used to populate a row in the database.\nFor example, if the properties of the database are title, rich_text, rich_text, rich_text, date, The combination of items requires 1 title, 3 rich_texts, and 1 date."
      },
      "IGoogleHotel.IResponse": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Accommodation Name",
            "description": "Accommodation Name"
          },
          "description": {
            "type": "string",
            "title": "Property Description",
            "description": "Property Description"
          },
          "link": {
            "type": "string",
            "title": "Accommodation Link",
            "description": "Accommodation Link"
          },
          "check_in_time": {
            "type": "string",
            "title": "Check-in time",
            "description": "Accommodation check-in time"
          },
          "check_out_time": {
            "type": "string",
            "title": "Check-out Time",
            "description": "Accommodation Check-out Time"
          },
          "price": {
            "type": "string",
            "title": "Accommodation prices",
            "description": "Accommodation prices"
          },
          "nearby_place": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleHotel.INearbyPlace"
            },
            "title": "Facilities around the property",
            "description": "Facilities around the property"
          },
          "hotel_class": {
            "type": "string",
            "title": "Accommodation rating",
            "description": "Accommodation rating"
          },
          "thumbnails": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iri",
              "contentMediaType": "image/*"
            },
            "title": "thumbnail",
            "description": "Accommodation thumbnail image"
          },
          "rating": {
            "type": "string",
            "title": "rating",
            "description": "Accommodation rating"
          },
          "review_count": {
            "type": "string",
            "title": "Number of reviews",
            "description": "Number of reviews"
          },
          "amenities": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "Amenities",
            "description": "Amenities provided by the property"
          },
          "excluded_amenities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Amenities not provided",
            "description": "Amenities not provided by the property"
          }
        },
        "required": [
          "name",
          "price",
          "thumbnails",
          "amenities"
        ],
        "title": "Accommodation search results"
      },
      "IGoogleHotel.INearbyPlace": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Surrounding facility name",
            "description": "Surrounding facility name"
          },
          "transportations": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "title": "Types of Transportation",
                  "description": "Types of Transportation"
                },
                "duration": {
                  "type": "string",
                  "title": "Time required",
                  "description": "Time required to reach surrounding facilities"
                }
              },
              "required": [
                "type",
                "duration"
              ]
            },
            "title": "Transportation",
            "description": "Transportation to nearby facilities"
          }
        },
        "required": [
          "name"
        ],
        "title": "Surrounding facilities"
      },
      "IGoogleHotel.IRequest": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "title": "Search term",
            "description": "Enter the keyword you want to search for."
          },
          "check_in_date": {
            "type": "string",
            "format": "date",
            "title": "Check-in date",
            "description": "Set your check-in date.\n\nPlease enter a date after today's date."
          },
          "check_out_date": {
            "type": "string",
            "format": "date",
            "title": "Checkout Date",
            "description": "Set a checkout date.\n\nPlease enter a date after today's date."
          },
          "adults": {
            "type": "integer",
            "default": 2,
            "title": "Number of adults",
            "description": "Set the number of adults staying. The default is 2."
          },
          "children": {
            "type": "integer",
            "default": 0,
            "title": "Number of children",
            "description": "Set the number of children staying. The default is 0."
          },
          "sort_by": {
            "oneOf": [
              {
                "const": "3"
              },
              {
                "const": "8"
              },
              {
                "const": "13"
              }
            ],
            "title": "Sort criteria",
            "description": "Please select the desired sort criteria.\n\nOnly 3, 8, and 13 are possible values."
          },
          "min_price": {
            "type": "integer",
            "title": "Minimum price",
            "description": "Please set the minimum price for the price range."
          },
          "max_price": {
            "type": "integer",
            "title": "Maximum price",
            "description": "Please set the maximum price for the price range."
          },
          "rating": {
            "oneOf": [
              {
                "const": "7"
              },
              {
                "const": "8"
              },
              {
                "const": "9"
              }
            ],
            "title": "Rating",
            "description": "Search only properties with a selected rating or higher.\n\nOnly possible values are 7, 8, and 9."
          },
          "type": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "12"
                },
                {
                  "const": "13"
                },
                {
                  "const": "14"
                },
                {
                  "const": "15"
                },
                {
                  "const": "16"
                },
                {
                  "const": "17"
                },
                {
                  "const": "18"
                },
                {
                  "const": "19"
                },
                {
                  "const": "20"
                },
                {
                  "const": "21"
                },
                {
                  "const": "22"
                },
                {
                  "const": "23"
                },
                {
                  "const": "24"
                }
              ]
            },
            "title": "Accommodation type",
            "description": "Please select the accommodation type.\n\nOnly 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 are possible values."
          },
          "hotel_class": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "1"
                },
                {
                  "const": "2"
                },
                {
                  "const": "3"
                },
                {
                  "const": "4"
                },
                {
                  "const": "5"
                }
              ]
            },
            "title": "Accommodation class",
            "description": "Please select your accommodation class.'\n\nOnly 1, 2, 3, 4, 5 are possible values."
          },
          "free_cancellation": {
            "type": "boolean",
            "title": "Is free cancellation possible?",
            "description": "Search only properties with free cancellation."
          },
          "max_results": {
            "type": "integer",
            "title": "Number of search results",
            "description": "Set the number of search results."
          }
        },
        "required": [
          "keyword",
          "check_in_date",
          "check_out_date",
          "max_results"
        ],
        "title": "Accommodation search criteria"
      },
      "IAirportInformation.IResponse": {
        "type": "object",
        "properties": {
          "country_name": {
            "type": "string",
            "title": "Country",
            "description": "Country Name"
          },
          "city_name": {
            "type": "string",
            "title": "City",
            "description": "City Name"
          },
          "airport_name": {
            "type": "string",
            "title": "Airport",
            "description": "Airport Name"
          },
          "airport_code": {
            "type": "string",
            "title": "Airport Code",
            "description": "Airport Code"
          }
        },
        "required": [
          "country_name",
          "city_name",
          "airport_name",
          "airport_code"
        ],
        "title": "Airport information search results"
      },
      "IAirportInformation.IRequest": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "title": "Search term",
            "description": "Enter the name of the country or city you want to search for."
          }
        },
        "required": [
          "keyword"
        ],
        "title": "Airport information search conditions"
      },
      "IGoogleFlight.IFinalResponse": {
        "type": "object",
        "properties": {
          "flight": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleFlight.ISearchOutput"
            },
            "title": "Final selected flight information",
            "description": "Here is the final selected flight information."
          },
          "booking_options": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleFlight.IBookingOption"
            },
            "title": "Reservation Information",
            "description": "Here is the information you need to book your chosen flight."
          }
        },
        "required": [
          "flight",
          "booking_options"
        ],
        "title": "Final flight selection results",
        "description": "Here are the final flight selection results."
      },
      "IGoogleFlight.ISearchOutput": {
        "type": "object",
        "properties": {
          "flight": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleFlight.IFlight"
            },
            "title": "Flight Information",
            "description": "Here is the flight information."
          },
          "total_duration": {
            "type": "string",
            "title": "Total flight time",
            "description": "Total flight time."
          },
          "price": {
            "type": "string",
            "title": "Flight prices",
            "description": "Flight prices."
          },
          "layover": {
            "$ref": "#/components/schemas/IGoogleFlight.ILayover",
            "title": "Transfer Information",
            "description": "Here is the flight transfer information."
          },
          "departure_token": {
            "type": "string",
            "title": "Return flight search token",
            "description": "Token for return flight search"
          },
          "booking_token": {
            "type": "string",
            "title": "Final confirmation token for flight",
            "description": "Token for final confirmation of flight"
          }
        },
        "required": [
          "flight",
          "total_duration",
          "price"
        ],
        "title": "Flight search results",
        "description": "Here are the flight search results."
      },
      "IGoogleFlight.IFlight": {
        "type": "object",
        "properties": {
          "departure_airport": {
            "$ref": "#/components/schemas/IGoogleFlight.IAirport",
            "title": "Departure Information",
            "description": "Here is the flight departure information."
          },
          "arrival_airport": {
            "$ref": "#/components/schemas/IGoogleFlight.IAirport",
            "title": "Arrival Information",
            "description": "Here is the flight arrival information."
          },
          "duration": {
            "type": "string",
            "title": "Flight time",
            "description": "This is the time it takes to fly."
          },
          "airplane": {
            "type": "string",
            "title": "Airplane type",
            "description": "Here is the aircraft type information."
          },
          "airline": {
            "type": "string",
            "title": "Airline",
            "description": "Here is the airline information."
          },
          "airline_logo": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "image/*",
            "title": "Airline Logo",
            "description": "This is an image of an airline logo."
          },
          "travel_class": {
            "type": "string",
            "title": "Seat Class",
            "description": "Here is the seat class information."
          },
          "flight_number": {
            "type": "string",
            "title": "Flight number",
            "description": "Flight number is."
          }
        },
        "required": [
          "departure_airport",
          "arrival_airport",
          "duration",
          "airplane",
          "airline",
          "airline_logo",
          "travel_class",
          "flight_number"
        ]
      },
      "IGoogleFlight.IAirport": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Airport name",
            "description": "Airport name."
          },
          "code": {
            "type": "string",
            "title": "Airport Code",
            "description": "This is a three-digit airport code."
          },
          "time": {
            "type": "string",
            "title": "Flight Departure Date / Time",
            "description": "The date and time of the flight departure."
          }
        },
        "required": [
          "name",
          "code",
          "time"
        ],
        "title": "Flight Information"
      },
      "IGoogleFlight.ILayover": {
        "type": "object",
        "properties": {
          "duration": {
            "type": "string",
            "title": "Transfer time",
            "description": "It's transfer time."
          },
          "name": {
            "type": "string",
            "title": "Airport name",
            "description": "Airport name."
          },
          "code": {
            "type": "string",
            "title": "Airport Code",
            "description": "This is a three-digit airport code."
          }
        },
        "required": [
          "duration",
          "name",
          "code"
        ],
        "title": "Transfer information"
      },
      "IGoogleFlight.IBookingOption": {
        "type": "object",
        "properties": {
          "book_with": {
            "type": "string",
            "title": "Reservation site",
            "description": "This is a site where you can book flights of your choice."
          },
          "price": {
            "type": "string",
            "title": "Price",
            "description": "The price of the selected flight."
          },
          "book_link": {
            "type": "string",
            "format": "uri",
            "title": "Reservation Link",
            "description": "Here is a link to book your selected flight."
          }
        },
        "required": [
          "book_with",
          "price",
          "book_link"
        ],
        "title": "Reservation options",
        "description": "Reservation options."
      },
      "IGoogleFlight.IRequest": {
        "type": "object",
        "properties": {
          "departure_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/airport-information/search",
              "jmesPath": "[].{value:airport_code, label: [country_name, city_name, airport_name, airport_code].join('-', @)}"
            },
            "title": "Departure",
            "description": "Please enter the code of the departure airport.\n\nThe departure code must be the same even if it is a round trip (type \"1\").\n\nWhen calling connector/google-flight/arrival for a round trip (type \"1\"), the departure_id must be the same as when calling connector/google-flight/departure."
          },
          "arrival_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/airport-information/search",
              "jmesPath": "[].{value:airport_code, label: [country_name, city_name, airport_name, airport_code].join('-', @)}"
            },
            "title": "Destination",
            "description": "Please enter the destination airport code.\n\nEven if it is a round trip (type \"1\"), the destination code must be the same.\n\nWhen calling connector/google-flight/arrival for a round trip (type \"1\"), the arrival_id must be the same as when calling connector/google-flight/departure."
          },
          "type": {
            "oneOf": [
              {
                "const": "1"
              },
              {
                "const": "2"
              }
            ],
            "title": "Round trip or one way",
            "description": "Please select whether it is round trip or one way.\n\nPossible values are 1 and 2.\n\nPlease select \"1\" for round trip and \"2\" for one way."
          },
          "outbound_date": {
            "type": "string",
            "format": "date",
            "title": "Departure date",
            "description": "Please enter your departure date.\n\nPlease enter a date after today's date."
          },
          "return_date": {
            "type": "string",
            "format": "date",
            "title": "Date of arrival",
            "description": "Please enter the date of arrival.\n\nIf type is \"1\", it must be entered.\n\nIf type is \"2\", it must not be entered.\n\nPlease enter a date after today's date."
          },
          "adults": {
            "type": "integer",
            "title": "Number of adults",
            "description": "Please enter the number of adults."
          },
          "children": {
            "type": "integer",
            "title": "Number of children",
            "description": "Please enter the number of children."
          },
          "stop": {
            "oneOf": [
              {
                "const": "0"
              },
              {
                "const": "1"
              },
              {
                "const": "2"
              },
              {
                "const": "3"
              }
            ],
            "title": "Whether it is a direct flight",
            "description": "Please select whether it is a direct flight.\n\nPossible values are 0, 1, 2, 3."
          },
          "max_price": {
            "type": "integer",
            "title": "Maximum Price",
            "description": "Please enter the maximum price for your flight.\n\nYou must search for flights that do not exceed the maximum price you entered."
          }
        },
        "required": [
          "departure_id",
          "arrival_id",
          "type",
          "outbound_date",
          "adults",
          "stop"
        ],
        "title": "Information needed to search for airline tickets"
      },
      "ISlack.IHoldVoteOutput": {
        "type": "object",
        "properties": {
          "blocks": {
            "type": "array",
            "items": {},
            "title": "title blocks"
          },
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp",
            "description": "for example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          }
        },
        "required": [
          "ts"
        ]
      },
      "ISlack.IHoldVoteInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id"
          },
          "title": {
            "type": "string",
            "title": "Title of vote to be held\n\nIt should be written as a simple one-line markdown and can include Slack emojis."
          },
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "title": "option title"
                },
                "link": {
                  "type": "string",
                  "title": "option's link"
                }
              },
              "required": [
                "text"
              ]
            },
            "title": "options available for voting\n\nIt refers to the options available for voting."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "channel",
          "title",
          "items",
          "secretKey"
        ]
      },
      "ISlack.IMarkInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id",
            "description": "It refers to the channel on which you want to mark the conversation history.\nIf you don't know the channel's ID, You need to view the channel first."
          },
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-channel-histories",
              "jmesPath": "messages[].{value: ts, label: text}"
            },
            "title": "ts",
            "description": "It means the 'ts' value of the chat you want to mark"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "channel",
          "ts",
          "secretKey"
        ]
      },
      "MyPickISlack.ScheduledMessagepost_at": {
        "type": "object",
        "properties": {
          "post_at": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp",
            "description": "for example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          }
        },
        "required": [
          "post_at"
        ]
      },
      "ISlack.ISCheduleMessageInput": {
        "type": "object",
        "properties": {
          "post_at": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "Transfer Schedule Time",
            "description": "You can schedule the time you want to send the message in advance.\nThe scheduled time must be in the same form as the ts property in the Message."
          },
          "thread_ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "thread ts\n\nIf the message you want to schedule is within a specific thread, you must pass the ts value of the parent message."
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-users",
                  "jmesPath": "users[].{ value: im_channel_id, label: display_name }"
                }
              }
            ],
            "title": "channel id",
            "description": "It refers to the channel on which you want to view the conversation history.\nIf you don't know the channel's ID, You need to view the channel first.\nWhen sending a message to a DM channel, you need the channel's ID, not the user's ID.\nThe user's ID starts with 'U', but if it's a DM channel, it's more likely to start with 'D'."
          },
          "text": {
            "type": "string",
            "title": "message to send",
            "description": "When a user enters a markdown format string, the internal function modifies it to the format of the slack.\nUsers can put text in accordance with the usual markdown grammar.\nFor user readability, it is recommended that the string be sent with appropriate new-line characters."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "post_at",
          "channel",
          "text",
          "secretKey"
        ]
      },
      "ISlack.IDeleteSCheduleMessageInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id",
            "description": "It refers to the channel on which you want to delete the scheduled message.\nIf you don't know the channel's ID, You need to view the channel first."
          },
          "scheduled_message_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-scheduled-messages",
              "jmesPath": "scheduled_messages[].{value:id, label:text}"
            },
            "title": "scheduled message id to delete"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "channel",
          "scheduled_message_id",
          "secretKey"
        ]
      },
      "MyPickISlack.Messagets": {
        "type": "object",
        "properties": {
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp",
            "description": "for example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          }
        },
        "required": [
          "ts"
        ]
      },
      "ISlack.IPostMessageToMyselfInput": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "message to send"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "text",
          "secretKey"
        ]
      },
      "ISlack.IPostMessageReplyInput": {
        "type": "object",
        "properties": {
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-channel-histories",
              "jmesPath": "messages[].{value: ts, label: text}"
            },
            "title": "ts",
            "description": "It means the 'ts' value of the chat you want to reply"
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-users",
                  "jmesPath": "users[].{ value: im_channel_id, label: display_name }"
                }
              }
            ],
            "title": "channel id",
            "description": "It refers to the channel on which you want to view the conversation history.\nIf you don't know the channel's ID, You need to view the channel first.\nWhen sending a message to a DM channel, you need the channel's ID, not the user's ID.\nThe user's ID starts with 'U', but if it's a DM channel, it's more likely to start with 'D'."
          },
          "text": {
            "type": "string",
            "title": "message to send",
            "description": "When a user enters a markdown format string, the internal function modifies it to the format of the slack.\nUsers can put text in accordance with the usual markdown grammar.\nFor user readability, it is recommended that the string be sent with appropriate new-line characters."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "ts",
          "channel",
          "text",
          "secretKey"
        ]
      },
      "ISlack.IPostMessageInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-users",
                  "jmesPath": "users[].{ value: im_channel_id, label: display_name }"
                }
              }
            ],
            "title": "channel id",
            "description": "It refers to the channel on which you want to view the conversation history.\nIf you don't know the channel's ID, You need to view the channel first.\nWhen sending a message to a DM channel, you need the channel's ID, not the user's ID.\nThe user's ID starts with 'U', but if it's a DM channel, it's more likely to start with 'D'."
          },
          "text": {
            "type": "string",
            "title": "message to send",
            "description": "When a user enters a markdown format string, the internal function modifies it to the format of the slack.\nUsers can put text in accordance with the usual markdown grammar.\nFor user readability, it is recommended that the string be sent with appropriate new-line characters."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "channel",
          "text",
          "secretKey"
        ]
      },
      "ISlack.IUpdateMessageOutput": {
        "type": "object",
        "properties": {
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp",
            "description": "for example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          }
        },
        "required": [
          "ts"
        ]
      },
      "ISlack.IUpdateMessageInput": {
        "type": "object",
        "properties": {
          "thread_ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "thread ts to update"
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-users",
                  "jmesPath": "users[].{ value: im_channel_id, label: display_name }"
                }
              }
            ],
            "title": "channel id",
            "description": "It refers to the channel on which you want to view the conversation history.\nIf you don't know the channel's ID, You need to view the channel first.\nWhen sending a message to a DM channel, you need the channel's ID, not the user's ID.\nThe user's ID starts with 'U', but if it's a DM channel, it's more likely to start with 'D'."
          },
          "text": {
            "type": "string",
            "title": "message to send",
            "description": "When a user enters a markdown format string, the internal function modifies it to the format of the slack.\nUsers can put text in accordance with the usual markdown grammar.\nFor user readability, it is recommended that the string be sent with appropriate new-line characters."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "thread_ts",
          "channel",
          "text",
          "secretKey"
        ]
      },
      "ISlack.IGetScheduledMessageListOutput": {
        "type": "object",
        "properties": {
          "scheduled_messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScheduledMessageidstringpost_at_datestring"
            },
            "title": "scheduled messages"
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor",
            "description": "Cursor for pagination\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`.\nIf this property is not null, It was not over to find data."
          }
        },
        "required": [
          "scheduled_messages",
          "next_cursor"
        ]
      },
      "ScheduledMessageidstringpost_at_datestring": {
        "type": "object",
        "properties": {
          "post_at": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp",
            "description": "for example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          },
          "date_created": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "when the user scheduled the message"
          },
          "text": {
            "type": "string",
            "title": "message contents",
            "description": "When users occasionally call others, they can be called in the form of '@USERNAME', which is called a tag.\nIn the conversation history, the link and code box are abbreviated to <LINK/> and <CODE/>, respectively.\nFor users, it is replaced by a user name, Like <@USERNAME>.\n<@USERNAME> is about calling someone else, and it's not the name of the person who started the conversation, so be careful.\nif you want to find who started this conversation, check 'user' property."
          },
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.Attachmenttitleid"
            },
            "title": "Attachments",
            "description": "Attachement contains all types of files and can sometimes be an external link.\nIt is not the type that can be confirmed because the internal properties can vary depending on the type of block it is making up."
          },
          "channel": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id"
          },
          "id": {
            "type": "string",
            "title": "id of scheduled message"
          },
          "post_at_date": {
            "type": "string",
            "title": "date-time format of post_at"
          }
        },
        "required": [
          "post_at",
          "date_created",
          "text",
          "channel",
          "id",
          "post_at_date"
        ]
      },
      "MyPickISlack.Attachmenttitleid": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "title\n\nLarge title text near the top of the attachment."
          },
          "id": {
            "type": "number",
            "title": "id"
          }
        },
        "required": []
      },
      "ISlack.IGetScheduledMessageListInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit",
            "description": "Indicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details,\nit is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          },
          "cursor": {
            "type": "string",
            "title": "cursor",
            "description": "If you pass the next_cursor or cursor value received from the previous inquiry, you can get additional data from the data.\nIf the next_cursor is not null, you can retrieve additional data.\nIf you don't put a value, it will be recognized as the first page.\nThis should never be null. If you don't have a value, don't forward properties."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ISlack.IGetUserDetailOutput": {
        "type": "object",
        "properties": {
          "fields": {
            "$ref": "#/components/schemas/Recordstringstring",
            "title": "custom fields"
          },
          "id": {
            "type": "string",
            "title": "User ID",
            "description": "Indicates the ID of the user.\nThis is different from the ID of the DM channel, or IM Channel.\nDM is a communication channel with people in that channel,\nand even if it is 1:1 the user has multiple DM channels,\nso it is not possible to say that the user's ID is a DM channel."
          },
          "im_channel_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "im_channel_id",
            "description": "If a user wants to send a DM message to another user,\nthey need to find a channel in im channels that matches their username.\nAnd call the message sending connector.\nHowever, since the purpose of looking up a user is usually to get information about the user or to send a message to the user,\nthis specification is extended to provide the DM channel (= IM channel) ID of the two users in this property when looking up a user.\nIf this value is 'null', then the user's im_channel_id was not found."
          },
          "display_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "display name",
            "description": "The user has a separate display name.\nA display name is a name that the user has chosen to show.\nTherefore, it would be best to use this name as a courtesy."
          },
          "real_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "real_name",
            "description": "The user's first and last name.\nUpdating this field will update first_name and last_name.\nIf only one name is provided, the value of last_name will be cleared."
          },
          "status_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "status"
          }
        },
        "required": [
          "fields",
          "id",
          "im_channel_id",
          "display_name",
          "real_name"
        ],
        "title": "profile",
        "description": "User information will usually include user's directories, start date, email, phone number, and status information.\nThe start date usually records when this member joined Slack or when he joined the team, but all the information here is written by the individual user and not by the HR person."
      },
      "Recordstringstring": {
        "type": "object",
        "properties": {},
        "required": [],
        "description": "Construct a type with a set of properties K of type T",
        "additionalProperties": {
          "type": "string"
        }
      },
      "ISlack.IGetUserDetailInput": {
        "type": "object",
        "properties": {
          "userIds": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/slack/get-users",
                "jmesPath": "users[].{value: id, label: display_name}"
              }
            },
            "minItems": 1,
            "title": "userIds\n\nYou can enter the ID value of the user who wants to look up the details."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "userIds",
          "secretKey"
        ]
      },
      "ISlack.IGetUserListOutput": {
        "type": "object",
        "properties": {
          "users": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitISlack.IGetUserOutputfields"
            },
            "title": "user list"
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor",
            "description": "Cursor for pagination\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`.\nIf this property is not null, It was not over to find data."
          }
        },
        "required": [
          "users",
          "next_cursor"
        ]
      },
      "StrictOmitISlack.IGetUserOutputfields": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name",
            "description": "This is the name of the user,\nbut in some countries,\nit may not be possible to call the user's name carelessly,\nand the company should refrain from using it because the position exists."
          },
          "id": {
            "type": "string",
            "title": "User ID",
            "description": "Indicates the ID of the user.\nThis is different from the ID of the DM channel, or IM Channel.\nDM is a communication channel with people in that channel,\nand even if it is 1:1 the user has multiple DM channels,\nso it is not possible to say that the user's ID is a DM channel."
          },
          "profile_image": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri",
                "contentMediaType": "image/*"
              }
            ],
            "title": "profile image",
            "description": "There are several profile images for each image quality,\nbut here we provide them based on the first image uploaded by the user."
          },
          "slack_team_id": {
            "type": "string",
            "title": "slack_team_id"
          },
          "im_channel_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "im_channel_id",
            "description": "If a user wants to send a DM message to another user,\nthey need to find a channel in im channels that matches their username.\nAnd call the message sending connector.\nHowever, since the purpose of looking up a user is usually to get information about the user or to send a message to the user,\nthis specification is extended to provide the DM channel (= IM channel) ID of the two users in this property when looking up a user.\nIf this value is 'null', then the user's im_channel_id was not found."
          },
          "display_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "display name",
            "description": "The user has a separate display name.\nA display name is a name that the user has chosen to show.\nTherefore, it would be best to use this name as a courtesy."
          },
          "real_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "real_name",
            "description": "The user's first and last name.\nUpdating this field will update first_name and last_name.\nIf only one name is provided, the value of last_name will be cleared."
          },
          "deleted": {
            "type": "boolean",
            "title": "deleted",
            "description": "This value is used to distinguish between deleted users."
          },
          "status_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "status"
          }
        },
        "required": [
          "name",
          "id",
          "profile_image",
          "slack_team_id",
          "im_channel_id",
          "display_name",
          "real_name",
          "deleted"
        ]
      },
      "ISlack.IGetUserListInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit",
            "description": "Indicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details,\nit is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          },
          "cursor": {
            "type": "string",
            "title": "cursor",
            "description": "If you pass the next_cursor or cursor value received from the previous inquiry, you can get additional data from the data.\nIf the next_cursor is not null, you can retrieve additional data.\nIf you don't put a value, it will be recognized as the first page.\nThis should never be null. If you don't have a value, don't forward properties."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ISlack.IGetReplyOutput": {
        "type": "object",
        "properties": {
          "replies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISlack.ChannelHistory"
            },
            "title": "replies",
            "description": "This value refers to replies that depend on the currently viewed thread."
          },
          "members": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.IGetUserOutputidim_channel_iddisplay_name"
            },
            "title": "members",
            "description": "This is a list of people who participated in the conversation in this conversation list."
          },
          "usergroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISlack.UserGroup"
            },
            "title": "usergroups"
          },
          "channel": {
            "type": "object",
            "properties": {
              "name": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "Channel Name",
                "description": "The channel name is the name of the channel for 'public' and 'private',\nand the name of the user for 'im'.\nIf the channel's name is not found, it is marked null."
              }
            },
            "required": [],
            "title": "Channel information"
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor",
            "description": "Cursor for pagination\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`.\nIf this property is not null, It was not over to find data."
          }
        },
        "required": [
          "replies",
          "members",
          "usergroups",
          "channel",
          "next_cursor"
        ]
      },
      "ISlack.ChannelHistory": {
        "type": "object",
        "properties": {
          "username": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "username of the person who made this message"
          },
          "user_profile": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "user profile image"
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "shortcut link",
            "description": "Link to view the conversation history immediately.\nWe can provide you with a shortcut link if user want, but you don't have to expose it to them in normal times."
          },
          "text": {
            "type": "string",
            "title": "message contents",
            "description": "When users occasionally call others, they can be called in the form of '@USERNAME', which is called a tag.\nIn the conversation history, the link and code box are abbreviated to <LINK/> and <CODE/>, respectively.\nFor users, it is replaced by a user name, Like <@USERNAME>.\n<@USERNAME> is about calling someone else, and it's not the name of the person who started the conversation, so be careful.\nif you want to find who started this conversation, check 'user' property."
          },
          "user": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "ID of the person who made this message\n\nIf not a user, message does not have an ID."
          },
          "channel": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id"
          },
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp",
            "description": "for example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          },
          "reply_count": {
            "type": "number",
            "title": "reply_count",
            "description": "Indicates the number of replies on this thread.\nIf there are many replies, active discussions are underway."
          },
          "reply_users_count": {
            "type": "number",
            "title": "reply_users_count",
            "description": "This means the person who has one or more Replys in this thread.\nThe number of unique people discussing in the thread."
          },
          "ts_date": {
            "type": "string",
            "title": "date format of `ts`\n\nThis is the value changed to ISO String to make it easier to recognize the current time value by separating 'ts'."
          },
          "links": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iri"
            },
            "title": "links\n\nLinks from the chat"
          }
        },
        "required": [
          "username",
          "user_profile",
          "link",
          "text",
          "user",
          "channel",
          "ts",
          "reply_count",
          "reply_users_count",
          "ts_date",
          "links"
        ]
      },
      "MyPickISlack.IGetUserOutputidim_channel_iddisplay_name": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "User ID",
            "description": "Indicates the ID of the user.\nThis is different from the ID of the DM channel, or IM Channel.\nDM is a communication channel with people in that channel,\nand even if it is 1:1 the user has multiple DM channels,\nso it is not possible to say that the user's ID is a DM channel."
          },
          "im_channel_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "im_channel_id",
            "description": "If a user wants to send a DM message to another user,\nthey need to find a channel in im channels that matches their username.\nAnd call the message sending connector.\nHowever, since the purpose of looking up a user is usually to get information about the user or to send a message to the user,\nthis specification is extended to provide the DM channel (= IM channel) ID of the two users in this property when looking up a user.\nIf this value is 'null', then the user's im_channel_id was not found."
          },
          "display_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "display name",
            "description": "The user has a separate display name.\nA display name is a name that the user has chosen to show.\nTherefore, it would be best to use this name as a courtesy."
          }
        },
        "required": [
          "id",
          "im_channel_id",
          "display_name"
        ]
      },
      "ISlack.UserGroup": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "ID",
            "description": "The ID of the user group."
          },
          "team_id": {
            "type": "string",
            "title": "Team ID",
            "description": "The ID of the team."
          },
          "is_usergroup": {
            "type": "boolean",
            "title": "Is User Group",
            "description": "Indicates if the object is a user group."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Friendly name of the group."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Purpose of the group (optional)."
          },
          "handle": {
            "type": "string",
            "title": "Handle",
            "description": "Value used to notify group members via a mention without a leading @ sign."
          },
          "is_external": {
            "type": "boolean",
            "title": "Is External",
            "description": "Indicates if the user group is external."
          },
          "date_create": {
            "type": "number",
            "title": "Date Created",
            "description": "Unix timestamp of when the group was created."
          },
          "date_update": {
            "type": "number",
            "title": "Date Updated",
            "description": "Unix timestamp of when the group was last updated."
          },
          "date_delete": {
            "type": "number",
            "title": "Date Deleted",
            "description": "Non-zero value for disabled groups."
          },
          "auto_type": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "admins"
              },
              {
                "const": "owners"
              }
            ],
            "title": "Auto Type",
            "description": "Can be 'admins', 'owners', or null for custom groups."
          },
          "created_by": {
            "type": "string",
            "title": "Created By",
            "description": "User ID of the member who created the group."
          },
          "updated_by": {
            "type": "string",
            "title": "Updated By",
            "description": "User ID of the member who updated the group."
          },
          "deleted_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Deleted By",
            "description": "User ID of the member who deleted the group."
          },
          "prefs": {
            "type": "object",
            "properties": {
              "channels": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "Channels",
                "description": "Default channels members will be invited to upon joining."
              },
              "groups": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "Groups",
                "description": "Default private channels members will be invited to upon joining."
              }
            },
            "required": [
              "channels",
              "groups"
            ],
            "title": "Preferences",
            "description": "Contains default channels and groups (private channels) that members of this group will be invited to upon joining."
          },
          "users": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Users",
            "description": "List of user object IDs belonging to the group (optional).\n\nIf you want to look up a particular user, you can find out if this property has that user ID.\nIf you want to see the user's nickname or name that corresponds to the user's ID, refer to the User Inquiry connector."
          },
          "user_count": {
            "type": "number",
            "title": "User Count",
            "description": "Total number of users in the group."
          }
        },
        "required": [
          "id",
          "team_id",
          "is_usergroup",
          "name",
          "handle",
          "is_external",
          "date_create",
          "date_update",
          "date_delete",
          "auto_type",
          "created_by",
          "updated_by",
          "deleted_by",
          "prefs",
          "user_count"
        ],
        "title": "UserGroup",
        "description": "Represents a user group with various properties like ID, name, and user details."
      },
      "ISlack.IGetReplyInput": {
        "type": "object",
        "properties": {
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-channel-histories",
              "jmesPath": "messages[].{value: ts, label: text}"
            },
            "title": "ts",
            "description": "It means the 'ts' value of the chat you want to look up."
          },
          "channel_type": {
            "oneOf": [
              {
                "const": "private"
              },
              {
                "const": "public"
              },
              {
                "const": "im"
              }
            ],
            "title": "Channel Type",
            "description": "If you know that the channel\nyou want to read the message is public, private, or im,\nmake sure to include it."
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id",
            "description": "It refers to the channel on which you want to view the conversation history.\nYou need to view the channel first.\nThis is a string that always begins with a capital letter 'C' or 'D'."
          },
          "latestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "latestDateTime",
            "description": "Only messages before this date-time will be included in results. Default is the current time.\nIt is a value that takes precedence over 'latest', 'latestTimestamp'."
          },
          "oldestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "oldestDateTime",
            "description": "Only messages after this date-time will be included in results.\nIt is a value that takes precedence over 'oldest', 'oldestTimestamp'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit",
            "description": "Indicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details,\nit is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          },
          "cursor": {
            "type": "string",
            "title": "cursor",
            "description": "If you pass the next_cursor or cursor value received from the previous inquiry, you can get additional data from the data.\nIf the next_cursor is not null, you can retrieve additional data.\nIf you don't put a value, it will be recognized as the first page.\nThis should never be null. If you don't have a value, don't forward properties."
          }
        },
        "required": [
          "ts",
          "channel",
          "secretKey"
        ]
      },
      "ISlack.IGetChannelLinkHistoryOutput": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISlack.ChannelHistory"
            },
            "title": "message",
            "description": "This refers to the history of conversations made on the channel.\nThe closer you are to the 0th in the array, the more recent it is.\nHowever, Slack's message can be modified, so just because it is the 0th, it may not be the last writing/modified."
          },
          "members": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.IGetUserOutputidim_channel_iddisplay_name"
            },
            "title": "members\n\nThis is a list of people who participated in the conversation in this conversation list."
          },
          "usergroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISlack.UserGroup"
            },
            "title": "usergroups"
          },
          "channel": {
            "type": "object",
            "properties": {
              "name": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "Channel Name",
                "description": "The channel name is the name of the channel for 'public' and 'private',\nand the name of the user for 'im'.\nIf the channel's name is not found, it is marked null."
              }
            },
            "required": [],
            "title": "Channel information"
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor",
            "description": "Cursor for pagination\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`.\nIf this property is not null, It was not over to find data."
          }
        },
        "required": [
          "messages",
          "members",
          "usergroups",
          "channel",
          "next_cursor"
        ]
      },
      "ISlack.IGetChannelHistoryInput": {
        "type": "object",
        "properties": {
          "channel_type": {
            "oneOf": [
              {
                "const": "private"
              },
              {
                "const": "public"
              },
              {
                "const": "im"
              }
            ],
            "title": "Channel Type",
            "description": "If you know that the channel\nyou want to read the message is public, private, or im,\nmake sure to include it."
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id",
            "description": "It refers to the channel on which you want to view the conversation history.\nYou need to view the channel first.\nThis is a string that always begins with a capital letter 'C' or 'D'."
          },
          "latestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "latestDateTime",
            "description": "Only messages before this date-time will be included in results. Default is the current time.\nIt is a value that takes precedence over 'latest', 'latestTimestamp'."
          },
          "oldestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "oldestDateTime",
            "description": "Only messages after this date-time will be included in results.\nIt is a value that takes precedence over 'oldest', 'oldestTimestamp'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit",
            "description": "Indicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details,\nit is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          },
          "cursor": {
            "type": "string",
            "title": "cursor",
            "description": "If you pass the next_cursor or cursor value received from the previous inquiry, you can get additional data from the data.\nIf the next_cursor is not null, you can retrieve additional data.\nIf you don't put a value, it will be recognized as the first page.\nThis should never be null. If you don't have a value, don't forward properties."
          }
        },
        "required": [
          "channel",
          "secretKey"
        ]
      },
      "ISlack.IGetChannelHistoryOutput": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISlack.ChannelHistory"
            },
            "title": "message",
            "description": "This refers to the history of conversations made on the channel.\nThe closer you are to the 0th in the array, the more recent it is.\nHowever, Slack's message can be modified, so just because it is the 0th, it may not be the last writing/modified."
          },
          "members": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.IGetUserOutputidim_channel_iddisplay_name"
            },
            "title": "members\n\nThis is a list of people who participated in the conversation in this conversation list."
          },
          "usergroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISlack.UserGroup"
            },
            "title": "usergroups"
          },
          "channel": {
            "type": "object",
            "properties": {
              "name": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "Channel Name",
                "description": "The channel name is the name of the channel for 'public' and 'private',\nand the name of the user for 'im'.\nIf the channel's name is not found, it is marked null."
              }
            },
            "required": [],
            "title": "Channel information"
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor",
            "description": "Cursor for pagination\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`.\nIf this property is not null, It was not over to find data."
          }
        },
        "required": [
          "messages",
          "members",
          "usergroups",
          "channel",
          "next_cursor"
        ]
      },
      "ISlack.PrivateChannel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "channel name"
          },
          "id": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id",
            "description": "The channel ID starts with 'C' and 'D', and for a private DM channel, 'D'.\nBut Sometimes there are channel names that start with a G."
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "ISlack.IGetChannelInput": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "deprecated": true,
            "title": "limit"
          },
          "cursor": {
            "type": "string",
            "deprecated": true,
            "title": "cursor"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "request condition"
      },
      "ISlack.PublicChannel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "channel name"
          },
          "id": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id",
            "description": "The channel ID starts with 'C' and 'D', and for a private DM channel, 'D'.\nBut Sometimes there are channel names that start with a G."
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "ISlack.ImChannel": {
        "type": "object",
        "properties": {
          "created": {
            "type": "integer",
            "title": "created time"
          },
          "is_im": {
            "const": true,
            "title": "Is it the `im` type or not"
          },
          "is_org_shared": {
            "type": "boolean",
            "title": "is org shared"
          },
          "is_user_deleted": {
            "type": "boolean",
            "title": "is user deleted"
          },
          "priority": {
            "type": "number",
            "title": "priority"
          },
          "user": {
            "type": "string",
            "title": "channel owner's id"
          },
          "context_team_id": {
            "type": "string",
            "title": "channel owner's team id"
          },
          "username": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "username"
          },
          "id": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id",
            "description": "The channel ID starts with 'C' and 'D', and for a private DM channel, 'D'.\nBut Sometimes there are channel names that start with a G."
          }
        },
        "required": [
          "created",
          "is_im",
          "is_org_shared",
          "is_user_deleted",
          "priority",
          "user",
          "context_team_id",
          "id"
        ]
      },
      "ISlack.IGetFileOutput": {
        "type": "object",
        "properties": {
          "ok": {
            "type": "boolean"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.Filechannelsnameidusercreatedsizecomments_countmimetypeurl_privateurl_private_downloadthumb_1024"
            }
          },
          "paging": {
            "type": "object",
            "properties": {
              "count": {
                "type": "number",
                "title": "current file count"
              },
              "total": {
                "type": "number",
                "title": "total page"
              },
              "page": {
                "type": "number",
                "title": "current page"
              },
              "pages": {
                "type": "number",
                "title": "total page"
              }
            },
            "required": [
              "count",
              "total",
              "page",
              "pages"
            ]
          }
        },
        "required": [
          "ok",
          "files",
          "paging"
        ],
        "title": "File Lookup Results"
      },
      "MyPickISlack.Filechannelsnameidusercreatedsizecomments_countmimetypeurl_privateurl_private_downloadthumb_1024": {
        "type": "object",
        "properties": {
          "channels": {
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "^((C(.*))|(D(.*))|(G(.*)))"
            },
            "title": "channels"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "user": {
            "type": "string",
            "title": "user"
          },
          "created": {
            "type": "number",
            "title": "created"
          },
          "size": {
            "type": "integer",
            "title": "size"
          },
          "comments_count": {
            "type": "integer",
            "title": "comments_count"
          },
          "mimetype": {
            "type": "string",
            "title": "mimetype"
          },
          "url_private": {
            "type": "string",
            "format": "iri",
            "title": "url_private"
          },
          "url_private_download": {
            "type": "string",
            "format": "iri",
            "title": "url_private_download"
          },
          "thumb_1024": {
            "type": "string",
            "format": "iri",
            "title": "thumb_1024"
          }
        },
        "required": [
          "channels",
          "name",
          "id",
          "user",
          "created",
          "size",
          "comments_count",
          "mimetype"
        ]
      },
      "ISlack.IGetFileInput": {
        "type": "object",
        "properties": {
          "page": {
            "type": "number",
            "default": 1,
            "title": "page"
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "Channel ID to browse the file\n\nIf not specified, the entire Slack workspace will be explored."
          },
          "user": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-users",
              "jmesPath": "users[].{value: id, label: display_name}"
            },
            "title": "user id\n\nIf you only want to check files sent by a particular user, enter your ID."
          },
          "types": {
            "type": "object",
            "properties": {
              "spaces": {
                "type": "boolean",
                "title": "spaces",
                "description": "Slack's Post is a feature that allows users to write and share long forms of documents or writings.\nIt is more formatting free than regular messages and can contain code blocks or sections, which are useful for creating structured documents.\nSlack often categorizes these documented files into spaces, helping to share knowledge or information easily within the team."
              },
              "snippets": {
                "type": "boolean",
                "title": "snippets",
                "description": "Snippets are used to share short code or text snippets.\nThey are usually useful when programmers share short code blocks or snippets of log files with their teams.\nSnippets quickly uploads text or code, and allows others to refer to or copy the content. In Slack, these files are classified into a file type called snippets."
              },
              "images": {
                "type": "boolean",
                "title": "images"
              },
              "gdocs": {
                "type": "boolean",
                "title": "gdocs\n\nGoogle docs"
              },
              "zips": {
                "type": "boolean",
                "title": "zips"
              },
              "pdfs": {
                "type": "boolean",
                "title": "pdfs"
              }
            },
            "required": [],
            "title": "file types to include",
            "description": "The file types you may encounter include (but are not limited to):\nIf you want to look up all of them regardless of the file type, you can ignore the properties.\nIf the file type is important, you can specify the file type property as true inside the object."
          },
          "latestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "latestDateTime",
            "description": "Only files before this date-time will be included in results. Default is the current time.\nIt is a value that takes precedence over 'latest', 'latestTimestamp'."
          },
          "oldestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "oldestDateTime",
            "description": "Only files after this date-time will be included in results.\nIt is a value that takes precedence over 'oldest', 'oldestTimestamp'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit",
            "description": "Indicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details,\nit is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ISlack.IGetUserGroupOutput": {
        "type": "object",
        "properties": {
          "ok": {
            "type": "boolean",
            "title": "ok"
          },
          "usergroups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISlack.UserGroup"
            },
            "title": "usergroups"
          }
        },
        "required": [
          "ok",
          "usergroups"
        ]
      },
      "ISlack.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ISlack.IGetMyInfoOutput": {
        "type": "object",
        "properties": {
          "user": {
            "type": "object",
            "properties": {
              "user_id": {
                "type": "string",
                "title": "User ID",
                "description": "Request's User ID.\nThis is identifier of requester from others."
              },
              "team_id": {
                "type": "string",
                "title": "Team ID"
              },
              "team": {
                "type": "string",
                "title": "Team Name"
              },
              "name": {
                "type": "string",
                "title": "User Name",
                "description": "Requester's User Name.\nBut, This is not unique. so This can't be used as an identifier."
              }
            },
            "required": [
              "user_id",
              "team_id",
              "team",
              "name"
            ],
            "title": "user"
          }
        },
        "required": [
          "user"
        ]
      },
      "ISlack.IDeleteMessageInput": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "channel": {
                  "type": "string",
                  "title": "Channel ID"
                },
                "user_id": {
                  "type": "string",
                  "x-wrtn-prerequisite": {
                    "method": "patch",
                    "path": "connector/slack/me",
                    "jmesPath": "user.{value: id, label: name}"
                  },
                  "title": "User ID",
                  "description": "User ID the of message.\nThis property is for checking log.\nyou can use only the `user_id` of messages matched requester's `user_id`"
                },
                "ts": {
                  "type": "string",
                  "x-wrtn-placeholder": "1405894322.002768",
                  "title": "timestamp",
                  "description": "for example, `1721804246.083609`.\nThis is the time value expression method used by Slack.\nYou must put the ts of the message sent by requester not others.\nyou can use only the `ts` of messages matched requester's `user_id`"
                }
              },
              "required": [
                "channel",
                "user_id",
                "ts"
              ]
            },
            "title": "Message Info List",
            "description": "Even if the user wants to delete \"all\" or \"every\" messages, you can delete only requester's messages."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "im:history",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read",
              "usergroups:read",
              "team:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "messages",
          "secretKey"
        ]
      },
      "IJira.IDeleteCommentInput": {
        "type": "object",
        "properties": {
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key",
            "description": "This connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "commentId": {
            "type": "string",
            "title": "ID of comment to delete"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "commentId",
          "secretKey"
        ]
      },
      "IJira.IUpdateCommentByMarkdownInput": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/StrictOmittypedocversion1contentTopLevelBlockNodecontentcontentstring",
            "title": "body of comment"
          },
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key",
            "description": "This connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "commentId": {
            "type": "string",
            "title": "ID of comment to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "body",
          "issueIdOrKey",
          "commentId",
          "secretKey"
        ]
      },
      "StrictOmittypedocversion1contentTopLevelBlockNodecontentcontentstring": {
        "type": "object",
        "properties": {
          "version": {
            "const": 1,
            "title": "version"
          },
          "type": {
            "const": "doc",
            "title": "type"
          },
          "content": {
            "type": "string",
            "title": "contents of description",
            "description": "You must use markdown format string.\n\nIt is recommended to contain as much detail as possible on the issue raised by the user,\nso that the next person who reads this issue can see the summary and description of this issue to resolve the issue."
          }
        },
        "required": [
          "version",
          "type",
          "content"
        ]
      },
      "IJira.ICreateCommentOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "ID of comment"
          }
        },
        "required": [
          "id"
        ]
      },
      "IJira.ICreateCommentByMarkdownInput": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/StrictOmittypedocversion1contentTopLevelBlockNodecontentcontentstring.o1",
            "title": "body of comment"
          },
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key",
            "description": "This connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "body",
          "issueIdOrKey",
          "secretKey"
        ]
      },
      "StrictOmittypedocversion1contentTopLevelBlockNodecontentcontentstring.o1": {
        "type": "object",
        "properties": {
          "version": {
            "const": 1,
            "title": "version"
          },
          "type": {
            "const": "doc",
            "title": "type"
          },
          "content": {
            "type": "string",
            "title": "contents of description",
            "description": "You must use markdown format string.\n\nIt is recommended to contain as much detail as possible on the issue raised by the user,\nso that the next person who reads this issue can see the summary and description of this issue to resolve the issue."
          }
        },
        "required": [
          "version",
          "type",
          "content"
        ]
      },
      "IJira.IGetCommentOutput": {
        "type": "object",
        "properties": {
          "comments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickCommentidcreatedauthorupdatedupdateAuthorbodyany"
            },
            "title": "comments"
          },
          "isLast": {
            "type": "boolean",
            "title": "Wheather is last page"
          },
          "total": {
            "type": "integer",
            "title": "total count"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          }
        },
        "required": [
          "comments",
          "total"
        ]
      },
      "MyPickCommentidcreatedauthorupdatedupdateAuthorbodyany": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id of comment"
          },
          "created": {
            "type": "string",
            "title": "created time of this comment"
          },
          "author": {
            "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName",
            "title": "author of this comment"
          },
          "updated": {
            "type": "string",
            "title": "updated time of this comment"
          },
          "updateAuthor": {
            "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName",
            "title": "who updates this comment"
          },
          "body": {
            "title": "Content of This Comments"
          }
        },
        "required": [
          "id",
          "created",
          "author",
          "updated",
          "updateAuthor",
          "body"
        ]
      },
      "MyPickIJira.UseractiveaccountIddisplayName": {
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean",
            "title": "Whether is user active"
          },
          "accountId": {
            "type": "string",
            "title": "id of this user account"
          },
          "displayName": {
            "type": "string",
            "title": "creator's name"
          }
        },
        "required": [
          "active",
          "accountId",
          "displayName"
        ]
      },
      "IJira.IGetCommentInput": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key",
            "description": "This connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "secretKey"
        ]
      },
      "IJira.IGetTransitionOutput": {
        "type": "object",
        "properties": {
          "transitions": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "title": "id of transition"
                },
                "to": {
                  "$ref": "#/components/schemas/MyPickIJira.StatusdescriptionnameidstatusCategory",
                  "title": "to",
                  "description": "StatusDetail.\nDetails of the issue status after the transition."
                }
              },
              "required": [
                "id",
                "to"
              ]
            },
            "title": "transition list of this jira issue"
          }
        },
        "required": [
          "transitions"
        ]
      },
      "MyPickIJira.StatusdescriptionnameidstatusCategory": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "title": "status description"
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "해야 할 일",
            "title": "status name"
          },
          "id": {
            "type": "string",
            "title": "status id"
          },
          "statusCategory": {
            "type": "object",
            "properties": {
              "id": {
                "type": "number",
                "title": "category id"
              },
              "key": {
                "type": "string",
                "x-wrtn-placeholder": "new",
                "title": "category key"
              }
            },
            "required": [
              "id",
              "key"
            ],
            "title": "status category"
          }
        },
        "required": [
          "description",
          "name",
          "id",
          "statusCategory"
        ]
      },
      "IJira.IGetTransitionInput": {
        "type": "object",
        "properties": {
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key",
            "description": "This connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "secretKey"
        ]
      },
      "IJira.IUnAssignInput": {
        "type": "object",
        "properties": {
          "issueId": {
            "type": "string",
            "title": "ID of issue"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueId",
          "secretKey"
        ]
      },
      "IJira.IAssignInput": {
        "type": "object",
        "properties": {
          "asigneeId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/issues/get-users-assignable",
                  "jmesPath": "[].{value:accountId, label:displayName}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/project/get-users-assignable",
                  "jmesPath": "[].{value:accountId, label:displayName}"
                }
              }
            ],
            "title": "accountId of the user you want to designate as the person in charge",
            "description": "If you want to designate a person in charge, you need that user's ID. Therefore, you need to look up the user first. There are connectors that look up who can be assigned to a project or issue. You can find the ID of the person in charge by choosing what you want.\nThe person in charge is inevitably one of Jira's users."
          },
          "issueId": {
            "type": "string",
            "title": "ID of issue"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "asigneeId",
          "issueId",
          "secretKey"
        ]
      },
      "IJira.IUpdateStatusInput": {
        "type": "object",
        "properties": {
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key",
            "description": "This connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "transitionId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/issue-get-transitions",
              "jmesPath": "transitions[].{value:id, label: to.name}"
            },
            "title": "ID of transition"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "transitionId",
          "secretKey"
        ]
      },
      "IJira.IUpdateIssueInput": {
        "type": "object",
        "properties": {
          "fields": {
            "$ref": "#/components/schemas/MyPartial__type",
            "title": "fields to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "fields",
          "secretKey"
        ]
      },
      "MyPartial__type": {
        "type": "object",
        "properties": {
          "assignee": {
            "type": "object",
            "properties": {
              "id": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/issues/get-users-assignable",
                      "jmesPath": "[].{value:accountId, label:displayName}"
                    }
                  },
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/project/get-users-assignable",
                      "jmesPath": "[].{value:accountId, label:displayName}"
                    }
                  }
                ],
                "title": "accountId of the user you want to designate as the person in charge",
                "description": "If you want to designate a person in charge, you need that user's ID. Therefore, you need to look up the user first. There are connectors that look up who can be assigned to a project or issue. You can find the ID of the person in charge by choosing what you want.\nThe person in charge is inevitably one of Jira's users."
              }
            },
            "required": [
              "id"
            ],
            "title": "Specify a representative at the same time as you create"
          },
          "description": {
            "type": "object",
            "properties": {
              "type": {
                "const": "doc",
                "title": "type of description\n\nAllow doc type only Now"
              },
              "version": {
                "const": 1,
                "title": "version"
              },
              "content": {
                "type": "string",
                "title": "contents of description",
                "description": "You must use markdown format string.\n\nIt is recommended to contain as much detail as possible on the issue raised by the user,\nso that the next person who reads this issue can see the summary and description of this issue to resolve the issue."
              }
            },
            "required": [
              "type",
              "version",
              "content"
            ],
            "title": "description\n\nThe content of the Jira issue consists of a combination of various contents."
          },
          "duedate": {
            "type": "string",
            "format": "date",
            "title": "due date",
            "description": "date format type.\nIndicates the schedule you want to be closed.Of course, it will be good to create a date or today."
          },
          "issuetype": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "pattern": "^(0|[1-9]\\d*)$",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issue-types",
                  "jmesPath": "issuetypes[].{value:id, label:name}"
                },
                "title": "id of issue type",
                "description": "The ID of the issue.\nSometimes the user can say the name of the issue type,\nsuch as 'bug' or 'story', but you cannot specify the issue type with the name of the issue type.\nBecause there can be types with the same name.\nTherefore, you must check the issue type with a different connector to verify that it is an issue type that can be used in the project.\n\nHowever, if you handed over the number string type from the beginning, it could be the ID of the issue type."
              }
            },
            "required": [
              "id"
            ],
            "title": "issuetype"
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels",
            "description": "You can add labels to make it easier to read issues.\nLabels are simply strings, which can be added immediately without having to look up using other connectors."
          },
          "parent": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                },
                "title": "key of parent issue",
                "description": "Sometimes an issue can be a sub-issue of another issue.\nIn this case, you need to specify the key for the parent issue.\nIf you want to know the key, use an issue list query or another connector to look up the details of the issue."
              }
            },
            "required": [
              "key"
            ],
            "title": "parent of this issue"
          },
          "priority": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issue-priorities",
                  "jmesPath": "[].{value:id, label:name}"
                },
                "title": "id of proirity",
                "description": "You can prioritize issues.\nUsers can also prioritize issues in natural languages such as Low, Medium, High, and so on,\nbut when creating issues, ID values for these priorities are required.\nTherefore, you should first call a connector that looks up what priorities are available for the project and issue."
              }
            },
            "required": [
              "id"
            ],
            "title": "priority"
          },
          "project": {
            "oneOf": [
              {
                "type": "object",
                "properties": {
                  "id": {
                    "oneOf": [
                      {
                        "type": "number",
                        "x-wrtn-prerequisite": {
                          "method": "post",
                          "path": "/connector/jira/get-projects",
                          "jmesPath": "[].{value:id, label:name}"
                        }
                      },
                      {
                        "type": "string",
                        "pattern": "^(0|[1-9]\\d*)$",
                        "x-wrtn-prerequisite": {
                          "method": "post",
                          "path": "/connector/jira/get-projects",
                          "jmesPath": "[].{value:id, label:name}"
                        }
                      }
                    ],
                    "title": "id of project"
                  }
                },
                "required": [
                  "id"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/get-project",
                      "jmesPath": "[].{value:key, label:name}"
                    },
                    "title": "key of project"
                  }
                },
                "required": [
                  "key"
                ]
              }
            ],
            "title": "project",
            "description": "Issues must inevitably belong to the project.\nAt this point, the project can be specified by receiving an ID or key.\nIf you do not know the key or ID of the project, you should first look up the project."
          },
          "summary": {
            "type": "string",
            "title": "summary",
            "description": "Meaning the title of the issue.\nMake sure you write a sentence that best represents this issue."
          }
        },
        "required": []
      },
      "IJira.ICreateIssueOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "ID of the issue that was created just now"
          },
          "key": {
            "type": "string",
            "title": "Key of the issue that was created just now"
          }
        },
        "required": [
          "id",
          "key"
        ],
        "title": "output of creation of issue"
      },
      "IJira.ICreateIssueByMarkdownInput": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "properties": {
              "assignee": {
                "type": "object",
                "properties": {
                  "id": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "x-wrtn-prerequisite": {
                          "method": "post",
                          "path": "/connector/jira/issues/get-users-assignable",
                          "jmesPath": "[].{value:accountId, label:displayName}"
                        }
                      },
                      {
                        "type": "string",
                        "x-wrtn-prerequisite": {
                          "method": "post",
                          "path": "/connector/jira/project/get-users-assignable",
                          "jmesPath": "[].{value:accountId, label:displayName}"
                        }
                      }
                    ],
                    "title": "accountId of the user you want to designate as the person in charge",
                    "description": "If you want to designate a person in charge, you need that user's ID. Therefore, you need to look up the user first. There are connectors that look up who can be assigned to a project or issue. You can find the ID of the person in charge by choosing what you want.\nThe person in charge is inevitably one of Jira's users."
                  }
                },
                "required": [
                  "id"
                ],
                "title": "Specify a representative at the same time as you create",
                "description": "The person in charge who wants to register must be a registered user in Jira.\nIf the person in charge does not exist, an error will occur.\nYou should not think that the ID of Slack or external service will be the same in Jira.\nIt is a good idea to check the person in charge because the user's ID may be different for each service."
              },
              "description": {
                "type": "object",
                "properties": {
                  "type": {
                    "const": "doc",
                    "title": "type of description\n\nAllow doc type only Now"
                  },
                  "version": {
                    "const": 1,
                    "title": "version\n\nversion only can be number 1"
                  },
                  "content": {
                    "type": "string",
                    "title": "contents of description",
                    "description": "You must use markdown format string.\n\nIt is recommended to contain as much detail as possible on the issue raised by the user,\nso that the next person who reads this issue can see the summary and description of this issue to resolve the issue."
                  }
                },
                "required": [
                  "type",
                  "version",
                  "content"
                ],
                "title": "description\n\nThe content of the Jira issue consists of a combination of various contents."
              },
              "issuetype": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "pattern": "^(0|[1-9]\\d*)$",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/get-issue-types",
                      "jmesPath": "issuetypes[].{value:id, label:name}"
                    },
                    "title": "id of issue type",
                    "description": "The ID of the issue.\nSometimes the user can say the name of the issue type,\nsuch as 'bug' or 'story', but you cannot specify the issue type with the name of the issue type.\nBecause there can be types with the same name.\nTherefore, you must check the issue type with a different connector to verify that it is an issue type that can be used in the project.\n\nHowever, if you handed over the number string type from the beginning, it could be the ID of the issue type."
                  }
                },
                "required": [
                  "id"
                ],
                "title": "issuetype",
                "description": "The issue type must be set, but the issue type that can be assigned to the project is set.\nUse the Issue Type Inquiry connector to determine which issue types can be set up."
              },
              "labels": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "labels",
                "description": "You can add labels to make it easier to read issues.\nLabels are simply strings, which can be added immediately without having to look up using other connectors."
              },
              "parent": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/get-issues",
                      "jmesPath": "issues[].{value:key, label:key}"
                    },
                    "title": "key of parent issue",
                    "description": "Sometimes an issue can be a sub-issue of another issue.\nIn this case, you need to specify the key for the parent issue.\nIf you want to know the key, use an issue list query or another connector to look up the details of the issue."
                  }
                },
                "required": [
                  "key"
                ],
                "title": "parent of this issue"
              },
              "priority": {
                "type": "object",
                "properties": {
                  "id": {
                    "type": "string",
                    "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/get-issue-priorities",
                      "jmesPath": "[].{value:id, label:name}"
                    },
                    "title": "id of proirity",
                    "description": "You can prioritize issues.\nUsers can also prioritize issues in natural languages such as Low, Medium, High, and so on,\nbut when creating issues, ID values for these priorities are required.\nTherefore, you should first call a connector that looks up what priorities are available for the project and issue."
                  }
                },
                "required": [
                  "id"
                ],
                "title": "priority",
                "description": "The project manager may have prohibited or not set priorities for each issue in the project.\nEven in the case of a project you just created,\nthe priority assignment for each issue may be omitted depending on the user.\nIn this case, priority assignment is not possible through API,\nso you should check the project settings.\n\nIf there is an error when creating it,\nit is likely to be a matter of priority,\nso please create it without priorities.\nAlso, it takes a long time to check the settings for each user on a daily basis,\nso make sure that you don't tell the user about the priority assignment,\nbut present it as an option."
              },
              "project": {
                "oneOf": [
                  {
                    "type": "object",
                    "properties": {
                      "id": {
                        "oneOf": [
                          {
                            "type": "number",
                            "x-wrtn-prerequisite": {
                              "method": "post",
                              "path": "/connector/jira/get-projects",
                              "jmesPath": "[].{value:id, label:name}"
                            }
                          },
                          {
                            "type": "string",
                            "pattern": "^(0|[1-9]\\d*)$",
                            "x-wrtn-prerequisite": {
                              "method": "post",
                              "path": "/connector/jira/get-projects",
                              "jmesPath": "[].{value:id, label:name}"
                            }
                          }
                        ],
                        "title": "id of project"
                      }
                    },
                    "required": [
                      "id"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "key": {
                        "type": "string",
                        "x-wrtn-prerequisite": {
                          "method": "post",
                          "path": "/connector/jira/get-project",
                          "jmesPath": "[].{value:key, label:name}"
                        },
                        "title": "key of project"
                      }
                    },
                    "required": [
                      "key"
                    ]
                  }
                ],
                "title": "project",
                "description": "Issues must inevitably belong to the project.\nAt this point, the project can be specified by receiving an ID or key.\nIf you do not know the key or ID of the project, you should first look up the project.\n\nproject's id is number or number string type and project's key type is only string."
              },
              "summary": {
                "type": "string",
                "title": "summary",
                "description": "Meaning the title of the issue.\nMake sure you write a sentence that best represents this issue."
              }
            },
            "required": [
              "issuetype",
              "project",
              "summary"
            ],
            "title": "fields\n\nIndicates the fields that you need to fill in when you want to create an issue."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "fields",
          "secretKey"
        ]
      },
      "IJira.IGetIssueDetailOutput": {
        "type": "object",
        "properties": {
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels attached to the issue"
          },
          "fields": {
            "$ref": "#/components/schemas/StrictOmitDetailedIssueFielddescriptioncommentcommentmaxResultsnumbertotalnumberstartAtnumbercommentsanydescriptionany",
            "title": "Details of the issue"
          },
          "id": {
            "type": "string",
            "title": "The ID of the issue"
          },
          "key": {
            "type": "string",
            "title": "The key of the issue"
          }
        },
        "required": [
          "fields",
          "id",
          "key"
        ]
      },
      "StrictOmitDetailedIssueFielddescriptioncommentcommentmaxResultsnumbertotalnumberstartAtnumbercommentsanydescriptionany": {
        "type": "object",
        "properties": {
          "summary": {
            "type": "string",
            "title": "summary"
          },
          "status": {
            "$ref": "#/components/schemas/MyPickIJira.StatusdescriptionnameidstatusCategoryuntranslatedName",
            "title": "status"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "assignee"
          },
          "issuetype": {
            "$ref": "#/components/schemas/MyPickIJira.IssueTypenameid",
            "title": "issue type"
          },
          "reporter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "reporter"
          },
          "priority": {
            "$ref": "#/components/schemas/MyPickIJira.Prioritynameid",
            "title": "priority"
          },
          "parent": {
            "$ref": "#/components/schemas/IJira.Parent",
            "title": "parent of this issue"
          },
          "statuscategorychangedate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "statuscategorychangedate",
            "description": "The date and time when the status category of the issue was last changed.\n\nThis property indicates the most recent timestamp when the issue transitioned\nbetween status categories (e.g., from \"To Do\" to \"In Progress\" or from\n\"In Progress\" to \"Done\"). Status categories in Jira typically include:\n- \"To Do\": The issue is pending and not yet started.\n- \"In Progress\": The issue is currently being worked on.\n- \"Done\": The issue has been completed."
          },
          "creator": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "creator"
          },
          "comment": {
            "type": "object",
            "properties": {
              "maxResults": {
                "type": "number",
                "title": "Number of comments viewed at one time"
              },
              "total": {
                "type": "number",
                "title": "Total count of comments"
              },
              "startAt": {
                "type": "number",
                "title": "page offset",
                "description": "The index of the first item to return in a page of results (page offset)."
              },
              "comments": {
                "type": "array",
                "items": {},
                "title": "list of comments"
              }
            },
            "required": [
              "maxResults",
              "total",
              "startAt",
              "comments"
            ],
            "title": "Comment Infomation and Pagination Metadata"
          },
          "description": {
            "title": "Description of Issue"
          }
        },
        "required": [
          "status",
          "priority",
          "comment",
          "description"
        ]
      },
      "MyPickIJira.StatusdescriptionnameidstatusCategoryuntranslatedName": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "title": "status description"
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "해야 할 일",
            "title": "status name"
          },
          "id": {
            "type": "string",
            "title": "status id"
          },
          "statusCategory": {
            "type": "object",
            "properties": {
              "id": {
                "type": "number",
                "title": "category id"
              },
              "key": {
                "type": "string",
                "x-wrtn-placeholder": "new",
                "title": "category key"
              }
            },
            "required": [
              "id",
              "key"
            ],
            "title": "status category"
          },
          "untranslatedName": {
            "type": "string",
            "title": "untranslated name"
          }
        },
        "required": [
          "description",
          "name",
          "id",
          "statusCategory"
        ]
      },
      "IJira.User": {
        "type": "object",
        "properties": {
          "accountId": {
            "type": "string",
            "title": "id of this user account"
          },
          "displayName": {
            "type": "string",
            "title": "creator's name"
          },
          "active": {
            "type": "boolean",
            "title": "Whether is user active"
          }
        },
        "required": [
          "accountId",
          "displayName",
          "active"
        ]
      },
      "MyPickIJira.IssueTypenameid": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "스토리",
            "title": "issue type name\n\nIt may be name, bug, story or etc."
          },
          "id": {
            "type": "string",
            "pattern": "^(0|[1-9]\\d*)$",
            "title": "issuetype's id"
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "MyPickIJira.Prioritynameid": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "priority name\n\nIt may be Low, Medium, High."
          },
          "id": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "title": "id"
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "IJira.Parent": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "The ID of the parent issue"
          },
          "key": {
            "type": "string",
            "title": "The key of the parent issue"
          },
          "fields": {
            "type": "object",
            "properties": {
              "summary": {
                "type": "string",
                "title": "summary"
              }
            },
            "required": [],
            "title": "fields"
          }
        },
        "required": [
          "id",
          "key",
          "fields"
        ]
      },
      "IJira.IGetIssueDetailInput": {
        "type": "object",
        "properties": {
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key",
            "description": "This connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "secretKey"
        ]
      },
      "IJira.IGetIssueOutput": {
        "type": "object",
        "properties": {
          "issues": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/linkstringFormatiriMyPickIssuefieldskeyid"
            },
            "title": "Jira issue list"
          },
          "isLast": {
            "type": "boolean",
            "title": "Wheather is last page"
          },
          "total": {
            "type": "integer",
            "title": "total count"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          }
        },
        "required": [
          "issues",
          "total"
        ]
      },
      "linkstringFormatiriMyPickIssuefieldskeyid": {
        "type": "object",
        "properties": {
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Link of issue",
            "description": "User can access by using this link"
          },
          "fields": {
            "$ref": "#/components/schemas/IJira.IssueField",
            "title": "fields"
          },
          "key": {
            "type": "string",
            "title": "The key of the issue"
          },
          "id": {
            "type": "string",
            "title": "The ID of the issue"
          }
        },
        "required": [
          "link",
          "fields",
          "key",
          "id"
        ]
      },
      "IJira.IssueField": {
        "type": "object",
        "properties": {
          "statuscategorychangedate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "statuscategorychangedate",
            "description": "The date and time when the status category of the issue was last changed.\n\nThis property indicates the most recent timestamp when the issue transitioned\nbetween status categories (e.g., from \"To Do\" to \"In Progress\" or from\n\"In Progress\" to \"Done\"). Status categories in Jira typically include:\n- \"To Do\": The issue is pending and not yet started.\n- \"In Progress\": The issue is currently being worked on.\n- \"Done\": The issue has been completed."
          },
          "reporter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "reporter"
          },
          "creator": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "creator"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "assignee"
          },
          "summary": {
            "type": "string",
            "title": "summary"
          },
          "issuetype": {
            "$ref": "#/components/schemas/MyPickIJira.IssueTypenameid",
            "title": "issue type"
          },
          "status": {
            "$ref": "#/components/schemas/MyPickIJira.StatusdescriptionnameidstatusCategoryuntranslatedName",
            "title": "status"
          },
          "priority": {
            "$ref": "#/components/schemas/MyPickIJira.Prioritynameid",
            "title": "priority"
          },
          "parent": {
            "$ref": "#/components/schemas/IJira.Parent",
            "title": "parent of this issue"
          }
        },
        "required": [
          "status",
          "priority"
        ]
      },
      "IJira.IGetIssueInputByBasicAuth": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-statuses",
              "jmesPath": "[].{value:id, label:untranslatedName}"
            },
            "title": "status"
          },
          "keyword": {
            "type": "string",
            "title": "search keyword\n\nIt is a keyword you want to find in the title or explanation of an issue, which is useful when searching."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "label titles\n\nComplex searches are possible using various labels."
          },
          "assignee": {
            "type": "string",
            "title": "name of assignee"
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "project_key": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-projects",
              "jmesPath": "values[].{value:key, label:name}"
            },
            "title": "key of project"
          },
          "issuetype": {
            "type": "string",
            "pattern": "^(0|[1-9]\\d*)$",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-issue-types",
              "jmesPath": "[].{label:untranslatedName, value:untranslatedName}"
            },
            "title": "issue type"
          },
          "reporter": {
            "type": "string",
            "title": "name of reporter"
          },
          "created_start_date": {
            "type": "string",
            "format": "date",
            "title": "Search for issues created after this date"
          },
          "created_end_date": {
            "type": "string",
            "format": "date",
            "title": "Search for issues created after this date"
          },
          "priority": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-issue-priorities",
              "jmesPath": "[].{value:name, label:name}"
            },
            "title": "priority name",
            "description": "If you want to search based on priority, deliver the name of the priority.\nThere are five priorities: 'Highest', 'High', 'Medium', 'Low', and 'Lowest'.\nAlthough it is a Deprecated feature, you can still query the priority level that can be assigned to an issue with the API.\nIt also exists as our connector, so use it if necessary."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "project_key",
          "secretKey"
        ]
      },
      "IJira.IGetProjectOutput": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IJira.Project"
            },
            "title": "Jira project list"
          },
          "isLast": {
            "type": "boolean",
            "title": "Wheather is last page"
          },
          "total": {
            "type": "integer",
            "title": "total count"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          }
        },
        "required": [
          "values",
          "total"
        ],
        "title": "output of getting Jira projects"
      },
      "IJira.Project": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string",
                "pattern": "^(0|[1-9]\\d*)$"
              }
            ],
            "title": "id"
          },
          "key": {
            "type": "string",
            "title": "key of project\n\nKey properties used to query the inside of a project."
          },
          "name": {
            "type": "string",
            "title": "name of this project"
          },
          "projectCategory": {
            "type": "object",
            "properties": {
              "description": {
                "type": "string",
                "title": "description"
              },
              "id": {
                "type": "string",
                "title": "id"
              },
              "name": {
                "type": "string",
                "title": "name"
              }
            },
            "required": [
              "description",
              "id",
              "name"
            ],
            "title": "project category info"
          }
        },
        "required": [
          "id",
          "key",
          "name"
        ]
      },
      "IJira.IGetProjectInputByBasicAuth": {
        "type": "object",
        "properties": {
          "orderBy": {
            "oneOf": [
              {
                "const": "issueCount"
              },
              {
                "const": "lastIssueUpdatedTime"
              },
              {
                "const": "name"
              }
            ],
            "title": "order by",
            "description": "Order the results by a field.\n\n- issueCount : Sorts by the total number of issues in each project.\n- lastIssueUpdatedTime : Sorts by the last issue update time.\n- name : Sorts by project name."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IJira.IGetIssueLabelOutput": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "label list"
          },
          "isLast": {
            "type": "boolean",
            "title": "Wheather is last page"
          },
          "total": {
            "type": "integer",
            "title": "total count"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          }
        },
        "required": [
          "values",
          "total"
        ]
      },
      "IJira.IGetIssueLabelInput": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IJira.IGetIssueTypeOutput": {
        "type": "object",
        "properties": {
          "issuetypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IJira.IssueType"
            },
            "title": "issue types in this projects"
          }
        },
        "required": [
          "issuetypes"
        ]
      },
      "IJira.IssueType": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "pattern": "^(0|[1-9]\\d*)$",
            "title": "issuetype's id"
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "스토리",
            "title": "issue type name\n\nIt may be name, bug, story or etc."
          },
          "description": {
            "type": "string",
            "title": "description"
          },
          "subtask": {
            "type": "boolean",
            "title": "whether is for substask issue type"
          }
        },
        "required": [
          "id",
          "name",
          "description",
          "subtask"
        ]
      },
      "IJira.IGetIssueTypeInput": {
        "type": "object",
        "properties": {
          "projectId": {
            "oneOf": [
              {
                "type": "number",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connectors/jira/get-projects",
                  "jmesPath": "values[].{value:id,label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^(0|[1-9]\\d*)$",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connectors/jira/get-projects",
                  "jmesPath": "values[].{value:id,label:name}"
                }
              }
            ],
            "title": "id of project"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "projectId",
          "secretKey"
        ]
      },
      "IJira.IGetIssueStatusOutput": {
        "type": "object",
        "properties": {
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickStatusnameiduntranslatedNameprojectIdstringundefined"
            },
            "title": "statuses"
          }
        },
        "required": [
          "statuses"
        ]
      },
      "MyPickStatusnameiduntranslatedNameprojectIdstringundefined": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "해야 할 일",
            "title": "status name"
          },
          "id": {
            "type": "string",
            "title": "status id"
          },
          "untranslatedName": {
            "type": "string",
            "title": "untranslated name"
          },
          "projectId": {
            "type": "string",
            "title": "projectId"
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "IJira.IGetIssueStatusInput": {
        "type": "object",
        "properties": {
          "projectId": {
            "oneOf": [
              {
                "type": "number",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connectors/jira/get-projects",
                  "jmesPath": "values[].{value:id,label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^(0|[1-9]\\d*)$",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connectors/jira/get-projects",
                  "jmesPath": "values[].{value:id,label:name}"
                }
              }
            ],
            "title": "id of project",
            "description": "If the status does not have the project ID,\nit means this status is beyond the scope of the project and can be selected by the entire team.\nIt can also be the default status created from the beginning by Jira."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IJira.IGetIssuePriorityInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IJira.IGetIssueAssignableInput": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "project": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-projects",
              "jmesPath": "values[].{value:key, label:name}"
            },
            "title": "key of project\n\nIt refers to the key of the project to search for the user to be assigned."
          },
          "issueKey": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connectors/jira/get-issues",
              "jmesPath": "issues[].{value:key, label:key}"
            },
            "title": "key of issue\n\nIt refers to the key of the issue to search for the user to be assigned."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "project",
          "issueKey",
          "secretKey"
        ]
      },
      "IJira.IGetProjectAssignableInput": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "project_key": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-projects",
              "jmesPath": "values[].{value:key, label:name}"
            },
            "title": "key of project\n\nIt refers to the key of the project to search for the user to be assigned."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "project_key",
          "secretKey"
        ]
      },
      "IJira.StatusCategory": {
        "type": "object",
        "properties": {
          "colorName": {
            "type": "string",
            "title": "name of color"
          },
          "id": {
            "type": "number",
            "title": "The ID of status category"
          },
          "key": {
            "type": "string",
            "title": "The key of status category"
          },
          "name": {
            "type": "string",
            "title": "name of the status category"
          }
        },
        "required": [
          "colorName",
          "id",
          "key",
          "name"
        ]
      },
      "IJira.IGetStatusCategoryInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IGoogleMap.IAutocompleteOutput": {
        "type": "object",
        "properties": {
          "suggestions": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "null"
                },
                {
                  "type": "object",
                  "properties": {
                    "placePrediction": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "$ref": "#/components/schemas/IGoogleMap.PlacePrediction"
                        }
                      ],
                      "title": "Place Prediction",
                      "description": "Meaning of candidate groups viewed as map search results"
                    }
                  },
                  "required": [
                    "placePrediction"
                  ]
                }
              ]
            },
            "title": "Response"
          }
        },
        "required": [],
        "title": "Response of Autocomplete"
      },
      "IGoogleMap.PlacePrediction": {
        "type": "object",
        "properties": {
          "placeId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Place ID",
            "description": "Place ID of Google map"
          },
          "text": {
            "type": "object",
            "properties": {
              "text": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string",
                    "x-wrtn-placeholder": "대한민국 서울특별시 강남구 신사동 피자익스프레스"
                  }
                ],
                "title": "Name"
              }
            },
            "required": [],
            "title": "Name"
          },
          "types": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Place Types"
          }
        },
        "required": [
          "types"
        ],
        "title": "Place Prediction"
      },
      "IGoogleMap.IAutocompleteInput": {
        "type": "object",
        "properties": {
          "input": {
            "type": "string",
            "title": "search keyword"
          },
          "circle": {
            "type": "object",
            "properties": {
              "latitude": {
                "type": "number",
                "title": "Latitude",
                "description": "It refers to a latitude value for specifying a space of an area to be searched."
              },
              "longitude": {
                "type": "number",
                "title": "Longitude",
                "description": "It refers to a longitude value for specifying a space of an area to be searched."
              },
              "radius": {
                "type": "number",
                "default": 500,
                "minimum": 0,
                "maximum": 50000,
                "title": "Radius",
                "description": "This refers to the radial distance for specifying the space of the region to be searched. It is in meters.\ndefault value is 500 meters."
              }
            },
            "required": [
              "latitude",
              "longitude",
              "radius"
            ],
            "title": "Search radius"
          }
        },
        "required": [
          "input"
        ],
        "title": "Input Parameter of Autocomplete"
      },
      "IGoogleMap.IReviewResponse": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "Author's name",
            "description": "Reviewer's name."
          },
          "rating": {
            "type": "number",
            "title": "Review ratings",
            "description": "Here are the review ratings."
          },
          "description": {
            "type": "string",
            "title": "Review content",
            "description": "Here is the review content."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Review Link",
            "description": "Here is the review link."
          },
          "images": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iri",
              "contentMediaType": "image/*"
            },
            "title": "Review Image",
            "description": "This is the image registered in the review."
          },
          "date": {
            "type": "string",
            "title": "Review Date",
            "description": "The date the review was written."
          }
        },
        "required": [
          "username",
          "rating",
          "description",
          "link",
          "images",
          "date"
        ],
        "title": "Review search results"
      },
      "IGoogleMap.IReviewRequest": {
        "type": "object",
        "properties": {
          "place_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-map/search",
              "jmesPath": "[].{value:place_id, label:place_id}"
            }
          }
        },
        "required": [
          "place_id"
        ]
      },
      "IGoogleMap.ISearchTextOutput": {
        "type": "object",
        "properties": {
          "places": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleMap.Place"
            },
            "title": "Places"
          },
          "nextPageToken": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Page Token For Next Page"
          }
        },
        "required": [
          "places",
          "nextPageToken"
        ]
      },
      "IGoogleMap.Place": {
        "type": "object",
        "properties": {
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "name"
          },
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "id"
          },
          "types": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "types"
          },
          "nationalPhoneNumber": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "nationalPhoneNumber"
          },
          "internationalPhoneNumber": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "internationalPhoneNumber"
          },
          "formattedAddress": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "formattedAddress"
          },
          "location": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "latitude": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "number",
                        "minimum": -90,
                        "maximum": 90
                      }
                    ],
                    "title": "latitude"
                  },
                  "longitude": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "number",
                        "minimum": 0,
                        "maximum": 360
                      }
                    ],
                    "title": "longitude"
                  }
                },
                "required": []
              }
            ],
            "title": "location"
          },
          "rating": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number",
                "maximum": 5
              }
            ],
            "title": "rating"
          },
          "googleMapsUri": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "googleMapsUri"
          },
          "websiteUri": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "websiteUri"
          },
          "regularOpeningHours": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "openNow": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "boolean"
                      }
                    ],
                    "title": "openNow"
                  },
                  "periods": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "open": {
                          "oneOf": [
                            {
                              "type": "null"
                            },
                            {
                              "type": "object",
                              "properties": {
                                "day": {
                                  "oneOf": [
                                    {
                                      "type": "null"
                                    },
                                    {
                                      "type": "integer",
                                      "minimum": 0,
                                      "maximum": 6
                                    }
                                  ],
                                  "title": "day"
                                },
                                "hour": {
                                  "oneOf": [
                                    {
                                      "type": "null"
                                    },
                                    {
                                      "type": "integer",
                                      "minimum": 0,
                                      "maximum": 24
                                    }
                                  ],
                                  "title": "hour"
                                },
                                "minute": {
                                  "oneOf": [
                                    {
                                      "type": "null"
                                    },
                                    {
                                      "type": "integer",
                                      "minimum": 0,
                                      "maximum": 60
                                    }
                                  ],
                                  "title": "minute"
                                }
                              },
                              "required": []
                            }
                          ],
                          "title": "open"
                        },
                        "close": {
                          "type": "object",
                          "properties": {
                            "day": {
                              "oneOf": [
                                {
                                  "type": "null"
                                },
                                {
                                  "type": "integer",
                                  "minimum": 0,
                                  "maximum": 6
                                }
                              ],
                              "title": "day"
                            },
                            "hour": {
                              "oneOf": [
                                {
                                  "type": "null"
                                },
                                {
                                  "type": "integer",
                                  "minimum": 0,
                                  "maximum": 24
                                }
                              ],
                              "title": "hour"
                            },
                            "minute": {
                              "oneOf": [
                                {
                                  "type": "null"
                                },
                                {
                                  "type": "integer",
                                  "minimum": 0,
                                  "maximum": 60
                                }
                              ],
                              "title": "minute"
                            }
                          },
                          "required": [],
                          "title": "close"
                        }
                      },
                      "required": []
                    },
                    "title": "periods"
                  },
                  "weekdayDescriptions": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ],
                    "title": "weekdayDescriptions"
                  }
                },
                "required": []
              }
            ],
            "title": "regularOpeningHours"
          },
          "utcOffsetMinutes": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number",
                "minimum": 0,
                "maximum": 1440
              }
            ],
            "title": "utcOffsetMinutes"
          },
          "businessStatus": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "businessStatus"
          },
          "priceLevel": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "priceLevel"
          },
          "userRatingCount": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "userRatingCount"
          },
          "displayName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "text": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "text"
                  },
                  "languageCode": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "languageCode"
                  }
                },
                "required": []
              }
            ],
            "title": "displayName"
          },
          "primaryTypeDisplayName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "text": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "text"
                  },
                  "languageCode": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "languageCode"
                  }
                },
                "required": []
              }
            ],
            "title": "primaryTypeDisplayName"
          },
          "takeout": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "takeout"
          },
          "delivery": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "delivery"
          },
          "dineIn": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "dineIn"
          },
          "reservable": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "reservable"
          },
          "servesBreakfast": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesBreakfast"
          },
          "servesLunch": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesLunch"
          },
          "servesDinner": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesDinner"
          },
          "servesBeer": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesBeer"
          },
          "servesBrunch": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesBrunch"
          },
          "servesVegetarianFood": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesVegetarianFood"
          },
          "primaryType": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "primaryType"
          },
          "photos": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "name"
                    },
                    "widthPx": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "number"
                        }
                      ],
                      "title": "widthPx"
                    },
                    "heightPx": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "number"
                        }
                      ],
                      "title": "heightPx"
                    },
                    "link": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "URI Link"
                    }
                  },
                  "required": []
                }
              }
            ],
            "title": "photos"
          },
          "outdoorSeating": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "outdoorSeating"
          },
          "liveMusic": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "liveMusic"
          },
          "menuForChildren": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "menuForChildren"
          },
          "servesCocktails": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesCocktails"
          },
          "servesDessert": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesDessert"
          },
          "servesCoffee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "servesCoffee"
          },
          "goodForChildren": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "goodForChildren"
          },
          "allowsDogs": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "allowsDogs"
          },
          "restroom": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "restroom"
          },
          "goodForGroups": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "goodForGroups"
          },
          "goodForWatchingSports": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "goodForWatchingSports"
          },
          "paymentOptions": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "acceptsCreditCards": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "boolean"
                      }
                    ],
                    "title": "acceptsCreditCards"
                  },
                  "acceptsDebitCards": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "boolean"
                      }
                    ],
                    "title": "acceptsDebitCards"
                  },
                  "acceptsCashOnly": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "boolean"
                      }
                    ],
                    "title": "acceptsCashOnly"
                  },
                  "acceptsNfc": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "boolean"
                      }
                    ],
                    "title": "acceptsNfc"
                  }
                },
                "required": []
              }
            ],
            "title": "paymentOptions"
          },
          "parkingOptions": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "freeParkingLot": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "boolean"
                      }
                    ],
                    "title": "freeParkingLot"
                  }
                },
                "required": []
              }
            ],
            "title": "parkingOptions"
          },
          "accessibilityOptions": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "wheelchairAccessibleParking": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "boolean"
                      }
                    ],
                    "title": "wheelchairAccessibleParking"
                  },
                  "wheelchairAccessibleSeating": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "boolean"
                      }
                    ],
                    "title": "wheelchairAccessibleSeating"
                  }
                },
                "required": []
              }
            ],
            "title": "accessibilityOptions"
          },
          "googleMapsLinks": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "placeUri": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "format": "iri"
                      }
                    ],
                    "title": "Place URI"
                  },
                  "reviewsUri": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "format": "iri"
                      }
                    ],
                    "title": "Reviews URI"
                  },
                  "photosUri": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "format": "iri"
                      }
                    ],
                    "title": "Photos URI"
                  }
                },
                "required": []
              }
            ],
            "title": "googleMapsLinks"
          }
        },
        "required": []
      },
      "IGoogleMap.ISearchTextInput": {
        "type": "object",
        "properties": {
          "textQuery": {
            "type": "string",
            "title": "search keyword"
          },
          "nextPageToken": {
            "type": "string",
            "title": "Page Token For Next Page"
          }
        },
        "required": [
          "textQuery"
        ]
      },
      "IGoogleMap.IResponse": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Name",
            "description": "It's the name of a restaurant."
          },
          "place_id": {
            "type": "string",
            "title": "unique ID",
            "description": "This is the unique ID of the restaurant.\n\nThis is the information needed to search for reviews."
          },
          "gps_coordinate": {
            "type": "object",
            "properties": {
              "latitude": {
                "type": "number",
                "title": "Latitude",
                "description": "This is the latitude of the restaurant's coordinates."
              },
              "longitude": {
                "type": "number",
                "title": "Longitude",
                "description": "This is the coordinates of the restaurant."
              }
            },
            "required": [
              "latitude",
              "longitude"
            ],
            "title": "Coordinates",
            "description": "Here are the coordinates for the restaurant."
          },
          "rating": {
            "type": "number",
            "title": "ratings",
            "description": "Here are the restaurant ratings."
          },
          "reviews": {
            "type": "number",
            "title": "Number of reviews",
            "description": "This is the number of restaurant reviews."
          },
          "address": {
            "type": "string",
            "title": "Address",
            "description": "Here is the address of the restaurant."
          },
          "open_state": {
            "type": "string",
            "title": "Operation Information",
            "description": "Information about whether the restaurant is currently operating."
          },
          "operating_hours": {
            "type": "object",
            "properties": {},
            "required": [],
            "title": "Information on operating hours",
            "description": "Here is the information on the restaurant's operating hours.",
            "additionalProperties": {
              "type": "string"
            }
          },
          "phone_number": {
            "type": "string",
            "title": "Phone number",
            "description": "This is the phone number for the restaurant."
          },
          "service_options": {
            "type": "object",
            "properties": {},
            "required": [],
            "title": "Service options",
            "description": "Service options provided by the restaurant.",
            "additionalProperties": {
              "type": "boolean"
            }
          },
          "user_review": {
            "type": "string",
            "title": "User Review",
            "description": "This is a user review of a delicious restaurant."
          },
          "thumbnail": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri",
                "contentMediaType": "image/*"
              }
            ],
            "title": "image",
            "description": "This is a thumbnail image of a delicious restaurant."
          }
        },
        "required": [
          "title",
          "place_id",
          "gps_coordinate",
          "address"
        ],
        "title": "Google Maps Restaurant Search Results"
      },
      "IGoogleMap.IRequest": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "minLength": 1,
            "x-wrtn-placeholder": "강남역 맛집",
            "title": "Search term",
            "description": "Please enter your search term"
          }
        },
        "required": [
          "keyword"
        ],
        "title": "Information for searching restaurants on Google Maps"
      },
      "IGithub.IGetEventOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "title": "id"
                },
                "type": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "const": "CommitCommentEvent"
                    },
                    {
                      "const": "CreateEvent"
                    },
                    {
                      "const": "DeleteEvent"
                    },
                    {
                      "const": "ForkEvent"
                    },
                    {
                      "const": "GollumEvent"
                    },
                    {
                      "const": "IssueCommentEvent"
                    },
                    {
                      "const": "IssuesEvent"
                    },
                    {
                      "const": "MemberEvent"
                    },
                    {
                      "const": "PublicEvent"
                    },
                    {
                      "const": "PullRequestEvent"
                    },
                    {
                      "const": "PullRequestReviewEvent"
                    },
                    {
                      "const": "PullRequestReviewCommentEvent"
                    },
                    {
                      "const": "PullRequestReviewThreadEvent"
                    },
                    {
                      "const": "PushEvent"
                    },
                    {
                      "const": "ReleaseEvent"
                    },
                    {
                      "const": "SponsorshipEvent"
                    },
                    {
                      "const": "WatchEvent"
                    }
                  ],
                  "title": "event type\nThere are various events such as `WatchEvent`, `CreateEvent`, `ForkEvent`."
                },
                "actor": {
                  "$ref": "#/components/schemas/MyPickIGithub.Useridlogin",
                  "title": "user"
                },
                "repo": {
                  "$ref": "#/components/schemas/MyPickIGithub.Repositorynameid",
                  "title": "repo"
                },
                "org": {
                  "$ref": "#/components/schemas/MyPickIGithub.Organizationidlogindisplay_login",
                  "title": "org"
                },
                "payload": {
                  "$ref": "#/components/schemas/IGithub.Payload",
                  "title": "payload"
                },
                "public": {
                  "type": "boolean",
                  "title": "whather is public"
                },
                "created_at": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    }
                  ],
                  "title": "created_at"
                }
              },
              "required": [
                "id",
                "type",
                "actor",
                "repo",
                "payload",
                "public",
                "created_at"
              ]
            },
            "title": "event"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "MyPickIGithub.Useridlogin": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          }
        },
        "required": [
          "id",
          "login"
        ]
      },
      "MyPickIGithub.Repositorynameid": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name"
          },
          "id": {
            "type": "number",
            "title": "id"
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "MyPickIGithub.Organizationidlogindisplay_login": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "login": {
            "type": "string",
            "title": "login"
          },
          "display_login": {
            "type": "string",
            "title": "display_login"
          }
        },
        "required": [
          "id",
          "login"
        ]
      },
      "IGithub.Payload": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "title": "action",
            "description": "It means what this event means.\nAlthough the type of event usually has a resource or the name of the event,\nit is necessary to view it with this property because it does not specify what actions occurred in that event are modified, deleted, created, etc."
          },
          "issue": {
            "$ref": "#/components/schemas/IGithub.Issue",
            "title": "issue",
            "description": "If it is an event for an issue, contain the issue information."
          },
          "comment": {
            "$ref": "#/components/schemas/IGithub.Comment",
            "title": "comment",
            "description": "If it is an event for an comment, contain the comment information."
          }
        },
        "required": []
      },
      "IGithub.Issue": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "title": "issue id"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url",
            "description": "If you want to see the issue or pull_request on the web, you can go to this link.\nIf pull is included on this link path, it is pull_request, and if issue is included, it is issue.\nIn essence, pull_request and issue are numbered together from the beginning, so while this connector does not distinguish the two, it can be distinguished by the url path."
          },
          "number": {
            "type": "integer",
            "title": "issue number\n\nNumber uniquely identifying the issue within its repository"
          },
          "state": {
            "type": "string",
            "title": "state\n\nState of the issue; either 'open' or 'closed'"
          },
          "state_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "completed"
              },
              {
                "const": "reopened"
              },
              {
                "const": "not_planned"
              }
            ],
            "title": "state_reason",
            "description": "The reason for the current state"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "title of the issue"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
            "title": "user"
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "body",
            "description": "Contents of the issue\n\nYou can also render this content because it is in a markdown format."
          },
          "labels": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "integer",
                      "title": "id"
                    },
                    "url": {
                      "type": "string",
                      "format": "iri",
                      "title": "url"
                    },
                    "name": {
                      "type": "string",
                      "title": "name"
                    },
                    "description": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "description"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "color"
                    },
                    "default": {
                      "type": "boolean",
                      "title": "default"
                    }
                  },
                  "required": []
                }
              ]
            },
            "title": "labels\n\nLabels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
              }
            ],
            "title": "assignee"
          },
          "assignees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            ],
            "title": "assignees\n\nIf there are many people in charge, you can be included in the array."
          }
        },
        "required": [
          "id",
          "html_url",
          "number",
          "state",
          "title",
          "user",
          "labels",
          "assignee"
        ]
      },
      "MyPickIGithub.Useridtypelogin": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          }
        },
        "required": [
          "id",
          "type",
          "login"
        ]
      },
      "MyPickIGithub.Userlogin": {
        "type": "object",
        "properties": {
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          }
        },
        "required": [
          "login"
        ]
      },
      "IGithub.Comment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "title": "id"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Useridtypeloginhtml_urlavatar_url",
            "title": "user"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "pages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Page"
            },
            "title": "pages"
          }
        },
        "required": [
          "id",
          "user",
          "created_at",
          "updated_at"
        ]
      },
      "MyPickIGithub.Useridtypeloginhtml_urlavatar_url": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to look up your profile, you can access this website."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "id",
          "type",
          "login",
          "html_url",
          "avatar_url"
        ]
      },
      "IGithub.Page": {
        "type": "object",
        "properties": {
          "page_name": {
            "type": "string",
            "title": "page_name"
          },
          "title": {
            "type": "string",
            "title": "title"
          },
          "summary": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "summary"
          },
          "action": {
            "type": "string",
            "title": "action"
          },
          "sha": {
            "type": "string",
            "title": "sha"
          },
          "html_url": {
            "type": "string",
            "title": "html_url"
          }
        },
        "required": []
      },
      "IGithub.IGetReceivedEventInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetUserPinnedRepositoryInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "username": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-users",
              "jmesPath": "items[].{value:login, label:login}"
            },
            "title": "username\n\nThis refers to the nickname of the user who will look up the repository."
          }
        },
        "required": [
          "secretKey",
          "username"
        ]
      },
      "IGithub.IGetUserRepositoryOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.RepositoryWithReadmeFile"
            },
            "title": "repositories"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.RepositoryWithReadmeFile": {
        "type": "object",
        "properties": {
          "readme": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.RepositoryFile"
              }
            ],
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "file": "#/components/schemas/IGithub.RepositoryFile"
              }
            },
            "title": "readme"
          },
          "id": {
            "type": "number",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "full_name": {
            "type": "string",
            "title": "full_name\n\nThis is in the form '{username}/{reponame}'."
          },
          "private": {
            "type": "boolean",
            "title": "private"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          },
          "fork": {
            "type": "boolean",
            "title": "fork"
          },
          "forks_count": {
            "type": "integer",
            "title": "forks_count"
          },
          "stargazers_count": {
            "type": "integer",
            "title": "stargazers_count"
          },
          "watchers_count": {
            "type": "integer",
            "title": "watchers_count"
          },
          "size": {
            "type": "number",
            "title": "size"
          },
          "default_branch": {
            "type": "string",
            "title": "default_branch"
          },
          "open_issues_count": {
            "type": "integer",
            "title": "open_issues_count"
          },
          "is_template": {
            "type": "boolean",
            "title": "is_template"
          },
          "topics": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "topics"
          },
          "has_issues": {
            "type": "boolean",
            "title": "has_issues"
          },
          "has_projects": {
            "type": "boolean",
            "title": "has_projects"
          },
          "has_wiki": {
            "type": "boolean",
            "title": "has_wiki"
          },
          "has_pages": {
            "type": "boolean",
            "title": "has_pages"
          },
          "has_downloads": {
            "type": "boolean",
            "title": "has_downloads"
          },
          "archived": {
            "type": "boolean",
            "title": "archived"
          },
          "disabled": {
            "type": "boolean",
            "title": "disabled"
          },
          "visibility": {
            "oneOf": [
              {
                "const": "private"
              },
              {
                "const": "public"
              }
            ],
            "title": "visibility"
          },
          "pushed_at": {
            "type": "string",
            "format": "date-time",
            "title": "pushed_at"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "permissions": {
            "type": "object",
            "properties": {
              "admin": {
                "type": "boolean",
                "title": "admin"
              },
              "push": {
                "type": "boolean",
                "title": "push"
              },
              "pull": {
                "type": "boolean",
                "title": "pull"
              }
            },
            "required": [
              "admin",
              "push",
              "pull"
            ],
            "title": "permissions"
          },
          "allow_rebase_merge": {
            "type": "boolean",
            "title": "allow_rebase_merge"
          },
          "allow_squash_merge": {
            "type": "boolean",
            "title": "allow_squash_merge"
          },
          "allow_auto_merge": {
            "type": "boolean",
            "title": "allow_auto_merge"
          },
          "delete_branch_on_merge": {
            "type": "boolean",
            "title": "delete_branch_on_merge"
          },
          "allow_merge_commit": {
            "type": "boolean",
            "title": "allow_merge_commit"
          },
          "subscribers_count": {
            "type": "integer",
            "title": "subscribers_count"
          },
          "network_count": {
            "type": "integer",
            "title": "network_count"
          },
          "license": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-placeholder": "mit",
                    "title": "key"
                  },
                  "name": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT License",
                    "title": "name"
                  },
                  "url": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "x-wrtn-placeholder": "https://api.github.com/licenses/mit"
                      }
                    ],
                    "title": "url"
                  },
                  "spdx_id": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT",
                    "title": "spdx_id"
                  }
                },
                "required": [
                  "key",
                  "name",
                  "url",
                  "spdx_id"
                ]
              }
            ],
            "title": "license"
          },
          "forks": {
            "type": "integer",
            "title": "forks"
          },
          "open_issues": {
            "type": "integer",
            "title": "open_issues"
          },
          "watchers": {
            "type": "integer",
            "title": "watchers"
          }
        },
        "required": [
          "readme",
          "id",
          "name",
          "full_name",
          "private",
          "html_url",
          "description",
          "fork",
          "forks_count",
          "stargazers_count",
          "watchers_count",
          "size",
          "default_branch",
          "open_issues_count",
          "is_template",
          "topics",
          "has_issues",
          "has_projects",
          "has_wiki",
          "has_pages",
          "has_downloads",
          "archived",
          "disabled",
          "visibility",
          "pushed_at",
          "created_at",
          "updated_at",
          "license",
          "forks",
          "open_issues",
          "watchers"
        ]
      },
      "IGithub.RepositoryFile": {
        "type": "object",
        "properties": {
          "type": {
            "const": "file",
            "title": "type"
          },
          "encoding": {
            "type": "string",
            "x-wrtn-placeholder": "base64",
            "title": "encoding"
          },
          "size": {
            "type": "number",
            "title": "Indicates the file size in bytes"
          },
          "name": {
            "type": "string",
            "title": "name of this file"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          },
          "content": {
            "type": "string",
            "title": "content"
          },
          "sha": {
            "type": "string",
            "title": "sha"
          },
          "url": {
            "type": "string",
            "title": "url\n\nA link that allows you to view the contents of the file as an Url value for viewing the details of the file."
          },
          "download_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "download_url\n\nThe url that allows you to download a file, which is useful if it is a media file containing an image."
          }
        },
        "required": [
          "type",
          "encoding",
          "size",
          "name",
          "path",
          "content",
          "sha",
          "url"
        ]
      },
      "IGithub.IGetUserRepositoryInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-users",
              "jmesPath": "items[].{value:login, label:login}"
            },
            "title": "username\n\nThis refers to the nickname of the user who will look up the repository."
          },
          "per_page": {
            "type": "integer",
            "default": 10,
            "maximum": 10,
            "title": "per_page",
            "description": "The number of results per page (max 10).\n\nThe response capacity may be very large because it even comes out with the reedy of the repository.\nTherefore, it is recommended to check by cutting up to 10 pieces."
          },
          "sort": {
            "oneOf": [
              {
                "const": "created"
              },
              {
                "const": "updated"
              },
              {
                "const": "pushed"
              },
              {
                "const": "full_name"
              }
            ],
            "title": "sorting condition",
            "description": "The property to sort the results by.\nIt must be one of: \"created\" | \"updated\" | \"pushed\" | \"full_name\""
          },
          "direction": {
            "oneOf": [
              {
                "const": "desc"
              },
              {
                "const": "asc"
              }
            ],
            "title": "direction",
            "description": "The order to sort by.\nDefault: asc when using full_name, otherwise desc."
          },
          "since": {
            "type": "string",
            "format": "date-time",
            "title": "since\nOnly show repositories updated after the given time. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ."
          },
          "before": {
            "type": "string",
            "format": "date-time",
            "title": "before\nOnly show repositories updated before the given time. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetOrganizationEventInput": {
        "type": "object",
        "properties": {
          "organization": {
            "type": "string",
            "title": "organization's name\n\nYou can also change it to your nickname."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "organization",
          "secretKey"
        ]
      },
      "IGithub.IGetOrganizationAuthenticationUserIssueOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Issue"
            },
            "title": "Issues"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.IGetOrganizationAuthenticationUserIssueInput": {
        "type": "object",
        "properties": {
          "organization": {
            "type": "string",
            "title": "organization\nThe organization name. The name is not case sensitive."
          },
          "direction": {
            "oneOf": [
              {
                "const": "desc"
              },
              {
                "const": "asc"
              }
            ],
            "title": "direction",
            "description": "The order to sort by.\nDefault: asc when using full_name, otherwise desc."
          },
          "filter": {
            "oneOf": [
              {
                "const": "assigned"
              },
              {
                "const": "created"
              },
              {
                "const": "mentioned"
              },
              {
                "const": "subscribed"
              },
              {
                "const": "repos"
              },
              {
                "const": "all"
              }
            ],
            "title": "filter",
            "description": "It must be one of: \"assigned\", \"created\", \"mentioned\", \"subscribed\", \"repos\", \"all\"\n\nIndicates which sorts of issues to return.\nassigned means issues assigned to you.\ncreated means issues created by you.\nmentioned means issues mentioning you.\nsubscribed means issues you're subscribed to updates for.\nall or repos means all issues you can see, regardless of participation or creation."
          },
          "state": {
            "oneOf": [
              {
                "const": "open"
              },
              {
                "const": "closed"
              },
              {
                "const": "all"
              }
            ],
            "title": "state",
            "description": "Indicates the state of the issues to return.\nIt must be one of: 'open', 'closed', 'all'"
          },
          "labels": {
            "type": "string",
            "title": "label\n\nA list of comma separated label names. Example: `bug,ui,@high`"
          },
          "sort": {
            "oneOf": [
              {
                "const": "created"
              },
              {
                "const": "updated"
              },
              {
                "const": "comments"
              }
            ],
            "title": "sort\nIt must be 'created', 'updated', 'comments'"
          },
          "owned": {
            "type": "boolean",
            "title": "owned"
          },
          "pulls": {
            "type": "boolean",
            "title": "pulls"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user",
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "organization",
          "secretKey"
        ]
      },
      "IGithub.IGetOrganizationRepositoryOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Repository"
            },
            "title": "repositories"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Repository": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "full_name": {
            "type": "string",
            "title": "full_name\n\nThis is in the form '{username}/{reponame}'."
          },
          "private": {
            "type": "boolean",
            "title": "private"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          },
          "fork": {
            "type": "boolean",
            "title": "fork"
          },
          "forks_count": {
            "type": "integer",
            "title": "forks_count"
          },
          "stargazers_count": {
            "type": "integer",
            "title": "stargazers_count"
          },
          "watchers_count": {
            "type": "integer",
            "title": "watchers_count"
          },
          "size": {
            "type": "number",
            "title": "size"
          },
          "default_branch": {
            "type": "string",
            "title": "default_branch"
          },
          "open_issues_count": {
            "type": "integer",
            "title": "open_issues_count"
          },
          "is_template": {
            "type": "boolean",
            "title": "is_template"
          },
          "topics": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "topics"
          },
          "has_issues": {
            "type": "boolean",
            "title": "has_issues"
          },
          "has_projects": {
            "type": "boolean",
            "title": "has_projects"
          },
          "has_wiki": {
            "type": "boolean",
            "title": "has_wiki"
          },
          "has_pages": {
            "type": "boolean",
            "title": "has_pages"
          },
          "has_downloads": {
            "type": "boolean",
            "title": "has_downloads"
          },
          "archived": {
            "type": "boolean",
            "title": "archived"
          },
          "disabled": {
            "type": "boolean",
            "title": "disabled"
          },
          "visibility": {
            "oneOf": [
              {
                "const": "private"
              },
              {
                "const": "public"
              }
            ],
            "title": "visibility"
          },
          "pushed_at": {
            "type": "string",
            "format": "date-time",
            "title": "pushed_at"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "permissions": {
            "type": "object",
            "properties": {
              "admin": {
                "type": "boolean",
                "title": "admin"
              },
              "push": {
                "type": "boolean",
                "title": "push"
              },
              "pull": {
                "type": "boolean",
                "title": "pull"
              }
            },
            "required": [
              "admin",
              "push",
              "pull"
            ],
            "title": "permissions"
          },
          "allow_rebase_merge": {
            "type": "boolean",
            "title": "allow_rebase_merge"
          },
          "allow_squash_merge": {
            "type": "boolean",
            "title": "allow_squash_merge"
          },
          "allow_auto_merge": {
            "type": "boolean",
            "title": "allow_auto_merge"
          },
          "delete_branch_on_merge": {
            "type": "boolean",
            "title": "delete_branch_on_merge"
          },
          "allow_merge_commit": {
            "type": "boolean",
            "title": "allow_merge_commit"
          },
          "subscribers_count": {
            "type": "integer",
            "title": "subscribers_count"
          },
          "network_count": {
            "type": "integer",
            "title": "network_count"
          },
          "license": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-placeholder": "mit",
                    "title": "key"
                  },
                  "name": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT License",
                    "title": "name"
                  },
                  "url": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "x-wrtn-placeholder": "https://api.github.com/licenses/mit"
                      }
                    ],
                    "title": "url"
                  },
                  "spdx_id": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT",
                    "title": "spdx_id"
                  }
                },
                "required": [
                  "key",
                  "name",
                  "url",
                  "spdx_id"
                ]
              }
            ],
            "title": "license"
          },
          "forks": {
            "type": "integer",
            "title": "forks"
          },
          "open_issues": {
            "type": "integer",
            "title": "open_issues"
          },
          "watchers": {
            "type": "integer",
            "title": "watchers"
          }
        },
        "required": [
          "id",
          "name",
          "full_name",
          "private",
          "html_url",
          "description",
          "fork",
          "forks_count",
          "stargazers_count",
          "watchers_count",
          "size",
          "default_branch",
          "open_issues_count",
          "is_template",
          "topics",
          "has_issues",
          "has_projects",
          "has_wiki",
          "has_pages",
          "has_downloads",
          "archived",
          "disabled",
          "visibility",
          "pushed_at",
          "created_at",
          "updated_at",
          "license",
          "forks",
          "open_issues",
          "watchers"
        ]
      },
      "IGithub.IGetCollaboratorOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Collaborator"
            },
            "title": "result"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Collaborator": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to look up your profile, you can access this website."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "id",
          "type",
          "login",
          "html_url",
          "avatar_url"
        ]
      },
      "IGithub.IGetCollaboratorInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "affiliation": {
            "oneOf": [
              {
                "const": "outside"
              },
              {
                "const": "direct"
              },
              {
                "const": "all"
              }
            ],
            "title": "affiliation",
            "description": "Filter collaborators returned by their affiliation.\noutside means all outside collaborators of an organization-owned repository. direct means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. all means all collaborators the authenticated user can see.\nIt must be one of: \"outside\", \"direct\", \"all\"."
          },
          "permission": {
            "oneOf": [
              {
                "const": "pull"
              },
              {
                "const": "triage"
              },
              {
                "const": "push"
              },
              {
                "const": "maintain"
              },
              {
                "const": "admin"
              }
            ],
            "title": "permission",
            "description": "Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.\nIt must be one of: \"pull\", \"triage\", \"push\", \"maintain\", \"admin\"."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "admin:org",
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IDeleteFileContentInput": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "title": "commit message\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "path": {
            "type": "string",
            "title": "path parameters",
            "description": "It refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "sha": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repos/get-contents",
              "jmesPath": "[].{value:sha, label:path} || {value:sha, label:path}"
            },
            "title": "sha of file content",
            "description": "As the sha value of the file to be modified, a conflict may occur if it is not the latest sha value among the sha values of the file.\nIt's safe when you look up a list of files through API to check sha and put in a value, or want to re-modify the sha value of a file you just created."
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The author of the file",
            "description": "If you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: The committer or the authenticated user if you omit committer."
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The person that committed the file",
            "description": "If you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: the authenticated user."
          },
          "branch": {
            "type": "string",
            "title": "branch name\n\nThe branch name. Default: the repository’s default branch"
          }
        },
        "required": [
          "message",
          "secretKey",
          "owner",
          "path",
          "repo",
          "sha"
        ]
      },
      "IGithub.IUpsertFileContentOutput": {
        "type": "object",
        "properties": {
          "content": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "file or folder name"
              },
              "path": {
                "type": "string",
                "title": "file or folder path"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "size": {
                "type": "number",
                "title": "size"
              }
            },
            "required": [
              "name",
              "path",
              "sha",
              "size"
            ],
            "title": "content"
          },
          "commit": {
            "type": "object",
            "properties": {
              "sha": {
                "type": "string",
                "title": "sha"
              }
            },
            "required": [
              "sha"
            ],
            "title": "commit"
          }
        },
        "required": [
          "content",
          "commit"
        ]
      },
      "IGithub.IUpdateFileContentInput": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repos/get-contents",
              "jmesPath": "[].{value:sha, label:path} || {value:sha, label:path}"
            },
            "title": "sha of file content",
            "description": "As the sha value of the file to be modified, a conflict may occur if it is not the latest sha value among the sha values of the file.\nIt's safe when you look up a list of files through API to check sha and put in a value, or want to re-modify the sha value of a file you just created."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "path": {
            "type": "string",
            "title": "path parameters",
            "description": "It refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "message": {
            "type": "string",
            "title": "commit message\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message."
          },
          "content": {
            "type": "string",
            "title": "the new file content",
            "description": "Meaning of the file is text and text.\nIf you want to create code content, you should write code content.\nSince it encodes with base64 internally, we need to deliver text here before encoding."
          },
          "branch": {
            "type": "string",
            "title": "branch name\n\nThe branch name. Default: the repository’s default branch"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The person that committed the file",
            "description": "If you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: the authenticated user."
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The author of the file",
            "description": "If you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: The committer or the authenticated user if you omit committer."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "sha",
          "owner",
          "repo",
          "path",
          "message",
          "content",
          "secretKey"
        ]
      },
      "IGithub.ICreateFileContentInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "path": {
            "type": "string",
            "title": "path parameters",
            "description": "It refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "message": {
            "type": "string",
            "title": "commit message\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message."
          },
          "content": {
            "type": "string",
            "title": "the new file content",
            "description": "Meaning of the file is text and text.\nIf you want to create code content, you should write code content.\nSince it encodes with base64 internally, we need to deliver text here before encoding."
          },
          "branch": {
            "type": "string",
            "title": "branch name\n\nThe branch name. Default: the repository’s default branch"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The person that committed the file",
            "description": "If you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: the authenticated user."
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The author of the file",
            "description": "If you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: The committer or the authenticated user if you omit committer."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "path",
          "message",
          "content",
          "secretKey"
        ]
      },
      "RepositoryFolderchildrenany": {
        "type": "object",
        "properties": {
          "type": {
            "const": "dir",
            "title": "type"
          },
          "size": {
            "const": 0,
            "title": "Indicates the file size in bytes"
          },
          "name": {
            "type": "string",
            "title": "name of this folder"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          },
          "sha": {
            "type": "string",
            "title": "sha"
          },
          "children": {
            "type": "array",
            "items": {},
            "title": "children",
            "description": "For folders, you may have other files or folders inside.\nThis should also be a folder or file type object,\nbut here, we specify it as any type to prevent it because it can be recursively infinitely large."
          }
        },
        "required": [
          "type",
          "size",
          "name",
          "path",
          "sha",
          "children"
        ]
      },
      "StrictOmitIGithub.RepositoryFilecontentencoding": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name of this file"
          },
          "url": {
            "type": "string",
            "title": "url\n\nA link that allows you to view the contents of the file as an Url value for viewing the details of the file."
          },
          "type": {
            "const": "file",
            "title": "type"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          },
          "size": {
            "type": "number",
            "title": "Indicates the file size in bytes"
          },
          "sha": {
            "type": "string",
            "title": "sha"
          },
          "download_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "download_url\n\nThe url that allows you to download a file, which is useful if it is a media file containing an image."
          }
        },
        "required": [
          "name",
          "url",
          "type",
          "path",
          "size",
          "sha"
        ]
      },
      "IGithub.IGetRepositoryFolderStructureInput": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "default": "",
            "title": "folder name",
            "description": "The path delivered is treated like a Root folder and continues the navigation from this folder.\nBrowse by this folder, and it must be a folder, not a file.\nIf omitted, start the circuit based on the top Root folder."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author.\n\nIf it is an organization's repository, it can also be the name of the organization."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          }
        },
        "required": [
          "secretKey",
          "owner",
          "repo"
        ]
      },
      "IGithub.RepositoryFolder": {
        "type": "object",
        "properties": {
          "type": {
            "const": "dir",
            "title": "type"
          },
          "size": {
            "const": 0,
            "title": "Indicates the file size in bytes"
          },
          "name": {
            "type": "string",
            "title": "name of this folder"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          },
          "sha": {
            "type": "string",
            "title": "sha"
          }
        },
        "required": [
          "type",
          "size",
          "name",
          "path",
          "sha"
        ]
      },
      "IGithub.IGetBulkFileContentInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "paths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "path parameters",
            "description": "It refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "branch": {
            "type": "string",
            "title": "branch name"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetFileContentInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author.\n\nIf it is an organization's repository, it can also be the name of the organization."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "path": {
            "type": "string",
            "title": "path parameters",
            "description": "It refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "branch": {
            "type": "string",
            "title": "branch name"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetReadmeFileContentInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author.\n\nIf it is an organization's repository, it can also be the name of the organization."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          }
        },
        "required": [
          "secretKey",
          "owner",
          "repo"
        ]
      },
      "IGithub.IGetRepoEventInput": {
        "type": "object",
        "properties": {
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "repo",
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetUserEventInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetUserOrganizationOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Organization"
            },
            "title": "result"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Organization": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "login": {
            "type": "string",
            "title": "login"
          },
          "display_login": {
            "type": "string",
            "title": "display_login"
          },
          "description": {
            "type": "string",
            "title": "description"
          }
        },
        "required": [
          "id",
          "login"
        ]
      },
      "IGithub.IGetUserOrganizationInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetEventInput": {
        "type": "object",
        "properties": {
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IGithub.IGetRepositoryActivityOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Activity"
            },
            "title": "result of repository activities"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Activity": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "ref": {
            "type": "string",
            "x-wrtn-placeholder": "refs/heads/main",
            "title": "ref"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "timestamp"
          },
          "activity_type": {
            "oneOf": [
              {
                "const": "push"
              },
              {
                "const": "force_push"
              },
              {
                "const": "branch_creation"
              },
              {
                "const": "branch_deletion"
              },
              {
                "const": "pr_merge"
              },
              {
                "const": "merge_queue_merge"
              }
            ],
            "title": "activity type"
          },
          "actor": {
            "$ref": "#/components/schemas/MyPickIGithub.Useridtypeloginavatar_url",
            "title": "actor"
          }
        },
        "required": [
          "id",
          "ref",
          "timestamp",
          "activity_type",
          "actor"
        ]
      },
      "MyPickIGithub.Useridtypeloginavatar_url": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "id",
          "type",
          "login",
          "avatar_url"
        ]
      },
      "IGithub.IGetRepositoryActivityInput": {
        "type": "object",
        "properties": {
          "direction": {
            "oneOf": [
              {
                "const": "desc"
              },
              {
                "const": "asc"
              }
            ],
            "title": "direction",
            "description": "The order to sort by.\nDefault: asc when using full_name, otherwise desc."
          },
          "before": {
            "type": "string",
            "title": "before",
            "description": "A cursor, as given in the Link header.\nIf specified, the query only searches for results before this cursor."
          },
          "after": {
            "type": "string",
            "title": "after",
            "description": "A cursor, as given in the Link header.\nIf specified, the query only searches for results after this cursor."
          },
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "ref": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-branches",
              "jmesPath": "result[].{value:name, label:name}"
            },
            "title": "ref\n\nThe name of one of the branches of this repository."
          },
          "actor": {
            "type": "string",
            "title": "username"
          },
          "time_period": {
            "oneOf": [
              {
                "const": "day"
              },
              {
                "const": "week"
              },
              {
                "const": "month"
              },
              {
                "const": "quarter"
              },
              {
                "const": "year"
              }
            ],
            "title": "time_period"
          },
          "activity_type": {
            "oneOf": [
              {
                "const": "push"
              },
              {
                "const": "force_push"
              },
              {
                "const": "branch_creation"
              },
              {
                "const": "branch_deletion"
              },
              {
                "const": "pr_merge"
              },
              {
                "const": "merge_queue_merge"
              }
            ],
            "title": "activity_type"
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IUpdatePullRequestOutput": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "number of this pull request"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "title of the issue"
          },
          "id": {
            "type": "integer",
            "title": "issue id"
          }
        },
        "required": [
          "number",
          "title",
          "id"
        ]
      },
      "IGithub.IUpdatePullRequestInput": {
        "type": "object",
        "properties": {
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "state": {
            "oneOf": [
              {
                "const": "open"
              },
              {
                "const": "closed"
              }
            ],
            "title": "state",
            "description": "State of this Pull Request. Either open or closed.\nCan be one of: open, closed"
          },
          "base": {
            "type": "string",
            "title": "base\n\nThe name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository."
          },
          "head": {
            "type": "string",
            "title": "head\n\nThe name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace head with a user like this: username:branch."
          },
          "title": {
            "type": "string",
            "title": "title\n\nThe title of the new pull request. Required unless issue is specified."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "body": {
            "type": "string",
            "title": "body\n\nThe contents of the pull request."
          },
          "head_repo": {
            "type": "string",
            "title": "head_repo\n\nThe name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization."
          },
          "maintainer_can_modify": {
            "type": "boolean",
            "title": "maintainer_can_modify\n\nIndicates whether maintainers can modify the pull request."
          },
          "draft": {
            "type": "boolean",
            "title": "draft\n\nIndicates whether the pull request is a draft. See \"Draft Pull Requests\" in the GitHub Help documentation to learn more."
          },
          "issue": {
            "type": "number",
            "title": "issue\n\nAn issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless title is specified."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels"
          }
        },
        "required": [
          "pull_number",
          "secretKey",
          "owner",
          "repo"
        ]
      },
      "IGithub.ICreatePullRequestOutput": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "number of this pull request"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "title of the issue"
          },
          "id": {
            "type": "integer",
            "title": "issue id"
          }
        },
        "required": [
          "number",
          "title",
          "id"
        ]
      },
      "IGithub.ICreatePullRequestInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "title": {
            "type": "string",
            "title": "title\n\nThe title of the new pull request. Required unless issue is specified."
          },
          "head": {
            "type": "string",
            "title": "head\n\nThe name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace head with a user like this: username:branch."
          },
          "head_repo": {
            "type": "string",
            "title": "head_repo\n\nThe name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization."
          },
          "base": {
            "type": "string",
            "title": "base\n\nThe name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository."
          },
          "body": {
            "type": "string",
            "title": "body\n\nThe contents of the pull request."
          },
          "maintainer_can_modify": {
            "type": "boolean",
            "title": "maintainer_can_modify\n\nIndicates whether maintainers can modify the pull request."
          },
          "draft": {
            "type": "boolean",
            "title": "draft\n\nIndicates whether the pull request is a draft. See \"Draft Pull Requests\" in the GitHub Help documentation to learn more."
          },
          "issue": {
            "type": "number",
            "title": "issue\n\nAn issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless title is specified."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "head",
          "base",
          "secretKey"
        ]
      },
      "IGithub.IGetIssueCommentsOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.IssueComment"
            },
            "title": "issue comments"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.IssueComment": {
        "type": "object",
        "properties": {
          "issue_url": {
            "type": "string",
            "format": "iri",
            "title": "issue_url"
          },
          "author_association": {
            "oneOf": [
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "NONE"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          },
          "id": {
            "type": "integer",
            "title": "id"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Useridtypeloginhtml_urlavatar_url",
            "title": "user"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          }
        },
        "required": [
          "issue_url",
          "author_association",
          "id",
          "created_at",
          "user",
          "updated_at"
        ]
      },
      "IGithub.IGetPullRequestCommentsInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.ICreateIssueCommentInput": {
        "type": "object",
        "properties": {
          "body": {
            "type": "string",
            "title": "The contents of the comment"
          },
          "issue_number": {
            "type": "integer",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repositories/get-issues",
              "jmesPath": "fetchedIssues[].{value:number, label:title}"
            },
            "title": "issue number to get detailed info"
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "body",
          "issue_number",
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IReadPullRequestRequestedReviewerOutput": {
        "type": "object",
        "properties": {
          "users": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Collaborator"
            },
            "title": "requested reviewers"
          },
          "teams": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Teamdescriptionnameidslugnotification_settingpermissionprivacy"
            },
            "title": "team"
          }
        },
        "required": [
          "users",
          "teams"
        ]
      },
      "MyPickIGithub.Teamdescriptionnameidslugnotification_settingpermissionprivacy": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "title": "description"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "id": {
            "type": "number",
            "title": "id"
          },
          "slug": {
            "type": "string",
            "title": "slug"
          },
          "notification_setting": {
            "type": "string",
            "title": "notification_setting"
          },
          "permission": {
            "type": "string",
            "title": "permission"
          },
          "privacy": {
            "oneOf": [
              {
                "const": "closed"
              },
              {
                "const": "open"
              }
            ],
            "title": "privacy"
          }
        },
        "required": [
          "description",
          "name",
          "id",
          "slug",
          "notification_setting",
          "permission",
          "privacy"
        ]
      },
      "IGithub.IReadPullRequestDetailInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IRequestReviewerInput": {
        "type": "object",
        "properties": {
          "reviewers": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/github/repos/get-collaborators",
                "jmesPath": "result[].{value:login, label:login}"
              }
            },
            "title": "reviewers",
            "description": "An array of user logins that will be requested."
          },
          "team_reviewers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "team_reviewers",
            "description": "An array of team slugs that will be requested."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IGetReviewCommentOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.ReviewComment"
            },
            "title": "result"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.ReviewComment": {
        "type": "object",
        "properties": {
          "pull_request_review_id": {
            "type": "integer",
            "title": "pull_request_review_id"
          },
          "diff_hunk": {
            "type": "string",
            "title": "diff_hunk",
            "description": "diff_hunk is a form for representing a change in code in github.\nIt consists of strings, and the first line, based on the new line character,\nhas meta information about the change point between the symbols"
          },
          "path": {
            "type": "string",
            "title": "path"
          },
          "position": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "position",
            "description": "The position in the diff where you want to add a review comment.\nNote this value is not the same as the line number in the file.\nThe position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment.\nThe line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.\n\nPosition value, which is the number of rows based on diff_hunk."
          },
          "original_position": {
            "type": "integer",
            "title": "original_position\n\nOriginal position value, which is the number of rows based on diff_hunk."
          },
          "commit_id": {
            "type": "string",
            "title": "commit_id"
          },
          "original_commit_id": {
            "type": "string",
            "title": "original_commit_id"
          },
          "in_reply_to_id": {
            "type": "integer",
            "title": "in_reply_to_id\n\nIn_reply_to_id is a field used by GitHub's review or comment API that is used to write a reply to a particular review or comment."
          },
          "user": {
            "$ref": "#/components/schemas/IGithub.Collaborator",
            "title": "user"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "author_association": {
            "oneOf": [
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "NONE"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          },
          "id": {
            "type": "integer",
            "title": "id"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          }
        },
        "required": [
          "pull_request_review_id",
          "diff_hunk",
          "path",
          "position",
          "original_position",
          "commit_id",
          "original_commit_id",
          "user",
          "html_url",
          "author_association",
          "id",
          "created_at",
          "updated_at"
        ]
      },
      "IGithub.IGetReviewCommentInput": {
        "type": "object",
        "properties": {
          "review_id": {
            "type": "integer",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/repositories/pull-requests/get-reviews",
              "jmesPath": "result[].{value:id, label: join('', [user.login, ''s review'])}"
            },
            "title": "review_id"
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "review_id",
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IReadPullRequestReviewOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Review"
            },
            "title": "commit list of this pull request"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Review": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "title": "id"
          },
          "user": {
            "$ref": "#/components/schemas/IGithub.Collaborator",
            "title": "reviewer"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "state": {
            "type": "string",
            "x-wrtn-placeholder": "APPROVED",
            "title": "state"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "pull_request_url": {
            "type": "string",
            "format": "iri",
            "title": "pull_request_url"
          },
          "submitted_at": {
            "type": "string",
            "format": "date-time",
            "title": "submitted_at"
          },
          "commit_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "commit_id",
            "description": "A commit SHA for the review.\nIf the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`."
          },
          "author_association": {
            "oneOf": [
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "NONE"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          }
        },
        "required": [
          "id",
          "user",
          "body",
          "state",
          "html_url",
          "pull_request_url",
          "commit_id",
          "author_association"
        ]
      },
      "IGithub.IReadPullRequestReviewInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IReviewPullRequestOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "title": "id"
          }
        },
        "required": [
          "id"
        ]
      },
      "IGithub.IReviewPullRequestInput": {
        "type": "object",
        "properties": {
          "commit_id": {
            "type": "string",
            "title": "commit_id",
            "description": "The SHA of the commit that needs a review.\nNot using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the position.\nDefaults to the most recent commit in the pull request when you do not specify a value."
          },
          "body": {
            "type": "string",
            "title": "body",
            "description": "Required when using REQUEST_CHANGES or COMMENT for the event parameter.\nThe body text of the pull request review."
          },
          "event": {
            "oneOf": [
              {
                "const": "APPROVE"
              },
              {
                "const": "REQUEST_CHANGES"
              },
              {
                "const": "COMMENT"
              }
            ],
            "title": "event",
            "description": "The review action you want to perform.\nThe review actions include: APPROVE, REQUEST_CHANGES, or COMMENT.\nBy leaving this blank, you set the review action state to PENDING, which means you will need to submit the pull request review when you are ready."
          },
          "comments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.IPullRequestComment"
            },
            "title": "comments\n\nUse the following table to specify the location, destination, and contents of the draft review comment."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IPullRequestComment": {
        "type": "object",
        "properties": {
          "line": {
            "type": "integer",
            "title": "line"
          },
          "side": {
            "type": "string",
            "title": "side"
          },
          "start_line": {
            "type": "integer",
            "title": "start_line"
          },
          "start_side": {
            "type": "string",
            "title": "start_side"
          },
          "path": {
            "type": "string",
            "title": "path"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "position": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "position",
            "description": "The position in the diff where you want to add a review comment.\nNote this value is not the same as the line number in the file.\nThe position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment.\nThe line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.\n\nPosition value, which is the number of rows based on diff_hunk."
          }
        },
        "required": [
          "line",
          "side",
          "start_line",
          "start_side",
          "path",
          "position"
        ]
      },
      "IGithub.IReadPullRequestFileOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.File"
            },
            "title": "result"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.File": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "title": "hash of this file"
          },
          "filename": {
            "type": "string",
            "title": "filename"
          },
          "status": {
            "oneOf": [
              {
                "const": "added"
              },
              {
                "const": "removed"
              },
              {
                "const": "modified"
              },
              {
                "const": "renamed"
              },
              {
                "const": "copied"
              },
              {
                "const": "changed"
              },
              {
                "const": "unchanged"
              }
            ],
            "title": "status of file in this commit"
          },
          "additions": {
            "type": "integer",
            "title": "additions"
          },
          "deletions": {
            "type": "integer",
            "title": "deletions"
          },
          "changes": {
            "type": "integer",
            "title": "changes"
          },
          "blob_url": {
            "type": "string",
            "format": "iri",
            "title": "blob_url\n\nThis is the path through which you can view the file through the github website."
          },
          "raw_url": {
            "type": "string",
            "format": "iri",
            "title": "raw_url\n\nThe API path through which the contents of the file can be viewed."
          },
          "patch": {
            "type": "string",
            "title": "patch",
            "description": "It means how much it has changed compared to previous commitments.\nIt gives you a text form to see what code has actually changed."
          }
        },
        "required": [
          "sha",
          "filename",
          "status",
          "additions",
          "deletions",
          "changes",
          "blob_url",
          "raw_url"
        ]
      },
      "IGithub.IReadPullRequestFileInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IReadPullRequestCommitOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGithub.Commitsha"
            },
            "title": "commit list of this pull request"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "StrictOmitIGithub.Commitsha": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "title": "commit message"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "uri\n\nuri to look up details of commitment"
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name"
              },
              "email": {
                "type": "string",
                "title": "email"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "author"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name"
              },
              "email": {
                "type": "string",
                "title": "email"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "committer"
          },
          "tree": {
            "type": "object",
            "properties": {
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url"
              }
            },
            "required": [
              "sha",
              "url"
            ],
            "title": "tree"
          },
          "comment_count": {
            "type": "integer",
            "title": "comment_count"
          }
        },
        "required": [
          "message",
          "url",
          "author",
          "committer",
          "tree",
          "comment_count"
        ]
      },
      "IGithub.IReadPullRequestCommitInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.PullRequest": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "number of this pull request"
          },
          "milestone": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.MileStone"
              }
            ],
            "title": "milestone"
          },
          "head": {
            "type": "object",
            "properties": {
              "label": {
                "type": "string",
                "title": "label"
              },
              "ref": {
                "type": "string",
                "title": "ref"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "user": {
                "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
                "title": "user"
              },
              "repo": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/MyPickIGithub.Repositoryfull_name"
                  }
                ],
                "title": "repo"
              }
            },
            "required": [
              "label",
              "ref",
              "sha",
              "user",
              "repo"
            ],
            "title": "head branch info"
          },
          "base": {
            "type": "object",
            "properties": {
              "label": {
                "type": "string",
                "title": "label"
              },
              "ref": {
                "type": "string",
                "title": "ref"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "user": {
                "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
                "title": "user"
              },
              "repo": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/MyPickIGithub.Repositoryfull_name"
                  }
                ],
                "title": "repo"
              }
            },
            "required": [
              "label",
              "ref",
              "sha",
              "user",
              "repo"
            ],
            "title": "base branch info"
          },
          "author_association": {
            "oneOf": [
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "NONE"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          },
          "draft": {
            "type": "boolean",
            "title": "draft\n\nIndicates whether or not the pull request is a draft."
          },
          "requested_reviewers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin"
            },
            "title": "requested_reviewers"
          },
          "requested_teams": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartialIGithub.Team"
            },
            "title": "requested_teams"
          },
          "auto_merge": {
            "title": "auto_merge"
          },
          "merged": {
            "type": "boolean",
            "title": "merged"
          },
          "mergeable": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "mergeable"
          },
          "rebaseable": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "rebaseable"
          },
          "mergeable_state": {
            "type": "string",
            "title": "mergeable_state"
          },
          "merged_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin"
              }
            ],
            "title": "merged_by"
          },
          "maintainer_can_modify": {
            "type": "boolean",
            "title": "maintainer_can_modify"
          },
          "comments": {
            "type": "integer",
            "minimum": 0,
            "title": "comments"
          },
          "review_comments": {
            "type": "integer",
            "minimum": 0,
            "title": "review_comments"
          },
          "commits": {
            "type": "integer",
            "minimum": 0,
            "title": "commits"
          },
          "additions": {
            "type": "integer",
            "minimum": 0,
            "title": "additions"
          },
          "deletions": {
            "type": "integer",
            "minimum": 0,
            "title": "deletions"
          },
          "changed_files": {
            "type": "integer",
            "minimum": 0,
            "title": "changed_files"
          },
          "locked": {
            "type": "boolean",
            "title": "locked"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "closed_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "closed_at"
          },
          "merged_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "merged_at"
          },
          "id": {
            "type": "integer",
            "title": "issue id"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url",
            "description": "If you want to see the issue or pull_request on the web, you can go to this link.\nIf pull is included on this link path, it is pull_request, and if issue is included, it is issue.\nIn essence, pull_request and issue are numbered together from the beginning, so while this connector does not distinguish the two, it can be distinguished by the url path."
          },
          "state": {
            "type": "string",
            "title": "state\n\nState of the issue; either 'open' or 'closed'"
          },
          "state_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "completed"
              },
              {
                "const": "reopened"
              },
              {
                "const": "not_planned"
              }
            ],
            "title": "state_reason",
            "description": "The reason for the current state"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "title of the issue"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
            "title": "user"
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "body",
            "description": "Contents of the issue\n\nYou can also render this content because it is in a markdown format."
          },
          "labels": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "integer",
                      "title": "id"
                    },
                    "url": {
                      "type": "string",
                      "format": "iri",
                      "title": "url"
                    },
                    "name": {
                      "type": "string",
                      "title": "name"
                    },
                    "description": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "description"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "color"
                    },
                    "default": {
                      "type": "boolean",
                      "title": "default"
                    }
                  },
                  "required": []
                }
              ]
            },
            "title": "labels\n\nLabels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
              }
            ],
            "title": "assignee"
          },
          "assignees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            ],
            "title": "assignees\n\nIf there are many people in charge, you can be included in the array."
          }
        },
        "required": [
          "number",
          "milestone",
          "head",
          "base",
          "author_association",
          "requested_reviewers",
          "requested_teams",
          "auto_merge",
          "mergeable",
          "rebaseable",
          "mergeable_state",
          "merged_by",
          "maintainer_can_modify",
          "comments",
          "review_comments",
          "commits",
          "additions",
          "deletions",
          "changed_files",
          "locked",
          "created_at",
          "updated_at",
          "closed_at",
          "merged_at",
          "id",
          "html_url",
          "state",
          "title",
          "user",
          "labels",
          "assignee"
        ]
      },
      "IGithub.MileStone": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "number": {
            "type": "number",
            "title": "number"
          },
          "state": {
            "oneOf": [
              {
                "const": "closed"
              },
              {
                "const": "open"
              }
            ],
            "title": "state"
          },
          "title": {
            "type": "string",
            "title": "title"
          },
          "description": {
            "type": "string",
            "title": "description"
          },
          "creator": {
            "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
            "title": "creator"
          },
          "open_issues": {
            "type": "integer",
            "minimum": 0,
            "title": "open_issues"
          },
          "closed_issues": {
            "type": "integer",
            "minimum": 0,
            "title": "closed_issues"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "closed_at": {
            "type": "string",
            "format": "date-time",
            "title": "closed_at"
          },
          "due_on": {
            "type": "string",
            "format": "date-time",
            "title": "due_on"
          }
        },
        "required": [
          "id",
          "number",
          "state",
          "title",
          "description",
          "creator",
          "open_issues",
          "closed_issues",
          "created_at",
          "updated_at",
          "closed_at",
          "due_on"
        ]
      },
      "MyPickIGithub.Repositoryfull_name": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string",
            "title": "full_name\n\nThis is in the form '{username}/{reponame}'."
          }
        },
        "required": [
          "full_name"
        ]
      },
      "PartialIGithub.Team": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "slug": {
            "type": "string",
            "title": "slug"
          },
          "description": {
            "type": "string",
            "title": "description"
          },
          "privacy": {
            "oneOf": [
              {
                "const": "closed"
              },
              {
                "const": "open"
              }
            ],
            "title": "privacy"
          },
          "notification_setting": {
            "type": "string",
            "title": "notification_setting"
          },
          "permission": {
            "type": "string",
            "title": "permission"
          }
        },
        "required": [],
        "description": "Make all properties in T optional"
      },
      "IGithub.IFetchRepositoryPullRequestOutput": {
        "type": "object",
        "properties": {
          "pullRequests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.FetchedPullRequest"
            },
            "title": "Pull Requests"
          },
          "pageInfo": {
            "type": "object",
            "properties": {
              "endCursor": {
                "type": "string",
                "title": "Cursor to be used to look up the next page"
              },
              "hasNextPage": {
                "type": "boolean",
                "title": "hasNextPage\n\ntrue if there is a next page"
              }
            },
            "required": [
              "hasNextPage"
            ],
            "title": "page info"
          }
        },
        "required": [
          "pullRequests",
          "pageInfo"
        ]
      },
      "IGithub.FetchedPullRequest": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "issue id"
          },
          "state": {
            "oneOf": [
              {
                "const": "OPEN"
              },
              {
                "const": "CLOSED"
              },
              {
                "const": "MERGED"
              }
            ],
            "title": "issue state"
          },
          "number": {
            "type": "integer",
            "title": "number of pull request"
          },
          "title": {
            "type": "string",
            "title": "Pull request title"
          },
          "comments": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total count of comments"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "comments"
          },
          "reviews": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total counr of reviews"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "reviews"
          },
          "reactions": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total count of reactions"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "reactions"
          },
          "labels": {
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Labeldescriptionname"
                }
              }
            },
            "required": [
              "nodes"
            ],
            "title": "labels"
          },
          "assignees": {
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                },
                "title": "nodes"
              }
            },
            "required": [
              "nodes"
            ],
            "title": "assignees"
          },
          "author": {
            "$ref": "#/components/schemas/MyPickIGithub.Userlogin",
            "title": "author"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "createdAt"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "updatedAt"
          }
        },
        "required": [
          "id",
          "number",
          "title",
          "comments",
          "reviews",
          "reactions",
          "labels",
          "assignees",
          "author",
          "createdAt",
          "updatedAt"
        ]
      },
      "MyPickIGithub.Labeldescriptionname": {
        "type": "object",
        "properties": {
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          },
          "name": {
            "type": "string",
            "title": "label name"
          }
        },
        "required": [
          "description",
          "name"
        ]
      },
      "IGithub.IFetchRepositoryPullRequestInput": {
        "type": "object",
        "properties": {
          "sort": {
            "oneOf": [
              {
                "const": "CREATED_AT"
              },
              {
                "const": "UPDATED_AT"
              }
            ],
            "title": "sort\nIt must be one of: \"CREATED_AT\", \"UPDATED_AT\"."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "after": {
            "type": "string",
            "title": "after\ncursor of next page"
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "state": {
            "oneOf": [
              {
                "const": "OPEN"
              },
              {
                "const": "CLOSED"
              },
              {
                "const": "MERGED"
              }
            ],
            "title": "state",
            "description": "If you don't want to filter, you don't put anything in.\nIt must be one of: \"OPEN\", \"CLOSED\", \"MERGED\"."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels",
            "description": "If you want to filter the issue by label, pass the string.\nIf it is an empty array, it is ignored."
          },
          "direction": {
            "oneOf": [
              {
                "const": "ASC"
              },
              {
                "const": "DESC"
              }
            ],
            "title": "direction\nIt must be one of: \"ASC\", \"DESC\"."
          }
        },
        "required": [
          "sort",
          "secretKey",
          "owner",
          "repo",
          "direction"
        ]
      },
      "IGithub.DetailedIssue": {
        "type": "object",
        "properties": {
          "milestone": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.MileStone"
              }
            ],
            "title": "milestone"
          },
          "reactions": {
            "type": "object",
            "properties": {
              "total_count": {
                "type": "integer",
                "title": "total_count"
              },
              "+1": {
                "type": "integer",
                "title": "\"+1\""
              },
              "-1": {
                "type": "integer",
                "title": "\"-1\""
              },
              "laugh": {
                "type": "integer",
                "title": "laugh"
              },
              "hooray": {
                "type": "integer",
                "title": "hooray"
              },
              "confused": {
                "type": "integer",
                "title": "confused"
              },
              "heart": {
                "type": "integer",
                "title": "heart"
              },
              "rocket": {
                "type": "integer",
                "title": "rocket"
              },
              "eyes": {
                "type": "integer",
                "title": "eyes"
              }
            },
            "required": [
              "total_count",
              "+1",
              "-1",
              "laugh",
              "hooray",
              "confused",
              "heart",
              "rocket",
              "eyes"
            ],
            "title": "reactions"
          },
          "closed_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin"
              }
            ],
            "title": "closed_by"
          },
          "id": {
            "type": "integer",
            "title": "issue id"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url",
            "description": "If you want to see the issue or pull_request on the web, you can go to this link.\nIf pull is included on this link path, it is pull_request, and if issue is included, it is issue.\nIn essence, pull_request and issue are numbered together from the beginning, so while this connector does not distinguish the two, it can be distinguished by the url path."
          },
          "number": {
            "type": "integer",
            "title": "issue number\n\nNumber uniquely identifying the issue within its repository"
          },
          "state": {
            "type": "string",
            "title": "state\n\nState of the issue; either 'open' or 'closed'"
          },
          "state_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "completed"
              },
              {
                "const": "reopened"
              },
              {
                "const": "not_planned"
              }
            ],
            "title": "state_reason",
            "description": "The reason for the current state"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "title of the issue"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
            "title": "user"
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "body",
            "description": "Contents of the issue\n\nYou can also render this content because it is in a markdown format."
          },
          "labels": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "integer",
                      "title": "id"
                    },
                    "url": {
                      "type": "string",
                      "format": "iri",
                      "title": "url"
                    },
                    "name": {
                      "type": "string",
                      "title": "name"
                    },
                    "description": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "description"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "color"
                    },
                    "default": {
                      "type": "boolean",
                      "title": "default"
                    }
                  },
                  "required": []
                }
              ]
            },
            "title": "labels\n\nLabels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
              }
            ],
            "title": "assignee"
          },
          "assignees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            ],
            "title": "assignees\n\nIf there are many people in charge, you can be included in the array."
          }
        },
        "required": [
          "milestone",
          "reactions",
          "id",
          "html_url",
          "number",
          "state",
          "title",
          "user",
          "labels",
          "assignee"
        ]
      },
      "IGithub.IGetIssueDetailInput": {
        "type": "object",
        "properties": {
          "issue_number": {
            "type": "integer",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repositories/get-issues",
              "jmesPath": "fetchedIssues[].{value:number, label:title}"
            },
            "title": "issue number to get detailed info"
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issue_number",
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetIssueCommentsInput": {
        "type": "object",
        "properties": {
          "issue_number": {
            "type": "integer",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repositories/get-issues",
              "jmesPath": "fetchedIssues[].{value:number, label:title}"
            },
            "title": "issue number to get detailed info"
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "issue_number",
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IFetchRepositoryOutput": {
        "type": "object",
        "properties": {
          "fetchedIssues": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGithub.FetchedIssuebody"
            },
            "title": "issues"
          },
          "pageInfo": {
            "type": "object",
            "properties": {
              "endCursor": {
                "type": "string",
                "title": "Cursor to be used to look up the next page"
              },
              "hasNextPage": {
                "type": "boolean",
                "title": "hasNextPage\n\ntrue if there is a next page"
              }
            },
            "required": [
              "hasNextPage"
            ],
            "title": "page info"
          }
        },
        "required": [
          "fetchedIssues",
          "pageInfo"
        ]
      },
      "StrictOmitIGithub.FetchedIssuebody": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "issue number\n\nNumber uniquely identifying the issue within its repository"
          },
          "title": {
            "type": "string",
            "title": "issue title"
          },
          "id": {
            "type": "string",
            "title": "issue id"
          },
          "comments": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total count of comments"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "comments"
          },
          "author": {
            "$ref": "#/components/schemas/MyPickIGithub.Userlogin",
            "title": "author"
          },
          "state": {
            "oneOf": [
              {
                "const": "OPEN"
              },
              {
                "const": "CLOSED"
              },
              {
                "const": "MERGED"
              }
            ],
            "title": "issue state"
          },
          "labels": {
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Labeldescriptionname"
                },
                "title": "nodes"
              }
            },
            "required": [
              "nodes"
            ],
            "title": "labels"
          },
          "stateReason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "reason of state"
          },
          "reactions": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total count of reactions"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "reactions"
          },
          "assignees": {
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                },
                "title": "nodes"
              }
            },
            "required": [
              "nodes"
            ],
            "title": "assignees"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "createdAt"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "updatedAt"
          }
        },
        "required": [
          "number",
          "title",
          "id",
          "comments",
          "author",
          "labels",
          "reactions",
          "assignees",
          "createdAt",
          "updatedAt"
        ]
      },
      "IGithub.IFetchRepositoryInput": {
        "type": "object",
        "properties": {
          "after": {
            "type": "string",
            "title": "after\ncursor of next page"
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels",
            "description": "If you want to filter the issue by label, pass the string.\nIf it is an empty array, it is ignored."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "state": {
            "oneOf": [
              {
                "const": "OPEN"
              },
              {
                "const": "CLOSED"
              },
              {
                "const": "MERGED"
              }
            ],
            "title": "state",
            "description": "If you don't want to filter, you don't put anything in.\nIt must be one of: \"OPEN\", \"CLOSED\", \"MERGED\"."
          },
          "direction": {
            "oneOf": [
              {
                "const": "ASC"
              },
              {
                "const": "DESC"
              }
            ],
            "title": "direction\nIt must be one of: \"ASC\", \"DESC\"."
          },
          "sort": {
            "oneOf": [
              {
                "const": "CREATED_AT"
              },
              {
                "const": "UPDATED_AT"
              },
              {
                "const": "COMMENTS"
              }
            ],
            "title": "condition of direction\nIt must be one of: \"CREATED_AT\", \"UPDATED_AT\", \"COMMENTS\"."
          },
          "owner": {
            "type": "string",
            "title": "owner's name",
            "description": "The owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "direction",
          "sort",
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.ISearchUserOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.User"
            },
            "title": "User Search Result Item\n\nUser Search Result Item"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.User": {
        "type": "object",
        "properties": {
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to look up your profile, you can access this website."
          },
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "score": {
            "type": "number",
            "title": "score"
          }
        },
        "required": [
          "login",
          "id",
          "avatar_url",
          "html_url",
          "type",
          "score"
        ]
      },
      "IGithub.ISearchUserInput": {
        "type": "object",
        "properties": {
          "q": {
            "type": "string",
            "title": "keyword",
            "description": "The query contains one or more search keywords and qualifiers.\nQualifiers allow you to limit your search to specific areas of GitHub.\nThe REST API supports the same qualifiers as the web interface for GitHub."
          },
          "sort": {
            "oneOf": [
              {
                "const": "followers"
              },
              {
                "const": "repositories"
              },
              {
                "const": "joined"
              }
            ],
            "title": "sorting condition",
            "description": "Sorts the results of your query by number of followers or repositories, or when the person joined GitHub. Default: best match\nIt must be one of this: \"followers\" | \"repositories\" | \"joined\""
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "order": {
            "oneOf": [
              {
                "const": "desc"
              },
              {
                "const": "asc"
              }
            ],
            "title": "order",
            "description": "Determines whether the first search result returned is the highest number of matches (desc) or lowest number of matches (asc).\nThis parameter is ignored unless you provide sort."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "q",
          "secretKey"
        ]
      },
      "IGithub.IGetUserProfileOutput": {
        "type": "object",
        "properties": {
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "name\nIt means the actual name that the user has written, not the user's nickname."
          },
          "company": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "comany name",
            "description": "As the name of the company,\nit cannot be said to be the exact name listed as the business operator because it was written by the user himself.\nAlso, we cannot guarantee that the user wrote the company name.\nSometimes the user jokingly writes down strange names."
          },
          "blog": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "blog\n\nIndicates the blog address."
          },
          "location": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "location",
            "description": "It means the location of the user.\nUsually, I write the country down, but the user can jokingly record the strange location."
          },
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "email address"
          },
          "bio": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "bio\n\nWrite down what the user wants to say or a history."
          },
          "twitter_username": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "twitter_username"
          },
          "public_repos": {
            "type": "integer",
            "title": "count of public repos"
          },
          "public_gists": {
            "type": "integer",
            "title": "count of public gists"
          },
          "followers": {
            "type": "integer",
            "title": "count of followers"
          },
          "following": {
            "type": "integer",
            "title": "count of follwing"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "profile_repository": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RepositoryreadmeIGetReadmeFileContentOutput"
              }
            ],
            "title": "profile_repo"
          },
          "pinned_repositories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "pinned_repositories\nIt is a repository where the user puts a pin on his profile, which is usually used to display his or her proud history."
          },
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "public_repos",
          "public_gists",
          "followers",
          "following",
          "created_at",
          "updated_at",
          "profile_repository",
          "pinned_repositories",
          "id",
          "type",
          "login",
          "avatar_url"
        ]
      },
      "RepositoryreadmeIGetReadmeFileContentOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "full_name": {
            "type": "string",
            "title": "full_name\n\nThis is in the form '{username}/{reponame}'."
          },
          "private": {
            "type": "boolean",
            "title": "private"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          },
          "fork": {
            "type": "boolean",
            "title": "fork"
          },
          "forks_count": {
            "type": "integer",
            "title": "forks_count"
          },
          "stargazers_count": {
            "type": "integer",
            "title": "stargazers_count"
          },
          "watchers_count": {
            "type": "integer",
            "title": "watchers_count"
          },
          "size": {
            "type": "number",
            "title": "size"
          },
          "default_branch": {
            "type": "string",
            "title": "default_branch"
          },
          "open_issues_count": {
            "type": "integer",
            "title": "open_issues_count"
          },
          "is_template": {
            "type": "boolean",
            "title": "is_template"
          },
          "topics": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "topics"
          },
          "has_issues": {
            "type": "boolean",
            "title": "has_issues"
          },
          "has_projects": {
            "type": "boolean",
            "title": "has_projects"
          },
          "has_wiki": {
            "type": "boolean",
            "title": "has_wiki"
          },
          "has_pages": {
            "type": "boolean",
            "title": "has_pages"
          },
          "has_downloads": {
            "type": "boolean",
            "title": "has_downloads"
          },
          "archived": {
            "type": "boolean",
            "title": "archived"
          },
          "disabled": {
            "type": "boolean",
            "title": "disabled"
          },
          "visibility": {
            "oneOf": [
              {
                "const": "private"
              },
              {
                "const": "public"
              }
            ],
            "title": "visibility"
          },
          "pushed_at": {
            "type": "string",
            "format": "date-time",
            "title": "pushed_at"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "permissions": {
            "type": "object",
            "properties": {
              "admin": {
                "type": "boolean",
                "title": "admin"
              },
              "push": {
                "type": "boolean",
                "title": "push"
              },
              "pull": {
                "type": "boolean",
                "title": "pull"
              }
            },
            "required": [
              "admin",
              "push",
              "pull"
            ],
            "title": "permissions"
          },
          "allow_rebase_merge": {
            "type": "boolean",
            "title": "allow_rebase_merge"
          },
          "allow_squash_merge": {
            "type": "boolean",
            "title": "allow_squash_merge"
          },
          "allow_auto_merge": {
            "type": "boolean",
            "title": "allow_auto_merge"
          },
          "delete_branch_on_merge": {
            "type": "boolean",
            "title": "delete_branch_on_merge"
          },
          "allow_merge_commit": {
            "type": "boolean",
            "title": "allow_merge_commit"
          },
          "subscribers_count": {
            "type": "integer",
            "title": "subscribers_count"
          },
          "network_count": {
            "type": "integer",
            "title": "network_count"
          },
          "license": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-placeholder": "mit",
                    "title": "key"
                  },
                  "name": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT License",
                    "title": "name"
                  },
                  "url": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "x-wrtn-placeholder": "https://api.github.com/licenses/mit"
                      }
                    ],
                    "title": "url"
                  },
                  "spdx_id": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT",
                    "title": "spdx_id"
                  }
                },
                "required": [
                  "key",
                  "name",
                  "url",
                  "spdx_id"
                ]
              }
            ],
            "title": "license"
          },
          "forks": {
            "type": "integer",
            "title": "forks"
          },
          "open_issues": {
            "type": "integer",
            "title": "open_issues"
          },
          "watchers": {
            "type": "integer",
            "title": "watchers"
          },
          "readme": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.RepositoryFile"
              }
            ],
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "file": "#/components/schemas/IGithub.RepositoryFile"
              }
            }
          }
        },
        "required": [
          "id",
          "name",
          "full_name",
          "private",
          "html_url",
          "description",
          "fork",
          "forks_count",
          "stargazers_count",
          "watchers_count",
          "size",
          "default_branch",
          "open_issues_count",
          "is_template",
          "topics",
          "has_issues",
          "has_projects",
          "has_wiki",
          "has_pages",
          "has_downloads",
          "archived",
          "disabled",
          "visibility",
          "pushed_at",
          "created_at",
          "updated_at",
          "license",
          "forks",
          "open_issues",
          "watchers",
          "readme"
        ]
      },
      "IGithub.IGetUserProfileInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "username"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetAuthenticatedUserOrganizationOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Organization"
            },
            "title": "result"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.IGetAuthenticatedUserOrganizationInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IGithub.IGetBranchOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Branch"
            },
            "title": "branches"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Branch": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name of Branch"
          },
          "commit": {
            "$ref": "#/components/schemas/StrictOmitIGithub.Commitsha",
            "title": "commit",
            "description": "In github, branch is just another name for the last node of a commit,\nso this property called commit is logically the same as what it means for that branch."
          }
        },
        "required": [
          "name",
          "commit"
        ]
      },
      "IGithub.IGetBranchInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.ICreateBranchOutput": {
        "type": "object",
        "properties": {
          "ref": {
            "type": "string",
            "x-wrtn-placeholder": "refs/heads/featureA",
            "title": "ref"
          },
          "object": {
            "type": "object",
            "properties": {
              "type": {
                "const": "commit",
                "title": "type"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              }
            },
            "required": [
              "type",
              "sha"
            ],
            "title": "object"
          }
        },
        "required": [
          "ref",
          "object"
        ]
      },
      "IGithub.ICreateBranchInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "ref": {
            "type": "string",
            "title": "ref\nThe name of the fully qualified reference (ie: refs/heads/master). If it doesn't start with 'refs' and have at least two slashes, it will be rejected."
          },
          "sha": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-commit-list",
              "jmesPath": "result[].{value:sha, label: commit.message}"
            },
            "title": "sha\nThe SHA1 value for this reference."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "ref",
          "sha",
          "secretKey"
        ]
      },
      "StrictOmitIGithub.PullRequestcommentsmaintainer_can_modifymergeablerebaseablemergeable_statemerged_byreview_commentscommitsadditionsdeletionschanged_files": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "number of this pull request"
          },
          "title": {
            "type": "string",
            "title": "title",
            "description": "title of the issue"
          },
          "base": {
            "type": "object",
            "properties": {
              "label": {
                "type": "string",
                "title": "label"
              },
              "ref": {
                "type": "string",
                "title": "ref"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "user": {
                "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
                "title": "user"
              },
              "repo": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/MyPickIGithub.Repositoryfull_name"
                  }
                ],
                "title": "repo"
              }
            },
            "required": [
              "label",
              "ref",
              "sha",
              "user",
              "repo"
            ],
            "title": "base branch info"
          },
          "head": {
            "type": "object",
            "properties": {
              "label": {
                "type": "string",
                "title": "label"
              },
              "ref": {
                "type": "string",
                "title": "ref"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "user": {
                "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
                "title": "user"
              },
              "repo": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/MyPickIGithub.Repositoryfull_name"
                  }
                ],
                "title": "repo"
              }
            },
            "required": [
              "label",
              "ref",
              "sha",
              "user",
              "repo"
            ],
            "title": "head branch info"
          },
          "id": {
            "type": "integer",
            "title": "issue id"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin",
            "title": "user"
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "body",
            "description": "Contents of the issue\n\nYou can also render this content because it is in a markdown format."
          },
          "state": {
            "type": "string",
            "title": "state\n\nState of the issue; either 'open' or 'closed'"
          },
          "labels": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "integer",
                      "title": "id"
                    },
                    "url": {
                      "type": "string",
                      "format": "iri",
                      "title": "url"
                    },
                    "name": {
                      "type": "string",
                      "title": "name"
                    },
                    "description": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "description"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "title": "color"
                    },
                    "default": {
                      "type": "boolean",
                      "title": "default"
                    }
                  },
                  "required": []
                }
              ]
            },
            "title": "labels\n\nLabels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"
          },
          "assignees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            ],
            "title": "assignees\n\nIf there are many people in charge, you can be included in the array."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url",
            "description": "If you want to see the issue or pull_request on the web, you can go to this link.\nIf pull is included on this link path, it is pull_request, and if issue is included, it is issue.\nIn essence, pull_request and issue are numbered together from the beginning, so while this connector does not distinguish the two, it can be distinguished by the url path."
          },
          "draft": {
            "type": "boolean",
            "title": "draft\n\nIndicates whether or not the pull request is a draft."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "milestone": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.MileStone"
              }
            ],
            "title": "milestone"
          },
          "author_association": {
            "oneOf": [
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "NONE"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          },
          "requested_reviewers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Useridtypelogin"
            },
            "title": "requested_reviewers"
          },
          "requested_teams": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartialIGithub.Team"
            },
            "title": "requested_teams"
          },
          "auto_merge": {
            "title": "auto_merge"
          },
          "merged": {
            "type": "boolean",
            "title": "merged"
          },
          "locked": {
            "type": "boolean",
            "title": "locked"
          },
          "closed_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "closed_at"
          },
          "merged_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "merged_at"
          },
          "state_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "completed"
              },
              {
                "const": "reopened"
              },
              {
                "const": "not_planned"
              }
            ],
            "title": "state_reason",
            "description": "The reason for the current state"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
              }
            ],
            "title": "assignee"
          }
        },
        "required": [
          "number",
          "title",
          "base",
          "head",
          "id",
          "created_at",
          "user",
          "state",
          "labels",
          "html_url",
          "updated_at",
          "milestone",
          "author_association",
          "requested_reviewers",
          "requested_teams",
          "auto_merge",
          "locked",
          "closed_at",
          "merged_at",
          "assignee"
        ]
      },
      "IGithub.IGetPullRequestInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "commit_sha": {
            "type": "string",
            "title": "commit_sha\n\nThe SHA of the commit."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "commit_sha",
          "secretKey"
        ]
      },
      "IGithub.IGetCommitHeadOutput": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "title": "sha"
          },
          "commit": {
            "$ref": "#/components/schemas/MyPickIGithub.Commitmessageurlauthorcommittertreecomment_count",
            "title": "commit"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.File"
            },
            "title": "files"
          }
        },
        "required": [
          "sha",
          "commit",
          "files"
        ]
      },
      "MyPickIGithub.Commitmessageurlauthorcommittertreecomment_count": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "title": "commit message"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "uri\n\nuri to look up details of commitment"
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name"
              },
              "email": {
                "type": "string",
                "title": "email"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "author"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name"
              },
              "email": {
                "type": "string",
                "title": "email"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "committer"
          },
          "tree": {
            "type": "object",
            "properties": {
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url"
              }
            },
            "required": [
              "sha",
              "url"
            ],
            "title": "tree"
          },
          "comment_count": {
            "type": "integer",
            "title": "comment_count"
          }
        },
        "required": [
          "message",
          "url",
          "author",
          "committer",
          "tree",
          "comment_count"
        ]
      },
      "IGithub.IGetCommitHeadInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "commit_sha": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-commit-list",
              "jmesPath": "result[].{value:sha, label:comment.message}"
            },
            "title": "commit_sha\n\nThe SHA of the commit."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "commit_sha",
          "secretKey"
        ]
      },
      "IGithub.IGetCommitOutput": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "title": "hash of this commit"
          },
          "commit": {
            "$ref": "#/components/schemas/StrictOmitIGithub.Commitsha",
            "title": "commit"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "parents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Commitsha"
            },
            "title": "Parents of this commit"
          },
          "stats": {
            "type": "object",
            "properties": {
              "total": {
                "type": "integer",
                "title": "sum of additions and deletions"
              },
              "additions": {
                "type": "integer",
                "title": "lines of additions"
              },
              "deletions": {
                "type": "integer",
                "title": "lines of deletions"
              }
            },
            "required": [
              "total",
              "additions",
              "deletions"
            ],
            "title": "stats"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.File"
            },
            "title": "files\n\nYou can see the changes for each file."
          }
        },
        "required": [
          "sha",
          "commit",
          "html_url",
          "parents",
          "stats",
          "files"
        ]
      },
      "MyPickIGithub.Commitsha": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "title": "hash of this commit"
          }
        },
        "required": [
          "sha"
        ]
      },
      "IGithub.IGetCommitInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "ref": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-branches",
              "jmesPath": "result[].{value:name, label:name}"
            },
            "title": "commit hash or branch name"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetCommitListOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "sha": {
                  "type": "string",
                  "title": "sha"
                },
                "commit": {
                  "$ref": "#/components/schemas/MyPickIGithub.Commitmessageurlauthorcommitter",
                  "title": "commit"
                }
              },
              "required": [
                "sha",
                "commit"
              ]
            },
            "title": "commit list"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "MyPickIGithub.Commitmessageurlauthorcommitter": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "title": "commit message"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "uri\n\nuri to look up details of commitment"
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name"
              },
              "email": {
                "type": "string",
                "title": "email"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "author"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name"
              },
              "email": {
                "type": "string",
                "title": "email"
              },
              "date": {
                "type": "string",
                "format": "date-time",
                "title": "date"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "committer"
          }
        },
        "required": [
          "message",
          "url",
          "author",
          "committer"
        ]
      },
      "IGithub.IGetCommitListInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "sha": {
            "type": "string",
            "title": "sha\n\nSHA or branch to start listing commits from. Default: the repository’s default branch (usually main)."
          },
          "path": {
            "type": "string",
            "title": "path\n\nOnly commits containing this file path will be returned."
          },
          "author": {
            "type": "string",
            "title": "author\n\nGitHub username or email address to use to filter by commit author."
          },
          "committer": {
            "type": "string",
            "title": "committer\n\nGitHub username or email address to use to filter by commit committer."
          },
          "since": {
            "type": "string",
            "format": "date-time",
            "title": "since\n\nOnly show results that were last updated after the given time. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned."
          },
          "until": {
            "type": "string",
            "format": "date-time",
            "title": "until\n\nOnly commits before this date will be returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "order": {
            "oneOf": [
              {
                "const": "desc"
              },
              {
                "const": "asc"
              }
            ],
            "title": "order",
            "description": "Determines whether the first search result returned is the highest number of matches (desc) or lowest number of matches (asc).\nThis parameter is ignored unless you provide sort."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetFollowerOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Useridloginhtml_urlavatar_url"
            },
            "title": "followers"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "MyPickIGithub.Useridloginhtml_urlavatar_url": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login",
            "description": "This means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to look up your profile, you can access this website."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "id",
          "login",
          "html_url",
          "avatar_url"
        ]
      },
      "IGithub.IGetFollowerInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "order": {
            "oneOf": [
              {
                "const": "desc"
              },
              {
                "const": "asc"
              }
            ],
            "title": "order",
            "description": "Determines whether the first search result returned is the highest number of matches (desc) or lowest number of matches (asc).\nThis parameter is ignored unless you provide sort."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetFolloweeOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Useridloginhtml_urlavatar_url"
            },
            "title": "followees"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.IGetFolloweeInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "order": {
            "oneOf": [
              {
                "const": "desc"
              },
              {
                "const": "asc"
              }
            ],
            "title": "order",
            "description": "Determines whether the first search result returned is the highest number of matches (desc) or lowest number of matches (asc).\nThis parameter is ignored unless you provide sort."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetLabelOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Label"
            },
            "title": "result"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page",
            "description": "However, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first",
            "description": "If this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Label": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "label name"
          },
          "color": {
            "type": "string",
            "title": "color"
          },
          "default": {
            "type": "boolean",
            "title": "default\n\nTrue if it is not created by the user but automatically created from the beginning."
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          }
        },
        "required": [
          "name",
          "color",
          "default",
          "description"
        ]
      },
      "IGithub.IGetLabelInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page",
            "description": "The page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page",
            "description": "The number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IUpdateIssueInput": {
        "type": "object",
        "properties": {
          "issue_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/github/issues",
                  "jmesPath": "{label:number, value:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/github/issues",
                  "jmesPath": "result[].{label:number, value:title}"
                }
              }
            ],
            "title": "issue number to update"
          },
          "title": {
            "type": "string",
            "title": "tite of this issue"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "body": {
            "type": "string",
            "title": "body of this issue",
            "description": "It can be markdown format\nIf you provide text in utf-8 format, which can be recognized by a person, in markdown format, it will be written as it is."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels"
          },
          "assignees": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/github/repos/get-collaborators",
                "jmesPath": "result[].{value:login, label:login}"
              }
            },
            "title": "assignees\n\nDeliver the user nickname to be designated as the person in charge in the array."
          }
        },
        "required": [
          "issue_number",
          "secretKey",
          "owner",
          "repo"
        ]
      },
      "IGithub.ICreateIssueInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "title": {
            "type": "string",
            "title": "tite of this issue"
          },
          "body": {
            "type": "string",
            "title": "body of this issue",
            "description": "It can be markdown format\nIf you provide text in utf-8 format, which can be recognized by a person, in markdown format, it will be written as it is."
          },
          "assignees": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/github/repos/get-collaborators",
                "jmesPath": "result[].{value:login, label:login}"
              }
            },
            "title": "assignees\n\nDeliver the user nickname to be designated as the person in charge in the array."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "title",
          "secretKey"
        ]
      },
      "IMarp.IConvertOutput": {
        "type": "object",
        "properties": {
          "s3Link": {
            "type": "string",
            "title": "S3 link",
            "description": "S3 link for the converted PPT."
          }
        },
        "required": [
          "s3Link"
        ],
        "title": "Marp conversion output"
      },
      "IMarp.IConvertInput": {
        "type": "object",
        "properties": {
          "markdown": {
            "type": "string",
            "title": "Marp markdown",
            "description": "Marp markdown input string."
          }
        },
        "required": [
          "markdown"
        ],
        "title": "Parameters for Marp conversion"
      },
      "IX.IUserOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "User ID",
            "description": "The unique id of the user"
          },
          "name": {
            "type": "string",
            "title": "name",
            "description": "The display name of the user"
          },
          "userName": {
            "type": "string",
            "title": "user name",
            "description": "The user name of user"
          }
        },
        "required": [
          "id",
          "name",
          "userName"
        ],
        "title": "User Information data"
      },
      "IX.IUserInput": {
        "type": "object",
        "properties": {
          "userName": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "title": "Twitter user name",
            "description": "User name for search"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "x",
            "x-wrtn-secret-scopes": [
              "tweet.read",
              "tweet.write",
              "users.read",
              "follows.read",
              "list.read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "userName",
          "secretKey"
        ],
        "title": "User Search Condition"
      },
      "IX.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "x",
            "x-wrtn-secret-scopes": [
              "tweet.read",
              "tweet.write",
              "users.read",
              "follows.read",
              "list.read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IX.IPrePareSummarizeTweetOutput": {
        "type": "object",
        "properties": {
          "chatId": {
            "type": "string",
            "title": "chat id",
            "description": "Chat id required for RAG generation results.\nReturns the chat id for the analyzed file to generate chat results for the file analyzed by RAG.\nThe same chat id is required to analyze multiple files and generate results for multiple files in the same chat."
          }
        },
        "required": [
          "chatId"
        ],
        "title": "Prepare Summarize tweet results"
      },
      "IX.IPrePareSummarizeTweetInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "x",
            "x-wrtn-secret-scopes": [
              "tweet.read",
              "tweet.write",
              "users.read",
              "follows.read",
              "list.read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "user": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "x-wrtn-prerequisite": {
                    "method": "post",
                    "path": "/connector/x/get-users",
                    "jmesPath": "[].{value:id, label:userName}"
                  },
                  "title": "user id",
                  "description": "The unique id of the user for search user tweet time line"
                },
                "name": {
                  "type": "string",
                  "x-wrtn-prerequisite": {
                    "method": "post",
                    "path": "/connector/x/get-users",
                    "jmesPath": "[].{value:name, label:name}"
                  },
                  "title": "user name",
                  "description": "The original user name"
                },
                "userName": {
                  "type": "string",
                  "x-wrtn-prerequisite": {
                    "method": "post",
                    "path": "/connector/x/get-users",
                    "jmesPath": "[].{value:userName, label:userName}"
                  },
                  "title": "twitter user name",
                  "description": "The user name of twitter"
                }
              },
              "required": [
                "id",
                "name",
                "userName"
              ]
            },
            "title": "user",
            "description": "User information for search user tweet time line"
          }
        },
        "required": [
          "secretKey",
          "user"
        ]
      },
      "IX.IGetChunkDocumentOutput": {
        "type": "object",
        "properties": {
          "documents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "title": "id",
                  "description": "Chunk document id"
                },
                "text": {
                  "type": "string",
                  "title": "text",
                  "description": "Chunk document text"
                },
                "score": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "number"
                    }
                  ],
                  "title": "score",
                  "description": "Chunk document score"
                },
                "image": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "image",
                  "description": "Chunk document image"
                },
                "metadata": {
                  "title": "metadata",
                  "description": "Chunk document metadata"
                }
              },
              "required": [
                "id",
                "text",
                "score",
                "image",
                "metadata"
              ]
            },
            "title": "Chunk Document List",
            "description": "Chunk Document List"
          }
        },
        "required": [
          "documents"
        ]
      },
      "IX.ISummarizeTweetInput": {
        "type": "object",
        "properties": {
          "chatId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/x/prepare-summarize",
              "jmesPath": "{value:chatId, label:chatId}"
            },
            "title": "chatId",
            "description": "\"chatId\" to get tweets. Pass the \"chatId\" obtained from the \"prepare-summarize-tweet\" API as-is."
          },
          "query": {
            "type": "string",
            "title": "query",
            "description": "A query that describes what tweets you want to get. For example, it can be a keyword or a name of a person.\n\nAvoid using a query that is too broad, it may lead to irrelevant results.\n\nPut a single subject at a time. If you need multiple subjects, must make multiple requests for each subject no exceptions."
          }
        },
        "required": [
          "chatId",
          "query"
        ],
        "title": "Information needed for tweet summary"
      },
      "IX.IGeneralSearchResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "tweet ID",
            "description": "The unique id of the tweet"
          },
          "userName": {
            "type": "string",
            "title": "user name",
            "description": "The user name of the tweet"
          },
          "text": {
            "type": "string",
            "title": "tweet content",
            "description": "The content text of the tweet"
          },
          "tweet_link": {
            "type": "string",
            "format": "iri",
            "title": "tweet link",
            "description": "The link of the tweet"
          },
          "metric": {
            "$ref": "#/components/schemas/IX.IMetric",
            "title": "metric",
            "description": "Metric data for the tweet"
          },
          "thumbnail": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "thumbnail",
            "description": "Thumbnail Image URL of the tweet"
          }
        },
        "required": [
          "id",
          "userName",
          "text",
          "tweet_link",
          "metric",
          "thumbnail"
        ],
        "title": "Tweet Search Result"
      },
      "IX.IMetric": {
        "type": "object",
        "properties": {
          "retweet_count": {
            "type": "integer",
            "title": "Retweet Count"
          },
          "reply_count": {
            "type": "integer",
            "title": "Reply Count",
            "description": "Indicates how many replies a tweet has."
          },
          "like_count": {
            "type": "integer",
            "title": "Like Count",
            "description": "Indicates how many likes a tweet has received."
          },
          "quote_count": {
            "type": "integer",
            "title": "Quote Count",
            "description": "Indicates how many times a tweet has been quoted."
          },
          "bookmark_count": {
            "type": "integer",
            "title": "Bookmark Count",
            "description": "Indicates how many times a tweet has been bookmarked."
          },
          "impression_count": {
            "type": "integer",
            "title": "Impression Count",
            "description": "Indicates how many times a tweet has been viewed."
          }
        },
        "required": [
          "retweet_count",
          "reply_count",
          "like_count",
          "quote_count",
          "bookmark_count",
          "impression_count"
        ],
        "title": "Metric for tweet"
      },
      "IX.IGeneralSearchRequest": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "title": "search query",
            "description": "Get tweets by query.\n\nThe query should be entered in natural language.\n\nFor example, if the user asks \"Search for what books are trending on Twitter these days,\" the query should be \"trending books.\""
          },
          "lang": {
            "type": "string",
            "title": "Tweet Settings Language",
            "description": "Matches posts categorized by X in a specific language.\n\nYou can only pass a single BCP 47 language identifier.\n\nex) You want to setting korean language, you can pass \"ko\"."
          },
          "maxResults": {
            "type": "integer",
            "default": 10,
            "title": "Maximum number of search results.",
            "description": "Sets the maximum number of results to be searched."
          },
          "sort_order": {
            "oneOf": [
              {
                "const": "recency"
              },
              {
                "const": "relevancy"
              }
            ],
            "title": "Sort order",
            "description": "Determines the sort order.\n- recency: newest\n- relevancy: relevance"
          },
          "start_time": {
            "type": "string",
            "format": "date-time",
            "title": "Start time for search tweet",
            "description": "The oldest UTC timestamp from which the Tweets will be provided.\n\nBy default, a request will return Tweets from up to 30 days ago if you do not include this parameter."
          },
          "end_time": {
            "type": "string",
            "format": "date-time",
            "title": "End time for search tweet",
            "description": "Used with start_time. The newest, most recent UTC timestamp to which the Tweets will be provided.\n\nIf used without start_time, Tweets from 30 days before end_time will be returned by default. If not specified, end_time will default to [now - 30 seconds]."
          },
          "isExcludeRetweet": {
            "type": "boolean",
            "title": "Whether to remove retweets",
            "description": "Sets whether to remove retweeted tweets from search results."
          },
          "isExcludeReply": {
            "type": "boolean",
            "title": "Whether to remove replies",
            "description": "Sets whether to remove replied tweets from search results."
          },
          "isExcludeQuote": {
            "type": "boolean",
            "title": "Whether to remove quotes",
            "description": "Sets whether to remove quoted tweets from search results."
          }
        },
        "required": [
          "query",
          "lang",
          "maxResults",
          "sort_order"
        ],
        "title": "Tweet Search Condition"
      },
      "IReddit.IGetHotPostsOutput": {
        "type": "object",
        "properties": {
          "after": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The after cursor for pagination"
          },
          "dist": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The number of items returned"
          },
          "modhash": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The modhash for the request"
          },
          "geo_filter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The geographical filter applied"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Children"
            },
            "title": "The list of children posts"
          },
          "before": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The before cursor for pagination"
          }
        },
        "required": [
          "after",
          "dist",
          "modhash",
          "geo_filter",
          "children",
          "before"
        ]
      },
      "IReddit.Children": {
        "type": "object",
        "properties": {
          "kind": {
            "type": "string",
            "title": "The kind of the child"
          },
          "data": {
            "$ref": "#/components/schemas/IReddit.Child",
            "title": "The data of the child"
          }
        },
        "required": [
          "kind",
          "data"
        ]
      },
      "IReddit.Child": {
        "type": "object",
        "properties": {
          "approved_at_utc": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Approval time in UTC"
          },
          "subreddit": {
            "type": "string",
            "title": "The subreddit name"
          },
          "selftext": {
            "type": "string",
            "title": "The text of the post"
          },
          "author_fullname": {
            "type": "string",
            "pattern": "^(t2_(.*))",
            "title": "The full name of the author"
          },
          "saved": {
            "type": "boolean",
            "title": "Whether the post is saved"
          },
          "mod_reason_title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator reason title"
          },
          "gilded": {
            "type": "integer",
            "title": "Number of times gilded"
          },
          "clicked": {
            "type": "boolean",
            "title": "Whether the post is clicked"
          },
          "title": {
            "type": "string",
            "title": "The title of the post"
          },
          "link_flair_richtext": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.LinkFlairRichtext"
            },
            "title": "Rich text for link flair"
          },
          "subreddit_name_prefixed": {
            "type": "string",
            "title": "Prefixed subreddit name"
          },
          "hidden": {
            "type": "boolean",
            "title": "Whether the post is hidden"
          },
          "pwls": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Post whitelist status"
          },
          "link_flair_css_class": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "CSS class for link flair"
          },
          "downs": {
            "type": "integer",
            "title": "Number of downvotes"
          },
          "thumbnail_height": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Height of the thumbnail"
          },
          "top_awarded_type": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Type of top award"
          },
          "hide_score": {
            "type": "boolean",
            "title": "Whether the score is hidden"
          },
          "name": {
            "type": "string",
            "title": "The name of the post"
          },
          "quarantine": {
            "type": "boolean",
            "title": "Whether the post is quarantined"
          },
          "link_flair_text_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text color for link flair"
          },
          "upvote_ratio": {
            "type": "number",
            "title": "Ratio of upvotes"
          },
          "author_flair_background_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Background color for author flair"
          },
          "ups": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Number of upvotes"
          },
          "total_awards_received": {
            "type": "number",
            "title": "Total awards received"
          },
          "media_embed": {
            "$ref": "#/components/schemas/IReddit.MediaEmbed",
            "title": "Media embed information"
          },
          "thumbnail_width": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Width of the thumbnail"
          },
          "author_flair_template_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "uuid"
              }
            ],
            "title": "Template ID for author flair"
          },
          "is_original_content": {
            "type": "boolean",
            "title": "Whether the content is original"
          },
          "user_reports": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "User reports"
          },
          "secure_media": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.SecureMedia"
              }
            ],
            "title": "Secure media information"
          },
          "is_reddit_media_domain": {
            "type": "boolean",
            "title": "Whether it's a Reddit media domain"
          },
          "is_meta": {
            "type": "boolean",
            "title": "Whether it's meta content"
          },
          "category": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Category of the post"
          },
          "secure_media_embed": {
            "$ref": "#/components/schemas/IReddit.SecureMediaEmbed",
            "title": "Secure media embed information"
          },
          "link_flair_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text for link flair"
          },
          "can_mod_post": {
            "type": "boolean",
            "title": "Whether the post can be moderated"
          },
          "score": {
            "type": "number",
            "title": "Score of the post"
          },
          "approved_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Approved by user"
          },
          "is_created_from_ads_ui": {
            "type": "boolean",
            "title": "Whether created from ads UI"
          },
          "author_premium": {
            "type": "boolean",
            "title": "Whether the author is premium"
          },
          "thumbnail": {
            "type": "string",
            "title": "Thumbnail URL"
          },
          "edited": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the post is edited"
          },
          "author_flair_css_class": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "CSS class for author flair"
          },
          "author_flair_richtext": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.AuthorFlairRichtext"
            },
            "title": "Rich text for author flair"
          },
          "gildings": {
            "title": "Gildings information"
          },
          "post_hint": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Hint for the post"
          },
          "content_categories": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "Content categories"
          },
          "is_self": {
            "type": "boolean",
            "title": "Whether it's a self post"
          },
          "subreddit_type": {
            "type": "string",
            "title": "Type of subreddit"
          },
          "created": {
            "type": "number",
            "title": "Creation time"
          },
          "link_flair_type": {
            "type": "string",
            "title": "Type of link flair"
          },
          "wls": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Whitelist status"
          },
          "removed_by_category": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Removed by category"
          },
          "banned_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Banned by user"
          },
          "author_flair_type": {
            "type": "string",
            "title": "Type of author flair"
          },
          "domain": {
            "type": "string",
            "title": "Domain of the post"
          },
          "allow_live_comments": {
            "type": "boolean",
            "title": "Whether live comments are allowed"
          },
          "selftext_html": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "HTML of the selftext"
          },
          "likes": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Likes on the post"
          },
          "suggested_sort": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Suggested sort order"
          },
          "banned_at_utc": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Banned time in UTC"
          },
          "url_overridden_by_dest": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "URL overridden by destination"
          },
          "view_count": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "View count"
          },
          "archived": {
            "type": "boolean",
            "title": "Whether the post is archived"
          },
          "no_follow": {
            "type": "boolean",
            "title": "Whether no-follow is enabled"
          },
          "is_crosspostable": {
            "type": "boolean",
            "title": "Whether the post is crosspostable"
          },
          "pinned": {
            "type": "boolean",
            "title": "Whether the post is pinned"
          },
          "over_18": {
            "type": "boolean",
            "title": "Whether the post is NSFW"
          },
          "preview": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.Preview"
              }
            ],
            "title": "Preview information"
          },
          "all_awardings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "All awardings"
          },
          "awarders": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Awarders of the post"
          },
          "media_only": {
            "type": "boolean",
            "title": "Whether it's media only"
          },
          "link_flair_template_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Template ID for link flair"
          },
          "can_gild": {
            "type": "boolean",
            "title": "Whether the post can be gilded"
          },
          "spoiler": {
            "type": "boolean",
            "title": "Whether the post is a spoiler"
          },
          "locked": {
            "type": "boolean",
            "title": "Whether the post is locked"
          },
          "author_flair_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text for author flair"
          },
          "treatment_tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Treatment tags"
          },
          "visited": {
            "type": "boolean",
            "title": "Whether the post is visited"
          },
          "removed_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Removed by user"
          },
          "mod_note": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator note"
          },
          "distinguished": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Distinguished status"
          },
          "subreddit_id": {
            "type": "string",
            "title": "ID of the subreddit"
          },
          "author_is_blocked": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the author is blocked"
          },
          "mod_reason_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator reason by user"
          },
          "num_reports": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Number of reports"
          },
          "removal_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Removal reason"
          },
          "link_flair_background_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Background color for link flair"
          },
          "id": {
            "type": "string",
            "title": "ID of the post"
          },
          "is_robot_indexable": {
            "type": "boolean",
            "title": "Whether the post is robot indexable"
          },
          "report_reasons": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Report reasons"
          },
          "author": {
            "type": "string",
            "title": "Author of the post"
          },
          "discussion_type": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Type of discussion"
          },
          "num_comments": {
            "type": "number",
            "title": "Number of comments"
          },
          "send_replies": {
            "type": "boolean",
            "title": "Whether to send replies"
          },
          "contest_mode": {
            "type": "boolean",
            "title": "Whether contest mode is enabled"
          },
          "mod_reports": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Moderator reports"
          },
          "author_patreon_flair": {
            "type": "boolean",
            "title": "Whether the author has Patreon flair"
          },
          "author_flair_text_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text color for author flair"
          },
          "permalink": {
            "type": "string",
            "title": "Permalink to the post"
          },
          "stickied": {
            "type": "boolean",
            "title": "Whether the post is stickied"
          },
          "url": {
            "type": "string",
            "title": "URL of the post"
          },
          "subreddit_subscribers": {
            "type": "number",
            "title": "Number of subreddit subscribers"
          },
          "created_utc": {
            "type": "integer",
            "title": "Creation time in UTC"
          },
          "num_crossposts": {
            "type": "number",
            "title": "Number of crossposts"
          },
          "media": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.Media"
              }
            ],
            "title": "Media information"
          },
          "is_video": {
            "type": "boolean",
            "title": "Whether the post is a video"
          },
          "is_gallery": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the post is a gallery"
          },
          "media_metadata": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.MediaMetadata"
              }
            ],
            "title": "Media metadata"
          },
          "gallery_data": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.GalleryData"
              }
            ],
            "title": "Gallery data"
          },
          "crosspost_parent_list": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IReddit.CrosspostParentList"
                }
              }
            ],
            "title": "List of crosspost parents"
          },
          "crosspost_parent": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Crosspost parent"
          },
          "author_cakeday": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether it's the author's cakeday"
          }
        },
        "required": [
          "title",
          "name",
          "id",
          "url"
        ]
      },
      "IReddit.LinkFlairRichtext": {
        "type": "object",
        "properties": {
          "a": {
            "type": "string",
            "title": "The type of the element"
          },
          "u": {
            "type": "string",
            "title": "The type of the element"
          },
          "e": {
            "type": "string",
            "title": "The type of the element"
          },
          "t": {
            "type": "string",
            "title": "The text of the element"
          }
        },
        "required": []
      },
      "IReddit.MediaEmbed": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "title": "The content of the media"
          },
          "width": {
            "type": "number",
            "title": "The width of the media"
          },
          "scrolling": {
            "type": "boolean",
            "title": "Whether scrolling is enabled"
          },
          "height": {
            "type": "number",
            "title": "The height of the media"
          }
        },
        "required": []
      },
      "IReddit.SecureMedia": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "title": "The type of the media"
          },
          "oembed": {
            "$ref": "#/components/schemas/IReddit.Oembed",
            "title": "Oembed information"
          }
        },
        "required": []
      },
      "IReddit.Oembed": {
        "type": "object",
        "properties": {
          "provider_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The provider URL"
          },
          "version": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The version of the Oembed"
          },
          "title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The title of the Oembed"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The description of the Oembed"
          },
          "type": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The type of the Oembed"
          },
          "thumbnail_width": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The width of the thumbnail"
          },
          "height": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The height of the Oembed"
          },
          "width": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The width of the Oembed"
          },
          "html": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The HTML content"
          },
          "author_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The name of the author"
          },
          "provider_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The name of the provider"
          },
          "thumbnail_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The URL of the thumbnail"
          },
          "thumbnail_height": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The height of the thumbnail"
          },
          "author_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The URL of the author"
          },
          "url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The URL of the Oembed"
          }
        },
        "required": []
      },
      "IReddit.SecureMediaEmbed": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "title": "The content of the media"
          },
          "width": {
            "type": "number",
            "title": "The width of the media"
          },
          "scrolling": {
            "type": "boolean",
            "title": "Whether scrolling is enabled"
          },
          "media_domain_url": {
            "type": "string",
            "title": "The media domain URL"
          },
          "height": {
            "type": "number",
            "title": "The height of the media"
          }
        },
        "required": []
      },
      "IReddit.AuthorFlairRichtext": {
        "type": "object",
        "properties": {
          "e": {
            "type": "string",
            "title": "The type of the element"
          },
          "t": {
            "type": "string",
            "title": "The text of the element"
          }
        },
        "required": []
      },
      "IReddit.Preview": {
        "type": "object",
        "properties": {
          "images": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Image"
            },
            "title": "The images in the preview"
          },
          "enabled": {
            "type": "boolean",
            "title": "Whether the preview is enabled"
          }
        },
        "required": [
          "images",
          "enabled"
        ]
      },
      "IReddit.Image": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/IReddit.Source",
            "title": "The source of the image"
          },
          "resolutions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Resolution"
            },
            "title": "The resolutions of the image"
          },
          "variants": {
            "title": "The variants of the image"
          },
          "id": {
            "type": "string",
            "title": "The ID of the image"
          }
        },
        "required": [
          "source",
          "resolutions",
          "variants",
          "id"
        ]
      },
      "IReddit.Source": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "The URL of the source"
          },
          "width": {
            "type": "number",
            "title": "The width of the source"
          },
          "height": {
            "type": "number",
            "title": "The height of the source"
          }
        },
        "required": [
          "url",
          "width",
          "height"
        ]
      },
      "IReddit.Resolution": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "The URL of the resolution"
          },
          "width": {
            "type": "number",
            "title": "The width of the resolution"
          },
          "height": {
            "type": "number",
            "title": "The height of the resolution"
          }
        },
        "required": [
          "url",
          "width",
          "height"
        ]
      },
      "IReddit.Media": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "title": "The type of the media"
          },
          "oembed": {
            "$ref": "#/components/schemas/IReddit.Oembed",
            "title": "Oembed information"
          }
        },
        "required": []
      },
      "IReddit.MediaMetadata": {
        "type": "object",
        "properties": {},
        "required": [],
        "additionalProperties": {
          "$ref": "#/components/schemas/IReddit.Metadata"
        }
      },
      "IReddit.Metadata": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "title": "The status of the metadata"
          },
          "e": {
            "type": "string",
            "title": "The type of the element"
          },
          "m": {
            "type": "string",
            "title": "The media type"
          },
          "p": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Position"
            },
            "title": "The positions"
          },
          "s": {
            "$ref": "#/components/schemas/IReddit.Position",
            "title": "The position"
          },
          "id": {
            "type": "string",
            "title": "The ID of the metadata"
          }
        },
        "required": []
      },
      "IReddit.Position": {
        "type": "object",
        "properties": {
          "y": {
            "type": "number",
            "title": "The y-coordinate"
          },
          "x": {
            "type": "number",
            "title": "The x-coordinate"
          },
          "u": {
            "type": "string",
            "format": "iri",
            "title": "The URL"
          }
        },
        "required": [
          "y",
          "x",
          "u"
        ]
      },
      "IReddit.GalleryData": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Item"
            },
            "title": "The items in the gallery"
          }
        },
        "required": [
          "items"
        ]
      },
      "IReddit.Item": {
        "type": "object",
        "properties": {
          "media_id": {
            "type": "string",
            "title": "The media ID"
          },
          "id": {
            "type": "number",
            "title": "The ID of the item"
          },
          "caption": {
            "type": "string",
            "title": "The caption of the item"
          }
        },
        "required": [
          "media_id",
          "id"
        ]
      },
      "IReddit.CrosspostParentList": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "The title of the post"
          },
          "name": {
            "type": "string",
            "title": "The name of the post"
          },
          "url": {
            "type": "string",
            "title": "URL of the post"
          },
          "id": {
            "type": "string",
            "title": "ID of the post"
          },
          "view_count": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "View count"
          },
          "hidden": {
            "type": "boolean",
            "title": "Whether the post is hidden"
          },
          "created": {
            "type": "number",
            "title": "Creation time"
          },
          "thumbnail": {
            "type": "string",
            "title": "Thumbnail URL"
          },
          "author": {
            "type": "string",
            "title": "Author of the post"
          },
          "locked": {
            "type": "boolean",
            "title": "Whether the post is locked"
          },
          "domain": {
            "type": "string",
            "title": "Domain of the post"
          },
          "score": {
            "type": "number",
            "title": "Score of the post"
          },
          "category": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Category of the post"
          },
          "media": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.Media"
              }
            ],
            "title": "Media information"
          },
          "archived": {
            "type": "boolean",
            "title": "Whether the post is archived"
          },
          "subreddit": {
            "type": "string",
            "title": "The subreddit name"
          },
          "approved_at_utc": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Approval time in UTC"
          },
          "author_is_blocked": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the author is blocked"
          },
          "subreddit_id": {
            "type": "string",
            "title": "ID of the subreddit"
          },
          "awarders": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Awarders of the post"
          },
          "mod_reason_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator reason by user"
          },
          "banned_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Banned by user"
          },
          "author_flair_type": {
            "type": "string",
            "title": "Type of author flair"
          },
          "total_awards_received": {
            "type": "number",
            "title": "Total awards received"
          },
          "author_flair_template_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "uuid"
              }
            ],
            "title": "Template ID for author flair"
          },
          "likes": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Likes on the post"
          },
          "user_reports": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "User reports"
          },
          "saved": {
            "type": "boolean",
            "title": "Whether the post is saved"
          },
          "banned_at_utc": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Banned time in UTC"
          },
          "mod_reason_title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator reason title"
          },
          "gilded": {
            "type": "integer",
            "title": "Number of times gilded"
          },
          "no_follow": {
            "type": "boolean",
            "title": "Whether no-follow is enabled"
          },
          "can_mod_post": {
            "type": "boolean",
            "title": "Whether the post can be moderated"
          },
          "created_utc": {
            "type": "integer",
            "title": "Creation time in UTC"
          },
          "send_replies": {
            "type": "boolean",
            "title": "Whether to send replies"
          },
          "author_fullname": {
            "type": "string",
            "pattern": "^(t2_(.*))",
            "title": "The full name of the author"
          },
          "approved_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Approved by user"
          },
          "mod_note": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator note"
          },
          "all_awardings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "All awardings"
          },
          "top_awarded_type": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Type of top award"
          },
          "author_flair_css_class": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "CSS class for author flair"
          },
          "downs": {
            "type": "integer",
            "title": "Number of downvotes"
          },
          "author_flair_richtext": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.AuthorFlairRichtext"
            },
            "title": "Rich text for author flair"
          },
          "author_patreon_flair": {
            "type": "boolean",
            "title": "Whether the author has Patreon flair"
          },
          "removal_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Removal reason"
          },
          "distinguished": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Distinguished status"
          },
          "stickied": {
            "type": "boolean",
            "title": "Whether the post is stickied"
          },
          "author_premium": {
            "type": "boolean",
            "title": "Whether the author is premium"
          },
          "can_gild": {
            "type": "boolean",
            "title": "Whether the post can be gilded"
          },
          "gildings": {
            "title": "Gildings information"
          },
          "author_flair_text_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text color for author flair"
          },
          "permalink": {
            "type": "string",
            "title": "Permalink to the post"
          },
          "subreddit_type": {
            "type": "string",
            "title": "Type of subreddit"
          },
          "report_reasons": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Report reasons"
          },
          "author_flair_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text for author flair"
          },
          "treatment_tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Treatment tags"
          },
          "subreddit_name_prefixed": {
            "type": "string",
            "title": "Prefixed subreddit name"
          },
          "author_flair_background_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Background color for author flair"
          },
          "mod_reports": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Moderator reports"
          },
          "num_reports": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Number of reports"
          },
          "ups": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Number of upvotes"
          },
          "selftext": {
            "type": "string",
            "title": "The text of the post"
          },
          "is_gallery": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the post is a gallery"
          },
          "link_flair_richtext": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.LinkFlairRichtext"
            },
            "title": "Rich text for link flair"
          },
          "pwls": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Post whitelist status"
          },
          "link_flair_css_class": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "CSS class for link flair"
          },
          "thumbnail_height": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Height of the thumbnail"
          },
          "hide_score": {
            "type": "boolean",
            "title": "Whether the score is hidden"
          },
          "media_metadata": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.MediaMetadata"
              }
            ],
            "title": "Media metadata"
          },
          "quarantine": {
            "type": "boolean",
            "title": "Whether the post is quarantined"
          },
          "link_flair_text_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text color for link flair"
          },
          "upvote_ratio": {
            "type": "number",
            "title": "Ratio of upvotes"
          },
          "media_embed": {
            "$ref": "#/components/schemas/IReddit.MediaEmbed",
            "title": "Media embed information"
          },
          "thumbnail_width": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Width of the thumbnail"
          },
          "is_original_content": {
            "type": "boolean",
            "title": "Whether the content is original"
          },
          "secure_media": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.SecureMedia"
              }
            ],
            "title": "Secure media information"
          },
          "is_reddit_media_domain": {
            "type": "boolean",
            "title": "Whether it's a Reddit media domain"
          },
          "is_meta": {
            "type": "boolean",
            "title": "Whether it's meta content"
          },
          "secure_media_embed": {
            "$ref": "#/components/schemas/IReddit.SecureMediaEmbed",
            "title": "Secure media embed information"
          },
          "gallery_data": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.GalleryData"
              }
            ],
            "title": "Gallery data"
          },
          "link_flair_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text for link flair"
          },
          "is_created_from_ads_ui": {
            "type": "boolean",
            "title": "Whether created from ads UI"
          },
          "edited": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the post is edited"
          },
          "content_categories": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "Content categories"
          },
          "is_self": {
            "type": "boolean",
            "title": "Whether it's a self post"
          },
          "link_flair_type": {
            "type": "string",
            "title": "Type of link flair"
          },
          "wls": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Whitelist status"
          },
          "removed_by_category": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Removed by category"
          },
          "allow_live_comments": {
            "type": "boolean",
            "title": "Whether live comments are allowed"
          },
          "selftext_html": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "HTML of the selftext"
          },
          "suggested_sort": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Suggested sort order"
          },
          "url_overridden_by_dest": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "URL overridden by destination"
          },
          "is_crosspostable": {
            "type": "boolean",
            "title": "Whether the post is crosspostable"
          },
          "pinned": {
            "type": "boolean",
            "title": "Whether the post is pinned"
          },
          "over_18": {
            "type": "boolean",
            "title": "Whether the post is NSFW"
          },
          "media_only": {
            "type": "boolean",
            "title": "Whether it's media only"
          },
          "spoiler": {
            "type": "boolean",
            "title": "Whether the post is a spoiler"
          },
          "visited": {
            "type": "boolean",
            "title": "Whether the post is visited"
          },
          "removed_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Removed by user"
          },
          "link_flair_background_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Background color for link flair"
          },
          "is_robot_indexable": {
            "type": "boolean",
            "title": "Whether the post is robot indexable"
          },
          "discussion_type": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Type of discussion"
          },
          "num_comments": {
            "type": "number",
            "title": "Number of comments"
          },
          "contest_mode": {
            "type": "boolean",
            "title": "Whether contest mode is enabled"
          },
          "subreddit_subscribers": {
            "type": "number",
            "title": "Number of subreddit subscribers"
          },
          "num_crossposts": {
            "type": "number",
            "title": "Number of crossposts"
          },
          "is_video": {
            "type": "boolean",
            "title": "Whether the post is a video"
          },
          "post_hint": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Hint for the post"
          },
          "preview": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.Preview"
              }
            ],
            "title": "Preview information"
          },
          "link_flair_template_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Template ID for link flair"
          }
        },
        "required": [
          "title",
          "name",
          "url",
          "id"
        ]
      },
      "IReddit.IGetHotPostsInput": {
        "type": "object",
        "properties": {
          "g": {
            "type": "string",
            "title": "Optional parameter",
            "description": "one of (GLOBAL, US, AR, AU, BG, CA, CL, CO, HR, CZ, FI, FR, DE, GR, HU, IS, IN, IE, IT, JP, MY, MX, NZ, PH, PL, PT, PR, RO, RS, SG, ES, SE, TW, TH, TR, GB, US_WA, US_DE, US_DC, US_WI, US_WV, US_HI, US_FL, US_WY, US_NH, US_NJ, US_NM, US_TX, US_LA, US_NC, US_ND, US_NE, US_TN, US_NY, US_PA, US_CA, US_NV, US_VA, US_CO, US_AK, US_AL, US_AR, US_VT, US_IL, US_GA, US_IN, US_IA, US_OK, US_AZ, US_ID, US_CT, US_ME, US_MD, US_MA, US_OH, US_UT, US_MO, US_MN, US_MI, US_RI, US_KS, US_MT, US_MS, US_SC, US_KY, US_OR, US_SD)"
          },
          "subreddit": {
            "type": "string",
            "pattern": "^(r\\/(.*))",
            "title": "The subreddit to fetch posts from"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 25,
            "title": "The number of posts to fetch"
          },
          "after": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "after",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "before": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "before",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IReddit.IGetNewPostsOutput": {
        "type": "object",
        "properties": {
          "after": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The after cursor for pagination"
          },
          "dist": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The number of items returned"
          },
          "modhash": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The modhash for the request"
          },
          "geo_filter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The geographical filter applied"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Children"
            },
            "title": "The list of children posts"
          },
          "before": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The before cursor for pagination"
          }
        },
        "required": [
          "after",
          "dist",
          "modhash",
          "geo_filter",
          "children",
          "before"
        ]
      },
      "IReddit.IGetNewPostsInput": {
        "type": "object",
        "properties": {
          "subreddit": {
            "type": "string",
            "pattern": "^(r\\/(.*))",
            "title": "The subreddit to fetch posts from"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 25,
            "title": "The number of posts to fetch"
          },
          "after": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "after",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "before": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "before",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IReddit.IGetTopPostsOutput": {
        "type": "object",
        "properties": {
          "after": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The after cursor for pagination"
          },
          "dist": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The number of items returned"
          },
          "modhash": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The modhash for the request"
          },
          "geo_filter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The geographical filter applied"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Children"
            },
            "title": "The list of children posts"
          },
          "before": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The before cursor for pagination"
          }
        },
        "required": [
          "after",
          "dist",
          "modhash",
          "geo_filter",
          "children",
          "before"
        ]
      },
      "IReddit.IGetTopPostsInput": {
        "type": "object",
        "properties": {
          "subreddit": {
            "type": "string",
            "pattern": "^(r\\/(.*))",
            "title": "The subreddit to fetch posts from"
          },
          "time_filter": {
            "oneOf": [
              {
                "const": "all"
              },
              {
                "const": "day"
              },
              {
                "const": "week"
              },
              {
                "const": "month"
              },
              {
                "const": "year"
              },
              {
                "const": "hour"
              }
            ],
            "title": "The time filter for the posts"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 25,
            "title": "The number of posts to fetch"
          },
          "after": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "after",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "before": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "before",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IReddit.IGetArticleAndCommentsOutput": {
        "type": "object",
        "properties": {
          "articles": {
            "type": "object",
            "properties": {
              "after": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string",
                    "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
                  }
                ],
                "title": "The after cursor for pagination"
              },
              "dist": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "number"
                  }
                ],
                "title": "The number of items returned"
              },
              "modhash": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "The modhash for the request"
              },
              "geo_filter": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "The geographical filter applied"
              },
              "children": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IReddit.Children"
                },
                "title": "The list of children posts"
              },
              "before": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string",
                    "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
                  }
                ],
                "title": "The before cursor for pagination"
              }
            },
            "required": [
              "after",
              "dist",
              "modhash",
              "geo_filter",
              "children",
              "before"
            ]
          },
          "more": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.ChildMore"
              }
            ],
            "discriminator": {
              "propertyName": "kind",
              "mapping": {
                "more": "#/components/schemas/IReddit.ChildMore"
              }
            }
          },
          "flatComments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.ChildComment"
            }
          }
        },
        "required": [
          "articles",
          "more",
          "flatComments"
        ]
      },
      "IReddit.ChildMore": {
        "type": "object",
        "properties": {
          "kind": {
            "const": "more",
            "title": "kind"
          },
          "data": {
            "type": "object",
            "properties": {
              "count": {
                "type": "integer",
                "title": "count"
              },
              "name": {
                "type": "string",
                "pattern": "^(t1_(.*))",
                "title": "name"
              },
              "id": {
                "type": "string",
                "title": "id"
              },
              "parent_id": {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
                "title": "parent_id"
              },
              "depth": {
                "type": "integer",
                "title": "depth"
              },
              "children": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "children"
              }
            },
            "required": [
              "count",
              "name",
              "id",
              "parent_id",
              "depth",
              "children"
            ],
            "title": "data"
          }
        },
        "required": [
          "kind",
          "data"
        ]
      },
      "IReddit.ChildComment": {
        "type": "object",
        "properties": {
          "kind": {
            "const": "t1",
            "title": "kind"
          },
          "data": {
            "$ref": "#/components/schemas/IReddit.Comment",
            "title": "data"
          }
        },
        "required": [
          "kind",
          "data"
        ]
      },
      "IReddit.Comment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id"
          },
          "parent_id": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "parent_id"
          },
          "link_id": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "link_id"
          },
          "comment_type": {
            "type": "null",
            "title": "comment_type"
          },
          "depth": {
            "type": "integer",
            "title": "depth"
          },
          "replies": {
            "oneOf": [
              {
                "const": ""
              },
              {
                "$ref": "#/components/schemas/__type.o2185"
              }
            ],
            "title": "replies"
          },
          "collapsed_reason_code": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "collapsed_reason_code"
          },
          "collapsed": {
            "type": "boolean",
            "title": "collapsed"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "body_html": {
            "type": "string",
            "title": "body_html"
          },
          "is_submitter": {
            "type": "boolean",
            "title": "is_submitter"
          },
          "collapsed_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "collapsed_reason"
          },
          "associated_award": {
            "type": "null",
            "title": "associated_award"
          },
          "unrepliable_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "unrepliable_reason"
          },
          "controversiality": {
            "type": "integer",
            "title": "controversiality"
          },
          "score_hidden": {
            "type": "boolean",
            "title": "score_hidden"
          },
          "collapsed_because_crowd_control": {
            "type": "null",
            "title": "collapsed_because_crowd_control"
          },
          "name": {
            "type": "string",
            "title": "The name of the post"
          },
          "created": {
            "type": "number",
            "title": "Creation time"
          },
          "author": {
            "type": "string",
            "title": "Author of the post"
          },
          "locked": {
            "type": "boolean",
            "title": "Whether the post is locked"
          },
          "score": {
            "type": "number",
            "title": "Score of the post"
          },
          "archived": {
            "type": "boolean",
            "title": "Whether the post is archived"
          },
          "subreddit": {
            "type": "string",
            "title": "The subreddit name"
          },
          "approved_at_utc": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Approval time in UTC"
          },
          "author_is_blocked": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the author is blocked"
          },
          "subreddit_id": {
            "type": "string",
            "title": "ID of the subreddit"
          },
          "awarders": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Awarders of the post"
          },
          "mod_reason_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator reason by user"
          },
          "banned_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Banned by user"
          },
          "author_flair_type": {
            "type": "string",
            "title": "Type of author flair"
          },
          "total_awards_received": {
            "type": "number",
            "title": "Total awards received"
          },
          "author_flair_template_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "uuid"
              }
            ],
            "title": "Template ID for author flair"
          },
          "likes": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Likes on the post"
          },
          "user_reports": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "User reports"
          },
          "saved": {
            "type": "boolean",
            "title": "Whether the post is saved"
          },
          "banned_at_utc": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Banned time in UTC"
          },
          "mod_reason_title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator reason title"
          },
          "gilded": {
            "type": "integer",
            "title": "Number of times gilded"
          },
          "no_follow": {
            "type": "boolean",
            "title": "Whether no-follow is enabled"
          },
          "can_mod_post": {
            "type": "boolean",
            "title": "Whether the post can be moderated"
          },
          "created_utc": {
            "type": "integer",
            "title": "Creation time in UTC"
          },
          "send_replies": {
            "type": "boolean",
            "title": "Whether to send replies"
          },
          "author_fullname": {
            "type": "string",
            "pattern": "^(t2_(.*))",
            "title": "The full name of the author"
          },
          "approved_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Approved by user"
          },
          "mod_note": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Moderator note"
          },
          "all_awardings": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "All awardings"
          },
          "top_awarded_type": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Type of top award"
          },
          "author_flair_css_class": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "CSS class for author flair"
          },
          "downs": {
            "type": "integer",
            "title": "Number of downvotes"
          },
          "author_flair_richtext": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.AuthorFlairRichtext"
            },
            "title": "Rich text for author flair"
          },
          "author_patreon_flair": {
            "type": "boolean",
            "title": "Whether the author has Patreon flair"
          },
          "removal_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Removal reason"
          },
          "distinguished": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Distinguished status"
          },
          "stickied": {
            "type": "boolean",
            "title": "Whether the post is stickied"
          },
          "author_premium": {
            "type": "boolean",
            "title": "Whether the author is premium"
          },
          "can_gild": {
            "type": "boolean",
            "title": "Whether the post can be gilded"
          },
          "gildings": {
            "title": "Gildings information"
          },
          "author_flair_text_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text color for author flair"
          },
          "permalink": {
            "type": "string",
            "title": "Permalink to the post"
          },
          "subreddit_type": {
            "type": "string",
            "title": "Type of subreddit"
          },
          "report_reasons": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Report reasons"
          },
          "author_flair_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Text for author flair"
          },
          "treatment_tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Treatment tags"
          },
          "subreddit_name_prefixed": {
            "type": "string",
            "title": "Prefixed subreddit name"
          },
          "author_flair_background_color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Background color for author flair"
          },
          "mod_reports": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Moderator reports"
          },
          "num_reports": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Number of reports"
          },
          "ups": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Number of upvotes"
          }
        },
        "required": [
          "id",
          "parent_id",
          "name"
        ]
      },
      "__type.o2185": {
        "type": "object",
        "properties": {
          "kind": {
            "const": "Listing"
          },
          "data": {
            "$ref": "#/components/schemas/__type.o2186"
          }
        },
        "required": [
          "kind",
          "data"
        ]
      },
      "__type.o2186": {
        "type": "object",
        "properties": {
          "after": {
            "type": "null"
          },
          "dist": {
            "type": "null"
          },
          "modhash": {
            "type": "null"
          },
          "geo_filter": {
            "type": "string"
          },
          "children": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/__type.o2187"
                },
                {
                  "type": "object",
                  "properties": {
                    "kind": {
                      "const": "more",
                      "title": "kind"
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "count": {
                          "type": "integer",
                          "title": "count"
                        },
                        "name": {
                          "type": "string",
                          "pattern": "^(t1_(.*))",
                          "title": "name"
                        },
                        "id": {
                          "type": "string",
                          "title": "id"
                        },
                        "parent_id": {
                          "type": "string",
                          "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
                          "title": "parent_id"
                        },
                        "depth": {
                          "type": "integer",
                          "title": "depth"
                        },
                        "children": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          },
                          "title": "children"
                        }
                      },
                      "required": [
                        "count",
                        "name",
                        "id",
                        "parent_id",
                        "depth",
                        "children"
                      ],
                      "title": "data"
                    }
                  },
                  "required": [
                    "kind",
                    "data"
                  ]
                }
              ]
            }
          },
          "before": {
            "type": "null"
          }
        },
        "required": [
          "after",
          "dist",
          "modhash",
          "geo_filter",
          "children",
          "before"
        ]
      },
      "__type.o2187": {
        "type": "object",
        "properties": {
          "kind": {
            "const": "t1",
            "title": "kind"
          },
          "data": {
            "$ref": "#/components/schemas/IReddit.Comment",
            "title": "data"
          }
        },
        "required": [
          "kind",
          "data"
        ]
      },
      "IReddit.IGetCommentsInput": {
        "type": "object",
        "properties": {
          "comment": {
            "type": "string",
            "title": "Comment ID",
            "description": "(optional) ID36 of a comment"
          },
          "depth": {
            "type": "number",
            "title": "depth",
            "description": "depth is the maximum depth of subtrees in the thread."
          },
          "subreddit": {
            "type": "string",
            "pattern": "^(r\\/(.*))",
            "title": "The subreddit of the post"
          },
          "article": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/reddit/get-hot-posts",
                  "jmesPath": "children[].data.{label: title, id: id}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/reddit/get-new-posts",
                  "jmesPath": "children[].data.{label: title, id: id}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/reddit/get-top-posts",
                  "jmesPath": "children[].data.{label: title, id: id}"
                }
              }
            ],
            "title": "The article ID of the post"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 25,
            "title": "The number of posts to fetch"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "article",
          "secretKey"
        ]
      },
      "IReddit.IGetUserAboutOutput": {
        "type": "object",
        "properties": {
          "kind": {
            "const": "t2",
            "title": "kind"
          },
          "data": {
            "type": "object",
            "properties": {
              "is_employee": {
                "type": "boolean",
                "title": "is_employee"
              },
              "has_visited_new_profile": {
                "type": "boolean",
                "title": "has_visited_new_profile"
              },
              "is_friend": {
                "type": "boolean",
                "title": "is_friend"
              },
              "pref_no_profanity": {
                "type": "boolean",
                "title": "pref_no_profanity"
              },
              "has_external_account": {
                "type": "boolean",
                "title": "has_external_account"
              },
              "pref_geopopular": {
                "type": "string",
                "title": "pref_geopopular"
              },
              "pref_show_trending": {
                "type": "boolean",
                "title": "pref_show_trending"
              },
              "subreddit": {
                "type": "object",
                "properties": {
                  "default_set": {
                    "type": "boolean",
                    "title": "default_set"
                  },
                  "user_is_contributor": {
                    "type": "boolean",
                    "title": "user_is_contributor"
                  },
                  "banner_img": {
                    "type": "string",
                    "title": "banner_img"
                  },
                  "allowed_media_in_comments": {
                    "type": "array",
                    "items": {},
                    "title": "allowed_media_in_comments"
                  },
                  "user_is_banned": {
                    "type": "boolean",
                    "title": "user_is_banned"
                  },
                  "free_form_reports": {
                    "type": "boolean",
                    "title": "free_form_reports"
                  },
                  "community_icon": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "format": "iri"
                      }
                    ],
                    "title": "community_icon"
                  },
                  "show_media": {
                    "type": "boolean",
                    "title": "show_media"
                  },
                  "icon_color": {
                    "type": "string",
                    "title": "icon_color"
                  },
                  "user_is_muted": {
                    "type": "null",
                    "title": "user_is_muted"
                  },
                  "display_name": {
                    "type": "string",
                    "title": "display_name"
                  },
                  "header_img": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "format": "iri"
                      }
                    ],
                    "title": "header_img"
                  },
                  "title": {
                    "type": "string",
                    "title": "title"
                  },
                  "coins": {
                    "type": "integer",
                    "title": "coins"
                  },
                  "previous_names": {
                    "type": "array",
                    "items": {},
                    "title": "previous_names"
                  },
                  "over_18": {
                    "type": "boolean",
                    "title": "over_18"
                  },
                  "icon_size": {
                    "type": "array",
                    "items": {
                      "type": "integer"
                    },
                    "minItems": 2,
                    "maxItems": 2,
                    "title": "icon_size"
                  },
                  "primary_color": {
                    "type": "string",
                    "title": "primary_color"
                  },
                  "icon_img": {
                    "type": "string",
                    "format": "iri",
                    "title": "icon_img"
                  },
                  "description": {
                    "type": "string",
                    "title": "description"
                  },
                  "submit_link_label": {
                    "type": "string",
                    "title": "submit_link_label"
                  },
                  "header_size": {
                    "type": "null",
                    "title": "header_size"
                  },
                  "restrict_posting": {
                    "type": "boolean",
                    "title": "restrict_posting"
                  },
                  "restrict_commenting": {
                    "type": "boolean",
                    "title": "restrict_commenting"
                  },
                  "subscribers": {
                    "type": "integer",
                    "title": "subscribers"
                  },
                  "submit_text_label": {
                    "type": "string",
                    "title": "submit_text_label"
                  },
                  "is_default_icon": {
                    "type": "boolean",
                    "title": "is_default_icon"
                  },
                  "link_flair_position": {
                    "type": "string",
                    "title": "link_flair_position"
                  },
                  "display_name_prefixed": {
                    "type": "string",
                    "pattern": "^(u\\/(.*))",
                    "title": "display_name_prefixed"
                  },
                  "key_color": {
                    "type": "string",
                    "title": "key_color"
                  },
                  "name": {
                    "type": "string",
                    "pattern": "^(t5_(.*))",
                    "title": "name"
                  },
                  "is_default_banner": {
                    "type": "boolean",
                    "title": "is_default_banner"
                  },
                  "url": {
                    "type": "string",
                    "pattern": "^(\\/user\\/(.*)\\/)$",
                    "title": "url"
                  },
                  "quarantine": {
                    "type": "boolean",
                    "title": "quarantine"
                  },
                  "banner_size": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "integer"
                        },
                        "minItems": 2,
                        "maxItems": 2
                      }
                    ],
                    "title": "banner_size"
                  },
                  "user_is_moderator": {
                    "type": "boolean",
                    "title": "user_is_moderator"
                  },
                  "accept_followers": {
                    "type": "boolean",
                    "title": "accept_followers"
                  },
                  "public_description": {
                    "type": "string",
                    "title": "public_description"
                  },
                  "link_flair_enabled": {
                    "type": "boolean",
                    "title": "link_flair_enabled"
                  },
                  "disable_contributor_requests": {
                    "type": "boolean",
                    "title": "disable_contributor_requests"
                  },
                  "subreddit_type": {
                    "const": "user",
                    "title": "subreddit_type"
                  },
                  "user_is_subscriber": {
                    "type": "boolean",
                    "title": "user_is_subscriber"
                  }
                },
                "required": [],
                "title": "subreddit"
              },
              "pref_show_presence": {
                "type": "boolean",
                "title": "pref_show_presence"
              },
              "snoovatar_img": {
                "type": "string",
                "title": "snoovatar_img"
              },
              "snoovatar_size": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "integer"
                    },
                    "minItems": 2,
                    "maxItems": 2
                  }
                ],
                "title": "snoovatar_size"
              },
              "gold_expiration": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "integer"
                  }
                ],
                "title": "gold_expiration"
              },
              "has_gold_subscription": {
                "type": "boolean",
                "title": "has_gold_subscription"
              },
              "is_sponsor": {
                "type": "boolean",
                "title": "is_sponsor"
              },
              "num_friends": {
                "type": "integer",
                "title": "num_friends"
              },
              "features": {
                "type": "object",
                "properties": {
                  "modmail_harassment_filter": {
                    "type": "boolean",
                    "title": "modmail_harassment_filter"
                  },
                  "mod_service_mute_writes": {
                    "type": "boolean",
                    "title": "mod_service_mute_writes"
                  },
                  "promoted_trend_blanks": {
                    "type": "boolean",
                    "title": "promoted_trend_blanks"
                  },
                  "show_amp_link": {
                    "type": "boolean",
                    "title": "show_amp_link"
                  },
                  "is_email_permission_required": {
                    "type": "boolean",
                    "title": "is_email_permission_required"
                  },
                  "mod_awards": {
                    "type": "boolean",
                    "title": "mod_awards"
                  },
                  "awards_on_streams": {
                    "type": "boolean",
                    "title": "awards_on_streams"
                  },
                  "mweb_xpromo_modal_listing_click_daily_dismissible_ios": {
                    "type": "boolean",
                    "title": "mweb_xpromo_modal_listing_click_daily_dismissible_ios"
                  },
                  "chat_subreddit": {
                    "type": "boolean",
                    "title": "chat_subreddit"
                  },
                  "cookie_consent_banner": {
                    "type": "boolean",
                    "title": "cookie_consent_banner"
                  },
                  "modlog_copyright_removal": {
                    "type": "boolean",
                    "title": "modlog_copyright_removal"
                  },
                  "do_not_track": {
                    "type": "boolean",
                    "title": "do_not_track"
                  },
                  "images_in_comments": {
                    "type": "boolean",
                    "title": "images_in_comments"
                  },
                  "mod_service_mute_reads": {
                    "type": "boolean",
                    "title": "mod_service_mute_reads"
                  },
                  "chat_user_settings": {
                    "type": "boolean",
                    "title": "chat_user_settings"
                  },
                  "use_pref_account_deployment": {
                    "type": "boolean",
                    "title": "use_pref_account_deployment"
                  },
                  "mweb_xpromo_interstitial_comments_ios": {
                    "type": "boolean",
                    "title": "mweb_xpromo_interstitial_comments_ios"
                  },
                  "mweb_xpromo_modal_listing_click_daily_dismissible_android": {
                    "type": "boolean",
                    "title": "mweb_xpromo_modal_listing_click_daily_dismissible_android"
                  },
                  "premium_subscriptions_table": {
                    "type": "boolean",
                    "title": "premium_subscriptions_table"
                  },
                  "mweb_xpromo_interstitial_comments_android": {
                    "type": "boolean",
                    "title": "mweb_xpromo_interstitial_comments_android"
                  },
                  "crowd_control_for_post": {
                    "type": "boolean",
                    "title": "crowd_control_for_post"
                  },
                  "chat_group_rollout": {
                    "type": "boolean",
                    "title": "chat_group_rollout"
                  },
                  "resized_styles_images": {
                    "type": "boolean",
                    "title": "resized_styles_images"
                  },
                  "noreferrer_to_noopener": {
                    "type": "boolean",
                    "title": "noreferrer_to_noopener"
                  },
                  "expensive_coins_package": {
                    "type": "boolean",
                    "title": "expensive_coins_package"
                  }
                },
                "required": [],
                "title": "features"
              },
              "can_edit_name": {
                "type": "boolean",
                "title": "can_edit_name"
              },
              "is_blocked": {
                "type": "boolean",
                "title": "is_blocked"
              },
              "verified": {
                "type": "boolean",
                "title": "verified"
              },
              "pref_autoplay": {
                "type": "boolean",
                "title": "pref_autoplay"
              },
              "coins": {
                "type": "integer",
                "title": "coins"
              },
              "has_paypal_subscription": {
                "type": "boolean",
                "title": "has_paypal_subscription"
              },
              "has_subscribed_to_premium": {
                "type": "boolean",
                "title": "has_subscribed_to_premium"
              },
              "id": {
                "type": "string",
                "title": "id"
              },
              "can_create_subreddit": {
                "type": "boolean",
                "title": "can_create_subreddit"
              },
              "over_18": {
                "type": "boolean",
                "title": "over_18"
              },
              "is_gold": {
                "type": "boolean",
                "title": "is_gold"
              },
              "is_mod": {
                "type": "boolean",
                "title": "is_mod"
              },
              "awarder_karma": {
                "type": "integer",
                "title": "awarder_karma"
              },
              "suspension_expiration_utc": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "integer"
                  }
                ],
                "title": "suspension_expiration_utc"
              },
              "has_stripe_subscription": {
                "type": "boolean",
                "title": "has_stripe_subscription"
              },
              "is_suspended": {
                "type": "boolean",
                "title": "is_suspended"
              },
              "pref_video_autoplay": {
                "type": "boolean",
                "title": "pref_video_autoplay"
              },
              "has_android_subscription": {
                "type": "boolean",
                "title": "has_android_subscription"
              },
              "in_redesign_beta": {
                "type": "boolean",
                "title": "in_redesign_beta"
              },
              "icon_img": {
                "type": "string",
                "format": "iri",
                "title": "icon_img"
              },
              "pref_nightmode": {
                "type": "boolean",
                "title": "pref_nightmode"
              },
              "awardee_karma": {
                "type": "integer",
                "title": "awardee_karma"
              },
              "hide_from_robots": {
                "type": "boolean",
                "title": "hide_from_robots"
              },
              "password_set": {
                "type": "boolean",
                "title": "password_set"
              },
              "modhash": {
                "type": "null",
                "title": "modhash"
              },
              "link_karma": {
                "type": "integer",
                "title": "link_karma"
              },
              "force_password_reset": {
                "type": "boolean",
                "title": "force_password_reset"
              },
              "total_karma": {
                "type": "integer",
                "title": "total_karma"
              },
              "inbox_count": {
                "type": "integer",
                "title": "inbox_count"
              },
              "pref_top_karma_subreddits": {
                "type": "boolean",
                "title": "pref_top_karma_subreddits"
              },
              "pref_show_snoovatar": {
                "type": "boolean",
                "title": "pref_show_snoovatar"
              },
              "name": {
                "type": "string",
                "title": "name"
              },
              "pref_clickgadget": {
                "type": "integer",
                "title": "pref_clickgadget"
              },
              "created": {
                "type": "integer",
                "title": "created"
              },
              "has_verified_email": {
                "type": "boolean",
                "title": "has_verified_email"
              },
              "gold_creddits": {
                "type": "integer",
                "title": "gold_creddits"
              },
              "created_utc": {
                "type": "integer",
                "title": "created_utc"
              },
              "has_ios_subscription": {
                "type": "boolean",
                "title": "has_ios_subscription"
              },
              "pref_show_twitter": {
                "type": "boolean",
                "title": "pref_show_twitter"
              },
              "in_beta": {
                "type": "boolean",
                "title": "in_beta"
              },
              "comment_karma": {
                "type": "integer",
                "title": "comment_karma"
              },
              "accept_followers": {
                "type": "boolean",
                "title": "accept_followers"
              },
              "has_subscribed": {
                "type": "boolean",
                "title": "has_subscribed"
              }
            },
            "required": [],
            "title": "data"
          }
        },
        "required": [
          "kind"
        ]
      },
      "IReddit.IGetUserAboutInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "The username to fetch information for"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IReddit.IGetUserSubmittedOutput": {
        "type": "object",
        "properties": {
          "after": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The after cursor for pagination"
          },
          "dist": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The number of items returned"
          },
          "modhash": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The modhash for the request"
          },
          "geo_filter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The geographical filter applied"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Children"
            },
            "title": "The list of children posts"
          },
          "before": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The before cursor for pagination"
          }
        },
        "required": [
          "after",
          "dist",
          "modhash",
          "geo_filter",
          "children",
          "before"
        ]
      },
      "IReddit.IGetUserSubmittedInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "The username to fetch posts for"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 25,
            "title": "The number of posts to fetch"
          },
          "after": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "after",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "before": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "before",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IReddit.IFlattenCommentsOutput": {
        "type": "object",
        "properties": {
          "more": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IReddit.ChildMore"
              }
            ],
            "discriminator": {
              "propertyName": "kind",
              "mapping": {
                "more": "#/components/schemas/IReddit.ChildMore"
              }
            }
          },
          "flatComments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.ChildComment"
            }
          }
        },
        "required": [
          "more",
          "flatComments"
        ]
      },
      "IReddit.IGetUserCommentsInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "The username to fetch comments for"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "title": "The number of comments to fetch"
          },
          "after": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "after",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "before": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "before",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IReddit.ISearchSubredditsOutput": {
        "type": "object",
        "properties": {
          "after": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The after cursor for pagination"
          },
          "dist": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The number of items returned"
          },
          "modhash": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The modhash for the request"
          },
          "geo_filter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The geographical filter applied"
          },
          "children": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "kind": {
                  "const": "t5",
                  "title": "kind"
                },
                "data": {
                  "$ref": "#/components/schemas/IReddit.SubReddit",
                  "title": "data"
                }
              },
              "required": [
                "kind",
                "data"
              ]
            },
            "title": "The list of children sub-reddits"
          },
          "before": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The before cursor for pagination"
          }
        },
        "required": [
          "after",
          "dist",
          "modhash",
          "geo_filter",
          "children",
          "before"
        ]
      },
      "IReddit.SubReddit": {
        "type": "object",
        "properties": {
          "restrict_posting": {
            "type": "boolean",
            "title": "restrict_posting"
          },
          "user_is_banned": {
            "type": "boolean",
            "title": "user_is_banned"
          },
          "free_form_reports": {
            "type": "boolean",
            "title": "free_form_reports"
          },
          "user_is_muted": {
            "type": "boolean",
            "title": "user_is_muted"
          },
          "display_name": {
            "type": "string",
            "title": "display_name"
          },
          "title": {
            "type": "string",
            "title": "title"
          },
          "allow_galleries": {
            "type": "boolean",
            "title": "allow_galleries"
          },
          "primary_color": {
            "type": "string",
            "title": "primary_color"
          },
          "icon_img": {
            "type": "string",
            "title": "icon_img"
          },
          "display_name_prefixed": {
            "type": "string",
            "title": "display_name_prefixed"
          },
          "public_traffic": {
            "type": "boolean",
            "title": "public_traffic"
          },
          "subscribers": {
            "type": "number",
            "title": "subscribers"
          },
          "user_flair_richtext": {
            "type": "array",
            "items": {},
            "title": "user_flair_richtext"
          },
          "videostream_links_count": {
            "type": "number",
            "title": "videostream_links_count"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "quarantine": {
            "type": "boolean",
            "title": "quarantine"
          },
          "hide_ads": {
            "type": "boolean",
            "title": "hide_ads"
          },
          "prediction_leaderboard_entry_type": {
            "type": "number",
            "title": "prediction_leaderboard_entry_type"
          },
          "emojis_enabled": {
            "type": "boolean",
            "title": "emojis_enabled"
          },
          "advertiser_category": {
            "type": "string",
            "title": "advertiser_category"
          },
          "public_description": {
            "type": "string",
            "title": "public_description"
          },
          "comment_score_hide_mins": {
            "type": "number",
            "title": "comment_score_hide_mins"
          },
          "allow_predictions": {
            "type": "boolean",
            "title": "allow_predictions"
          },
          "user_has_favorited": {
            "type": "boolean",
            "title": "user_has_favorited"
          },
          "community_icon": {
            "type": "string",
            "title": "community_icon"
          },
          "banner_background_image": {
            "type": "string",
            "title": "banner_background_image"
          },
          "original_content_tag_enabled": {
            "type": "boolean",
            "title": "original_content_tag_enabled"
          },
          "community_reviewed": {
            "type": "boolean",
            "title": "community_reviewed"
          },
          "submit_text": {
            "type": "string",
            "title": "submit_text"
          },
          "description_html": {
            "type": "string",
            "title": "description_html"
          },
          "spoilers_enabled": {
            "type": "boolean",
            "title": "spoilers_enabled"
          },
          "comment_contribution_settings": {
            "title": "comment_contribution_settings"
          },
          "allow_talks": {
            "type": "boolean",
            "title": "allow_talks"
          },
          "user_flair_position": {
            "type": "string",
            "title": "user_flair_position"
          },
          "all_original_content": {
            "type": "boolean",
            "title": "all_original_content"
          },
          "has_menu_widget": {
            "type": "boolean",
            "title": "has_menu_widget"
          },
          "key_color": {
            "type": "string",
            "title": "key_color"
          },
          "can_assign_user_flair": {
            "type": "boolean",
            "title": "can_assign_user_flair"
          },
          "created": {
            "type": "number",
            "title": "created"
          },
          "wls": {
            "type": "number",
            "title": "wls"
          },
          "show_media_preview": {
            "type": "boolean",
            "title": "show_media_preview"
          },
          "submission_type": {
            "type": "string",
            "title": "submission_type"
          },
          "user_is_subscriber": {
            "type": "boolean",
            "title": "user_is_subscriber"
          },
          "allowed_media_in_comments": {
            "type": "array",
            "items": {},
            "title": "allowed_media_in_comments"
          },
          "allow_videogifs": {
            "type": "boolean",
            "title": "allow_videogifs"
          },
          "should_archive_posts": {
            "type": "boolean",
            "title": "should_archive_posts"
          },
          "user_flair_type": {
            "type": "string",
            "title": "user_flair_type"
          },
          "allow_polls": {
            "type": "boolean",
            "title": "allow_polls"
          },
          "collapse_deleted_comments": {
            "type": "boolean",
            "title": "collapse_deleted_comments"
          },
          "public_description_html": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "public_description_html"
          },
          "allow_videos": {
            "type": "boolean",
            "title": "allow_videos"
          },
          "is_crosspostable_subreddit": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "is_crosspostable_subreddit"
          },
          "should_show_media_in_comments_setting": {
            "type": "boolean",
            "title": "should_show_media_in_comments_setting"
          },
          "can_assign_link_flair": {
            "type": "boolean",
            "title": "can_assign_link_flair"
          },
          "accounts_active_is_fuzzed": {
            "type": "boolean",
            "title": "accounts_active_is_fuzzed"
          },
          "allow_prediction_contributors": {
            "type": "boolean",
            "title": "allow_prediction_contributors"
          },
          "submit_text_label": {
            "type": "string",
            "title": "submit_text_label"
          },
          "link_flair_position": {
            "type": "string",
            "title": "link_flair_position"
          },
          "user_flair_enabled_in_sr": {
            "type": "boolean",
            "title": "user_flair_enabled_in_sr"
          },
          "allow_discovery": {
            "type": "boolean",
            "title": "allow_discovery"
          },
          "accept_followers": {
            "type": "boolean",
            "title": "accept_followers"
          },
          "user_sr_theme_enabled": {
            "type": "boolean",
            "title": "user_sr_theme_enabled"
          },
          "link_flair_enabled": {
            "type": "boolean",
            "title": "link_flair_enabled"
          },
          "disable_contributor_requests": {
            "type": "boolean",
            "title": "disable_contributor_requests"
          },
          "subreddit_type": {
            "type": "string",
            "title": "subreddit_type"
          },
          "banner_img": {
            "type": "string",
            "title": "banner_img"
          },
          "banner_background_color": {
            "type": "string",
            "title": "banner_background_color"
          },
          "show_media": {
            "type": "boolean",
            "title": "show_media"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "user_is_contributor": {
            "type": "boolean",
            "title": "user_is_contributor"
          },
          "over18": {
            "type": "boolean",
            "title": "over18"
          },
          "header_title": {
            "type": "string",
            "title": "header_title"
          },
          "description": {
            "type": "string",
            "title": "description"
          },
          "submit_link_label": {
            "type": "string",
            "title": "submit_link_label"
          },
          "restrict_commenting": {
            "type": "boolean",
            "title": "restrict_commenting"
          },
          "allow_images": {
            "type": "boolean",
            "title": "allow_images"
          },
          "lang": {
            "type": "string",
            "title": "lang"
          },
          "url": {
            "type": "string",
            "title": "url"
          },
          "created_utc": {
            "type": "number",
            "title": "created_utc"
          },
          "mobile_banner_image": {
            "type": "string",
            "title": "mobile_banner_image"
          },
          "user_is_moderator": {
            "type": "boolean",
            "title": "user_is_moderator"
          },
          "allow_predictions_tournament": {
            "type": "boolean",
            "title": "allow_predictions_tournament"
          }
        },
        "required": []
      },
      "IReddit.ISearchSubredditsInput": {
        "type": "object",
        "properties": {
          "q": {
            "type": "string",
            "title": "The search query"
          },
          "count": {
            "type": "integer",
            "minimum": 0,
            "title": "The count of items"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "title": "The number of subreddits to fetch"
          },
          "sort": {
            "oneOf": [
              {
                "const": "relevance"
              },
              {
                "const": "activity"
              }
            ],
            "title": "sort"
          },
          "after": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "after",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "before": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "before",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "q",
          "secretKey"
        ]
      },
      "IReddit.IGetSubredditAboutOutput": {
        "type": "object",
        "properties": {
          "header_img": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "header_img"
          },
          "name": {
            "type": "string",
            "title": "The name of the subreddit"
          },
          "description": {
            "type": "string",
            "title": "The description of the subreddit"
          },
          "subscribers": {
            "type": "number",
            "title": "The number of subscribers"
          },
          "restrict_posting": {
            "type": "boolean",
            "title": "restrict_posting"
          },
          "user_is_banned": {
            "type": "boolean",
            "title": "user_is_banned"
          },
          "free_form_reports": {
            "type": "boolean",
            "title": "free_form_reports"
          },
          "user_is_muted": {
            "type": "boolean",
            "title": "user_is_muted"
          },
          "display_name": {
            "type": "string",
            "title": "display_name"
          },
          "title": {
            "type": "string",
            "title": "title"
          },
          "allow_galleries": {
            "type": "boolean",
            "title": "allow_galleries"
          },
          "primary_color": {
            "type": "string",
            "title": "primary_color"
          },
          "icon_img": {
            "type": "string",
            "title": "icon_img"
          },
          "display_name_prefixed": {
            "type": "string",
            "title": "display_name_prefixed"
          },
          "public_traffic": {
            "type": "boolean",
            "title": "public_traffic"
          },
          "user_flair_richtext": {
            "type": "array",
            "items": {},
            "title": "user_flair_richtext"
          },
          "videostream_links_count": {
            "type": "number",
            "title": "videostream_links_count"
          },
          "quarantine": {
            "type": "boolean",
            "title": "quarantine"
          },
          "hide_ads": {
            "type": "boolean",
            "title": "hide_ads"
          },
          "prediction_leaderboard_entry_type": {
            "type": "number",
            "title": "prediction_leaderboard_entry_type"
          },
          "emojis_enabled": {
            "type": "boolean",
            "title": "emojis_enabled"
          },
          "advertiser_category": {
            "type": "string",
            "title": "advertiser_category"
          },
          "public_description": {
            "type": "string",
            "title": "public_description"
          },
          "comment_score_hide_mins": {
            "type": "number",
            "title": "comment_score_hide_mins"
          },
          "allow_predictions": {
            "type": "boolean",
            "title": "allow_predictions"
          },
          "user_has_favorited": {
            "type": "boolean",
            "title": "user_has_favorited"
          },
          "community_icon": {
            "type": "string",
            "title": "community_icon"
          },
          "banner_background_image": {
            "type": "string",
            "title": "banner_background_image"
          },
          "original_content_tag_enabled": {
            "type": "boolean",
            "title": "original_content_tag_enabled"
          },
          "community_reviewed": {
            "type": "boolean",
            "title": "community_reviewed"
          },
          "submit_text": {
            "type": "string",
            "title": "submit_text"
          },
          "description_html": {
            "type": "string",
            "title": "description_html"
          },
          "spoilers_enabled": {
            "type": "boolean",
            "title": "spoilers_enabled"
          },
          "comment_contribution_settings": {
            "title": "comment_contribution_settings"
          },
          "allow_talks": {
            "type": "boolean",
            "title": "allow_talks"
          },
          "user_flair_position": {
            "type": "string",
            "title": "user_flair_position"
          },
          "all_original_content": {
            "type": "boolean",
            "title": "all_original_content"
          },
          "has_menu_widget": {
            "type": "boolean",
            "title": "has_menu_widget"
          },
          "key_color": {
            "type": "string",
            "title": "key_color"
          },
          "can_assign_user_flair": {
            "type": "boolean",
            "title": "can_assign_user_flair"
          },
          "created": {
            "type": "number",
            "title": "created"
          },
          "wls": {
            "type": "number",
            "title": "wls"
          },
          "show_media_preview": {
            "type": "boolean",
            "title": "show_media_preview"
          },
          "submission_type": {
            "type": "string",
            "title": "submission_type"
          },
          "user_is_subscriber": {
            "type": "boolean",
            "title": "user_is_subscriber"
          },
          "allowed_media_in_comments": {
            "type": "array",
            "items": {},
            "title": "allowed_media_in_comments"
          },
          "allow_videogifs": {
            "type": "boolean",
            "title": "allow_videogifs"
          },
          "should_archive_posts": {
            "type": "boolean",
            "title": "should_archive_posts"
          },
          "user_flair_type": {
            "type": "string",
            "title": "user_flair_type"
          },
          "allow_polls": {
            "type": "boolean",
            "title": "allow_polls"
          },
          "collapse_deleted_comments": {
            "type": "boolean",
            "title": "collapse_deleted_comments"
          },
          "public_description_html": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "public_description_html"
          },
          "allow_videos": {
            "type": "boolean",
            "title": "allow_videos"
          },
          "is_crosspostable_subreddit": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "is_crosspostable_subreddit"
          },
          "should_show_media_in_comments_setting": {
            "type": "boolean",
            "title": "should_show_media_in_comments_setting"
          },
          "can_assign_link_flair": {
            "type": "boolean",
            "title": "can_assign_link_flair"
          },
          "accounts_active_is_fuzzed": {
            "type": "boolean",
            "title": "accounts_active_is_fuzzed"
          },
          "allow_prediction_contributors": {
            "type": "boolean",
            "title": "allow_prediction_contributors"
          },
          "submit_text_label": {
            "type": "string",
            "title": "submit_text_label"
          },
          "link_flair_position": {
            "type": "string",
            "title": "link_flair_position"
          },
          "user_flair_enabled_in_sr": {
            "type": "boolean",
            "title": "user_flair_enabled_in_sr"
          },
          "allow_discovery": {
            "type": "boolean",
            "title": "allow_discovery"
          },
          "accept_followers": {
            "type": "boolean",
            "title": "accept_followers"
          },
          "user_sr_theme_enabled": {
            "type": "boolean",
            "title": "user_sr_theme_enabled"
          },
          "link_flair_enabled": {
            "type": "boolean",
            "title": "link_flair_enabled"
          },
          "disable_contributor_requests": {
            "type": "boolean",
            "title": "disable_contributor_requests"
          },
          "subreddit_type": {
            "type": "string",
            "title": "subreddit_type"
          },
          "banner_img": {
            "type": "string",
            "title": "banner_img"
          },
          "banner_background_color": {
            "type": "string",
            "title": "banner_background_color"
          },
          "show_media": {
            "type": "boolean",
            "title": "show_media"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "user_is_contributor": {
            "type": "boolean",
            "title": "user_is_contributor"
          },
          "over18": {
            "type": "boolean",
            "title": "over18"
          },
          "header_title": {
            "type": "string",
            "title": "header_title"
          },
          "submit_link_label": {
            "type": "string",
            "title": "submit_link_label"
          },
          "restrict_commenting": {
            "type": "boolean",
            "title": "restrict_commenting"
          },
          "allow_images": {
            "type": "boolean",
            "title": "allow_images"
          },
          "lang": {
            "type": "string",
            "title": "lang"
          },
          "url": {
            "type": "string",
            "title": "url"
          },
          "created_utc": {
            "type": "number",
            "title": "created_utc"
          },
          "mobile_banner_image": {
            "type": "string",
            "title": "mobile_banner_image"
          },
          "user_is_moderator": {
            "type": "boolean",
            "title": "user_is_moderator"
          },
          "allow_predictions_tournament": {
            "type": "boolean",
            "title": "allow_predictions_tournament"
          }
        },
        "required": [
          "name",
          "description",
          "subscribers"
        ]
      },
      "IReddit.IGetSubredditAboutInput": {
        "type": "object",
        "properties": {
          "subreddit": {
            "type": "string",
            "pattern": "^(r\\/(.*))",
            "title": "The subreddit to fetch information for"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "subreddit",
          "secretKey"
        ]
      },
      "IReddit.IGetPopularSubredditsOutput": {
        "type": "object",
        "properties": {
          "after": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The after cursor for pagination"
          },
          "dist": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The number of items returned"
          },
          "modhash": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The modhash for the request"
          },
          "geo_filter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The geographical filter applied"
          },
          "children": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "kind": {
                  "const": "t5",
                  "title": "kind"
                },
                "data": {
                  "$ref": "#/components/schemas/IReddit.SubReddit",
                  "title": "data"
                }
              },
              "required": [
                "kind",
                "data"
              ]
            },
            "title": "The list of children sub-reddits"
          },
          "before": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The before cursor for pagination"
          }
        },
        "required": [
          "after",
          "dist",
          "modhash",
          "geo_filter",
          "children",
          "before"
        ]
      },
      "IReddit.IGetPopularSubredditsInput": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 25,
            "title": "The number of posts to fetch"
          },
          "after": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "after",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "before": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "before",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IReddit.IGetBestContentOutput": {
        "type": "object",
        "properties": {
          "after": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The after cursor for pagination"
          },
          "dist": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "The number of items returned"
          },
          "modhash": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The modhash for the request"
          },
          "geo_filter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The geographical filter applied"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IReddit.Children"
            },
            "title": "The list of children posts"
          },
          "before": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))"
              }
            ],
            "title": "The before cursor for pagination"
          }
        },
        "required": [
          "after",
          "dist",
          "modhash",
          "geo_filter",
          "children",
          "before"
        ]
      },
      "IReddit.IGetBestContentInput": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 25,
            "title": "The max number of items"
          },
          "after": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "after",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "before": {
            "type": "string",
            "pattern": "^((t2_(.*))|(t1_(.*))|(t6_(.*))|(t3_(.*))|(t5_(.*))|(t4_(.*)))",
            "title": "before",
            "description": "When the value of the 'after' parameter that came in response to the previous request is substituted,\nit is a parameter for page selection that inquires before and after the value.\nIf omitted, the first page will be viewed unconditionally.\n\nThe prefix t1_, t2_, t3_, t4_, t5_, t6_ attached to the beginning of the value has the following meaning.\n- t1_ : Comment\n- t2_ : Account\n- t3_ : Link\n- t4_ : Message\n- t5_ : Subreddit\n- t6_ : Award"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "reddit",
            "x-wrtn-secret-scopes": [
              "account",
              "history",
              "identity",
              "mysubreddits",
              "read",
              "report",
              "save"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IWebCrawler.IResponse": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "iri",
            "title": "Crawled url"
          },
          "content": {
            "type": "string",
            "title": "Crawled content"
          }
        },
        "required": [
          "url",
          "content"
        ],
        "title": "Response from crawled web page"
      },
      "IWebCrawler.IRequest": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "Target URL to crawl"
          },
          "wait_for": {
            "type": "string",
            "title": "Wait for a CSS selector to appear before returning content. (not required)"
          }
        },
        "required": [
          "url"
        ],
        "title": "Request to crawl a web page"
      },
      "IGoogleImage.IResponse": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "title",
            "description": "Image title"
          },
          "imageUrl": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Image url"
          },
          "thumbnail": {
            "type": "string",
            "format": "iri",
            "title": "thumbnail",
            "description": "Image Thumbnail"
          }
        },
        "required": [
          "title",
          "imageUrl",
          "thumbnail"
        ],
        "title": "Google Image Search Result"
      },
      "IGoogleImage.IRequest": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "title": "Search Query",
            "description": "Set a search query to get images."
          },
          "lang": {
            "type": "string",
            "title": "Language Setting",
            "description": "Choose which language you want to use as your search term.\n\nYou can only pass a single BCP 47 language identifier.\n\nex) You want to setting korean language, you can pass \"ko\"."
          },
          "ratio": {
            "oneOf": [
              {
                "const": "s"
              },
              {
                "const": "t"
              },
              {
                "const": "w"
              },
              {
                "const": "xw"
              }
            ],
            "title": "Image Ratio",
            "description": "Set the ratio of the images to be retrieved as search results"
          }
        },
        "required": [
          "query",
          "lang",
          "ratio"
        ],
        "title": "Google Image Search Condition"
      }
    }
  },
  "tags": [
    {
      "name": "RAG"
    },
    {
      "name": "Hwp"
    },
    {
      "name": "Excel"
    },
    {
      "name": "Google Docs"
    },
    {
      "name": "Google Sheet"
    },
    {
      "name": "Google Calendar"
    },
    {
      "name": "Google Drive"
    },
    {
      "name": "Gmail"
    },
    {
      "name": "Hancel"
    },
    {
      "name": "Kakao Map"
    },
    {
      "name": "Dall-e-3"
    },
    {
      "name": "Google Search"
    },
    {
      "name": "Wanted"
    },
    {
      "name": "Incruit"
    },
    {
      "name": "Saramin"
    },
    {
      "name": "Jumpit"
    },
    {
      "name": "Careerly"
    },
    {
      "name": "Aladin"
    },
    {
      "name": "AliExpress"
    },
    {
      "name": "Coupang"
    },
    {
      "name": "EQL"
    },
    {
      "name": "iHerb"
    },
    {
      "name": "Market Kurly"
    },
    {
      "name": "OCO"
    },
    {
      "name": "Olive Young"
    },
    {
      "name": "29CM"
    },
    {
      "name": "Uniqlo"
    },
    {
      "name": "yes24"
    },
    {
      "name": "Musinsa"
    },
    {
      "name": "Amazon"
    },
    {
      "name": "Ebay"
    },
    {
      "name": "Walmart"
    },
    {
      "name": "Arxiv"
    },
    {
      "name": "Daum"
    },
    {
      "name": "Naver"
    },
    {
      "name": "Youtube"
    },
    {
      "name": "Google Scholar"
    },
    {
      "name": "CSV"
    },
    {
      "name": "Notion"
    },
    {
      "name": "Google Hotel"
    },
    {
      "name": "Search Airport Information"
    },
    {
      "name": "Google Flight"
    },
    {
      "name": "Slack"
    },
    {
      "name": "Jira"
    },
    {
      "name": "Google Map"
    },
    {
      "name": "Github"
    },
    {
      "name": "Marp"
    },
    {
      "name": "pptx"
    },
    {
      "name": "hanshow"
    },
    {
      "name": "ppt"
    },
    {
      "name": "powerpoint"
    },
    {
      "name": "markdown"
    },
    {
      "name": "marp"
    },
    {
      "name": "Web Crawler"
    },
    {
      "name": "Google Image"
    }
  ],
  "x-samchon-emended": true
}