{
  "openapi": "3.1.0",
  "servers": [
    {
      "url": "https://studio-connector-api.wrtn.ai",
      "description": "Production Server"
    },
    {
      "url": "https://studio-connector-poc.dev.wrtn.club",
      "description": "Develop Server"
    },
    {
      "url": "http://localhost:3003",
      "description": "Local Server"
    }
  ],
  "info": {
    "version": "0.1.267",
    "title": "@wrtn/connector",
    "description": "wrtn-ecosystem connectors and sdk",
    "license": {
      "name": "AGPL-3.0-only"
    }
  },
  "paths": {
    "/_health": {
      "get": {
        "description": "health check port",
        "tags": [],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          }
        }
      }
    },
    "/workflow/run": {
      "post": {
        "description": "Run workflow",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IRunWorkflowInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IRunWorkflowOutput"
                }
              }
            }
          }
        }
      }
    },
    "/workflow/run/{workflowRunId}": {
      "get": {
        "description": "Return status of one workflow run",
        "tags": [],
        "parameters": [
          {
            "name": "workflowRunId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IWorkflowRunStatus"
                }
              }
            }
          }
        }
      }
    },
    "/workflow/runs": {
      "get": {
        "description": "Return all workflow run information",
        "tags": [],
        "parameters": [
          {
            "name": "workflowId",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "required": false,
            "title": "Workflow id.",
            "description": "If not specified, returns all runs."
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGetWorkflowRunsOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/extract/keyword": {
      "post": {
        "summary": "Keyword extraction",
        "description": "Extracts keywords highly related to the given input\n\nA connector used when generating marketing copy.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Input for keyword extraction",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKeywordExtraction.IExtractKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Extracted keywords",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKeywordExtraction.IExtractKeywordOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/keyword.svg"
      }
    },
    "/connector/rank/rank": {
      "post": {
        "summary": "Sort by condition",
        "description": "Sorts the given array of items in order of highest score.",
        "deprecated": true,
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Candidate information to sort",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IRanker.IRankInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Array of indices of sorted candidates",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IRanker.IRankOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Sort_full.svg"
      }
    },
    "/connector/marketing-copy/generate-copy": {
      "post": {
        "summary": "Generate marketing copy",
        "description": "Generates marketing copy from given input.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Input for generating marketing copy",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMarketingCopyGenerator.IGenerateMarketingCopyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Generated marketing copy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPartialIMarketingCopyComponents"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Marketing_full.svg"
      }
    },
    "/connector/marketing-copy/generate-copy-image": {
      "post": {
        "summary": "Generate a marketing copy image",
        "description": "Generates a marketing copy image from the given input.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Input for generating a marketing copy image",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMarketingCopyGenerator.IGenerateMarketingCopyImageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Generated marketing copy image",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMarketingCopyImage"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Marketing_full.svg"
      }
    },
    "/connector/aws/file/upload-url": {
      "get": {
        "summary": "Generate File Upload URL",
        "description": "Generate the URL required to upload a file.",
        "tags": [],
        "parameters": [
          {
            "name": "extension",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "required": true,
            "title": "File extension",
            "description": "File extension."
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IAws.IGetPutObjectUrlOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/student-report-generator": {
      "post": {
        "summary": "Create a student life record",
        "description": "Create a student life record based on the entered information.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Information for creating a student life record.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IStudentReportGeneratorRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created student life record.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IStudentReportGeneratorResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/StudentRecord_full.svg"
      }
    },
    "/connector/student-report-generator/row": {
      "post": {
        "summary": "Create a student life record",
        "description": "Create a student life record based on the entered information.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Information for creating a student life record.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IStudentReportRowGeneratorRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created student life record.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IStudentReportRowGeneratorResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/StudentRecord_full.svg"
      }
    },
    "/connector/rag/analyze": {
      "post": {
        "summary": "Request RAG analysis.",
        "description": "Request RAG analysis for the input file.\n\nThis connector can be used when creating a chatbot that compares multiple research papers.",
        "tags": [
          "RAG"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information about the file to be analyzed.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IRag.IAnalyzeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IRag.IAnalysisOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/RAG_full.svg"
      }
    },
    "/connector/rag/{jobId}/status": {
      "get": {
        "summary": "Check RAG analysis status.",
        "description": "Check the analysis progress status.",
        "tags": [
          "RAG"
        ],
        "parameters": [
          {
            "name": "jobId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IRag.IStatusOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/rag/generate/{chatId}": {
      "post": {
        "summary": "Generate RAG-based results",
        "description": "Generates requested results based on RAG analysis.\n\nA connector that can be used to generate answers to user questions through a chatbot that compares multiple research papers.",
        "tags": [
          "RAG"
        ],
        "parameters": [
          {
            "name": "chatId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IRag.IGenerateInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IRag.IGenerateOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/RAG_full.svg"
      }
    },
    "/connector/hwp/parse": {
      "post": {
        "summary": "Parse the Hwp file",
        "description": "Parse the hwp file.",
        "tags": [
          "Hwp"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The hwp file to parse",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IHwp.IParseInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The parsed hwp file text data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IHwp.IParseOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/HWP_full.svg"
      }
    },
    "/connector/excel/read/headers": {
      "post": {
        "summary": "Get the headers in the Excel file",
        "description": "Based on the input file information, the headers of the corresponding Excel file are retrieved.",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IReadExcelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg"
      }
    },
    "/connector/excel/read": {
      "post": {
        "summary": "Get the contents of the Excel file",
        "description": "Get the contents of the corresponding Excel file based on the input file information.",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information on the Excel file to get the contents",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IReadExcelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IReadExcelOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg"
      }
    },
    "/connector/excel/worksheet": {
      "post": {
        "summary": "Get a list of Excel worksheets",
        "description": "Get a list of Excel worksheets that exist in the input file url.",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The url of the Excel file from which to get the list of worksheets",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IGetWorksheetListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of Excel worksheets.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IWorksheetListOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg"
      }
    },
    "/connector/excel/rows/upload": {
      "post": {
        "summary": "엑셀 파일 업로드를 통한 엑셀 생성 및 데이터 추가",
        "description": "엑셀 파일을 업로드하여 파일에 데이터를 추가합니다\n\nWhen adding data to Excel, sheet creation precedes if it is a sheet that does not exist yet.\nTherefore, this feature can also be used for sheet creation.\nIf you want to create a sheet only and create an empty file without any data,\nyou just need to specify the name of the sheet without any data.\n\nWhen adding rows to an already existing sheet,\nit is supposed to be added to the lower line, so it is recommended to check the data before adding it.\nIf you provide fileUrl, you can modify it after you work on it. After modification, the file will be issued as a new link.\n\nIt is a connector that allows users to upload files by drag and drop.",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "엑셀 파일에 새로운 데이터를 추가 하기 위한 정보",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IInsertExcelRowByUploadInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IExportExcelFileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg"
      }
    },
    "/connector/excel/rows": {
      "post": {
        "summary": "엑셀 파일 링크를 가지고 액셀 생성 및 데이터 추가",
        "description": "엑셀 파일 링크를 가지고 엑셀 파일에 데이터를 추가합니다\n\nWhen adding data to Excel, sheet creation precedes if it is a sheet that does not exist yet.\nTherefore, this feature can also be used for sheet creation.\nIf you want to create a sheet only and create an empty file without any data,\nyou just need to specify the name of the sheet without any data.\n\nWhen adding rows to an already existing sheet,\nit is supposed to be added to the lower line, so it is recommended to check the data before adding it.\nIf you provide fileUrl, you can modify it after you work on it. After modification, the file will be issued as a new link.\n\nA connector that allows you to update a file without uploading it if you know the link to the file in the previous utterance, or if you receive a file link in the utterance from the user.\n\nSince a link to the Excel file generated immediately after the Excel file is generated, calling this connector is more advantageous in terms of user experience than adding data through upload.",
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "엑셀 파일에 새로운 데이터를 추가 하기 위한 정보",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.IInsertExcelRowInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IExportExcelFileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg"
      }
    },
    "/connector/excel": {
      "post": {
        "summary": "Add Excel files and sheet",
        "description": "Add Excel files and sheet\n\nCreate an Excel file and get the link back.\nYou can also forward this link to the following connector to reflect further modifications.\nWhen creating a sheet with this feature, the default name 'Sheet1' is created if the sheet name is not provided.",
        "deprecated": true,
        "tags": [
          "Excel"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IExcel.ICreateSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IExcel.IExportExcelFileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/light/excel.svg"
      }
    },
    "/connector/google-docs": {
      "post": {
        "summary": "Generate Google Docs",
        "description": "Generate Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Title of Google Docs to generate",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ICreateGoogleDocsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Unique ID of generated Google Docs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.ICreateGoogleDocsOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-docs/permission": {
      "post": {
        "summary": "Grant permission to Google Docs",
        "description": "Grant permission to Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for granting permission to Google Docs",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.IPermissionGoogleDocsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/connector/google-docs/get/{id}": {
      "post": {
        "summary": "Read Google Docs",
        "description": "Read the contents of Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-docs/get-list",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "description": " Google Docs unique ID"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Google Docs contents",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.IReadGoogleDocsOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/connector/google-docs/template": {
      "post": {
        "summary": "Copy Google Docs",
        "description": "Create new Google Docs by copying existing Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Links to Google Docs to copy and titles of Google Docs to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ICreateDocByTemplateInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Unique ID of the generated Google Docs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.ICreateDocByTemplateOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/connector/google-docs/{id}": {
      "delete": {
        "summary": "Delete Google Docs",
        "description": "Delete Google Docs.",
        "tags": [
          "Google Docs"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-docs/get-list",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "description": " Unique ID of the Google Docs to delete"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/connector/google-docs/get-list": {
      "post": {
        "summary": "Get a list of Google Docs",
        "description": "Get a list of Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "a list of Google Docs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDocs.IListGoogleDocsOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-docs/append": {
      "post": {
        "summary": "Add text to Google Docs",
        "description": "Add text to Google Docs",
        "tags": [
          "Google Docs"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDocs.IAppendTextGoogleDocsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Google+Docs_full.svg"
      }
    },
    "/internal/google": {
      "get": {
        "description": "Request to reissue Google access token",
        "tags": [],
        "parameters": [],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/connector/google-sheet": {
      "post": {
        "summary": "Get the header information of a Google Sheet.",
        "description": "Get the header information of a Google Sheet.",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Google Sheet URL and the header index to get.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetHeadersInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Google Sheet header information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/append": {
      "post": {
        "summary": "Add content to Google Sheets",
        "description": "Add content to Google Sheets.",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information to add content",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IAppendToSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg"
      }
    },
    "/connector/google-sheet/create": {
      "post": {
        "summary": "Create a Google Sheet",
        "description": "Create a Google Sheet.\n\nThe created sheet will be created in the Google Drive root path.",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The title of the sheet to be created",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.ICreateGoogleSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created sheet id and Url",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.ICreateGoogleSheetOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/permission": {
      "post": {
        "summary": "Grant permissions to Google Sheets.",
        "description": "Grant permissions to Google Sheets.",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for granting permissions.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IPermissionInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/header": {
      "post": {
        "summary": "Add a Google Sheet header.",
        "description": "Add a header to a Google Sheet.",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The Google Sheet url and the header name to add.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IWriteGoogleSheetHeadersInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/worksheet": {
      "post": {
        "summary": "Get a list of Google Sheets Worksheets.",
        "description": "Get a list of Google Worksheets.",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The Google Sheets url to get the list of worksheets.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IGetWorkSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.IGetWorkSheetOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-sheet/get-rows": {
      "post": {
        "summary": "Get Row information from Google Sheets.",
        "description": "Get Row information from Google Sheets.",
        "tags": [
          "Google Sheet"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetRowsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Row information from Google Sheets.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetRowsOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSheet_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-calendar/get-list": {
      "post": {
        "summary": "Get a list of Google Calendars.",
        "description": "Get a list of Google Calendars.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of Google Calendars.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-calendar": {
      "post": {
        "summary": "Create a Google Calendar.",
        "description": "Create a Google Calendar.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The title of the calendar to be created.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ICreateCalendarInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The unique ID of the calendar and the title of the calendar.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-calendar/{calendarId}": {
      "delete": {
        "summary": "Delete a Google Calendar.",
        "description": "Delete a calendar.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "title": "The unique ID of the calendar to delete",
            "description": " The unique ID of the calendar to delete."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg"
      }
    },
    "/connector/google-calendar/{calendarId}/get-events": {
      "post": {
        "summary": "Get a list of Google Calendar events.",
        "description": "Get a list of events in Google Calendar.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the calendar to get the list of events",
            "description": " Unique ID of the calendar to get the list of events."
          }
        ],
        "requestBody": {
          "description": "Condition to get the list of events.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.IReadGoogleCalendarEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of Google Calendar events.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IReadGoogleCalendarEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg"
      }
    },
    "/connector/google-calendar/{calendarId}/quick-event": {
      "post": {
        "summary": "Add a quick event to Google Calendar.",
        "description": "Add a quick event to Google Calendar.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the calendar to add the event to",
            "description": " Unique ID of the calendar to add the event to."
          }
        ],
        "requestBody": {
          "description": "Unique ID of the calendar to add the event to, and the event name.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ICreateQuickEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg"
      }
    },
    "/connector/google-calendar/{calendarId}/event": {
      "post": {
        "summary": "Add a Google Calendar event.",
        "description": "Add an event to Google Calendar.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the calendar to add the event to",
            "description": " Unique ID of the calendar to add the event to."
          }
        ],
        "requestBody": {
          "description": "Information for adding the event.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.IEventRequestBodyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information about the added event.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg"
      }
    },
    "/connector/google-calendar/{calendarId}/event/{eventId}": {
      "put": {
        "summary": "Modify a Google Calendar event.",
        "description": "Modify an event.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the calendar that contains the event",
            "description": " Unique ID of the calendar that contains the event."
          },
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/{calendarId}/get-events",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the event to modify",
            "description": " Unique ID of the event to modify."
          }
        ],
        "requestBody": {
          "description": "The event information to update.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.IEventRequestBodyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The updated event information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg"
      },
      "delete": {
        "summary": "Delete a Google Calendar event.",
        "description": "Delete an event.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "title": "The unique ID of the calendar that contains the event",
            "description": " The unique ID of the calendar that contains the event."
          },
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/{calendarId}/get-events",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "title": "The unique ID of the event to delete",
            "description": " The unique ID of the event to delete."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg"
      }
    },
    "/connector/google-calendar/{calendarId}/event/{eventId}/attendees": {
      "put": {
        "summary": "Add attendees to a Google Calendar event.",
        "description": "Add attendees to an event.",
        "tags": [
          "Google Calendar"
        ],
        "parameters": [
          {
            "name": "calendarId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/get-list",
                "jmesPath": "[].{value:id, label:summary || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the calendar where the event is",
            "description": " Unique ID of the calendar where the event is."
          },
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-calendar/{calendarId}/get-events",
                "jmesPath": "[].{value: id, label: title || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the event to add attendees to",
            "description": " Unique ID of the event to add attendees to."
          }
        ],
        "requestBody": {
          "description": "List of email addresses of attendees to add.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleCalendar.IAddAttendeesToEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Event information with attendees added.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleCal_full.svg"
      }
    },
    "/connector/google-drive/get/folders": {
      "post": {
        "summary": "Get a list of Google Drive folders.",
        "description": "Get a list of folders in Google Drive.",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of Google Drive folders.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.IFolderListGoogleDriveOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-drive/get/files": {
      "post": {
        "summary": "Get a list of Google Drive files.",
        "description": "Get a list of files in Google Drive.",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.IFileListGoogleDriveInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of Google Drive files.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.IFileListGoogleDriveOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg"
      }
    },
    "/connector/google-drive/folder": {
      "post": {
        "summary": "Create a Google Drive folder.",
        "description": "Create a new folder in Google Drive.",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The name of the folder to be created.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ICreateFolderGoogleDriveInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The unique ID of the created folder.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.ICreateFolderGoogleDriveOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-drive/file": {
      "post": {
        "summary": "Create a Google Drive file.",
        "description": "Create a new file in Google Drive.",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The name of the file to be created and the unique ID of the folder where the file will be created.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.IUploadFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The unique ID of the created file.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.ICreateFileGoogleDriveOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg"
      }
    },
    "/connector/google-drive/file/{id}": {
      "delete": {
        "summary": "Delete a Google Drive file.",
        "description": "Delete a file in Google Drive.",
        "tags": [
          "Google Drive"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-drive/get/files",
                "jmesPath": "data[].{value: id || '', label: name || ''}"
              }
            },
            "required": true,
            "title": "The unique ID of the file to be deleted",
            "description": " The unique ID of the file to be deleted."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg"
      }
    },
    "/connector/google-drive/folder/{id}": {
      "delete": {
        "summary": "Delete a Google Drive folder.",
        "description": "Delete a folder in Google Drive.",
        "tags": [
          "Google Drive"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-drive/get/folders",
                "jmesPath": "data[].{value: id || '', label: name || ''}"
              }
            },
            "required": true,
            "title": "The unique ID of the folder to be deleted",
            "description": " The unique ID of the folder to be deleted."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg"
      }
    },
    "/connector/google-drive/permission": {
      "post": {
        "summary": "Grant Google Drive permission.",
        "description": "Grants permission to access a file or folder.",
        "tags": [
          "Google Drive"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for granting permission.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.IPermissionGoogleDriveInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg"
      }
    },
    "/connector/google-drive/get/file/{id}": {
      "post": {
        "summary": "Read text from a Google Drive file.",
        "description": "Read text from a file.",
        "tags": [
          "Google Drive"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-drive/get/files",
                "jmesPath": "data[].{value: id || '', label: name || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the file",
            "description": " Unique ID of the file."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleDrive.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The text content of the file.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleDrive.IGetFileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleDrive_full.svg"
      }
    },
    "/connector/llm/selector-llm": {
      "post": {
        "summary": "Select condition",
        "description": "Select a candidate that satisfies the conditions from the given candidates.",
        "tags": [
          "Llm"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Input for candidate selection",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISelectorLlmRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Array of selected candidate indices",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISelectorLlmResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/LLM_full.svg"
      }
    },
    "/connector/gmail/send": {
      "post": {
        "summary": "GMAIL Send",
        "description": "Sending mail\n\nGmail is a free web-based email service provided by Google.\n\nThis connector is for sending emails,\nand if you send it as simple text, the sentences will be displayed as one long line, so you need to insert a line break character.\nThe current format uses `text/html; charset=utf-8` as content-type.\nIn some cases, you can use the HTML format.\n\nIf you want to attach a file, you must specify the name of the file and the address at which it is stored.\nThe saved file is read as a GET request inside the function, encoded, and processed.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information needed to send an email.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ICreateMailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "ID of the sent email.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.ISendMailOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/gmail/draft": {
      "post": {
        "summary": "Create GMAIL Draft",
        "description": "Create a mail draft\n\nGmail is a free web-based email service provided by Google.\n\nThis connector is for sending emails,\nand if you send it as simple text, the sentences will be displayed as one long line, so you need to insert a line break character.\nThe current format uses `text/html; charset=utf-8` as content-type.\nIn some cases, you can use the html format.\n\nIf you want to attach a file, you must specify the name of the file and the address at which it is stored.\nThe saved file is read as a GET request inside the function, encoded, and processed.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for creating a mail draft.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ICreateMailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/gmail/reply/{id}": {
      "post": {
        "summary": "GMAIL Reply",
        "description": "Reply to received email\n\nGmail is a free web-based email service provided by Google.\n\nThis connector is for sending emails,\nand if you send it as simple text, the sentences will be displayed as one long line, so you need to insert a line break character.\nThe current format uses `text/html; charset=utf-8` as content-type.\nIn some cases, you can also use the HTML format.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true
          }
        ],
        "requestBody": {
          "description": "Information required for replying to emails.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IReplyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg"
      }
    },
    "/connector/gmail/get/{id}": {
      "post": {
        "summary": "Get GMAIL information",
        "description": "Get information about a mail\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the email",
            "description": " Unique ID of the email."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information about the email.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.IFindGmailOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg"
      }
    },
    "/connector/gmail/read-list": {
      "post": {
        "summary": "Get GMAIL list",
        "description": "Get mailing list\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for getting mailing list.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IFindEmailListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Mailing list.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.IFindGmailListOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/gmail/{id}/hardDelete": {
      "delete": {
        "summary": "Delete mail.",
        "description": "Delete mail\n\nGmail is a free web-based email service provided by Google.\n\nThis function requires special attention because it permanently deletes mail instead of moving it to the trash.\n\nMost users will want to delete mail that is already in the trash.\n\nTherefore, if the user wants to delete it, it is better to guide them to move the mail to the trash, but if they still want to delete it, it is right to target the trash.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg"
      }
    },
    "/connector/gmail/{id}": {
      "delete": {
        "summary": "Delete GMAIL",
        "description": "Move mail to trash\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true,
            "title": "The unique ID of the email to be deleted",
            "description": " The unique ID of the email to be deleted."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg"
      }
    },
    "/connector/gmail/label": {
      "post": {
        "summary": "Create GMAIL label",
        "description": "Create a label\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for creating a label.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.ILabelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Unique ID of the created label.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGmail.ILabelOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/gmail/label/{mailId}": {
      "post": {
        "summary": "GMAIL Label Assignment",
        "description": "Assign a label to a mail\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "mailId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the mail to assign a label to",
            "description": " Unique ID of the mail to assign a label to."
          }
        ],
        "requestBody": {
          "description": "A list of unique IDs of labels to assign.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IMailLabelOperationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg"
      },
      "delete": {
        "summary": "Remove GMAIL labels",
        "description": "Remove labels assigned to mail\n\nGmail is a free web-based email service provided by Google.",
        "tags": [
          "Gmail"
        ],
        "parameters": [
          {
            "name": "mailId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/gmail/read-list",
                "jmesPath": "data[].{value: id, label: subject || ''}"
              }
            },
            "required": true,
            "title": "Unique ID of the mail from which to remove labels",
            "description": " Unique ID of the mail from which to remove labels."
          }
        ],
        "requestBody": {
          "description": "A list of unique IDs of labels to remove.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGmail.IMailLabelOperationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMail_full.svg"
      }
    },
    "/connector/tool/{id}/generate": {
      "post": {
        "summary": "Use tool",
        "description": "Use tool.\n\nThis connector is a special purpose connector and is not used in general situations.\n\nThis connector is only used when using tools migrated from Studio 1.0.\n\nThis connector is not used when creating general workflows.",
        "tags": [],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITool.IGenerateInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ITool.IGenerateOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "htthttps://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/_Studio1.0Tool_full.svg"
      }
    },
    "/connector/chatbot/generate/easy": {
      "post": {
        "summary": "Use Easy difficulty chatbot",
        "description": "Use a chatbot built with Easy difficulty.\n\nThis connector is a special purpose connector and is not used in general situations.\nThis connector is only used when using a chatbot migrated from Studio 1.0.\nThis connector is not used when creating a chatbot from a general workflow.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Information for using a chatbot built with Easy difficulty",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IChatbot.IChatbotEasyGenerateInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The chatbot's response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IChatbot.IChatbotGenerateOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://gh-devs-be.s3.ap-northeast-2.amazonaws.com/icon/full/_Studio1.0Chatbot_full.svg"
      }
    },
    "/connector/chatbot/generate/hard": {
      "post": {
        "summary": "Use a chatbot with the Hard difficulty level",
        "description": "Use a chatbot built with the Hard difficulty level.\n\nThis connector is a special purpose connector and is not used in general situations.\nThis connector is only used when using a chatbot migrated from Studio 1.0.\nThis connector is not used when creating a chatbot from a general workflow.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Information for using a chatbot built with the Hard difficulty level",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IChatbot.IChatBotHardGenerateInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The chatbot's response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IChatbot.IChatbotGenerateOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/_Studio1.0Chatbot_full.svg"
      }
    },
    "/connector/figma/get-files": {
      "post": {
        "summary": "Import Figma files",
        "description": "Import Figma files",
        "tags": [
          "Figma"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditional values for importing files",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IFigma.IReadFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of Figma files",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IFigma.IReadFileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Figma_full.svg"
      }
    },
    "/connector/figma/comments": {
      "post": {
        "summary": "Write a comment within the canvas",
        "description": "Write a comment",
        "tags": [
          "Figma"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Condition value for writing a comment",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IFigma.IAddCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information about the comment just written",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Comment"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Figma_full.svg"
      }
    },
    "/connector/figma/get-comments": {
      "post": {
        "summary": "Get Figma comments",
        "description": "Get Figma comments",
        "tags": [
          "Figma"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Condition value to get comments",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IFigma.IReadCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of Figma comments",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetCommentsResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Figma_full.svg"
      }
    },
    "/connector/figma/projects/{id}/get-canvas": {
      "post": {
        "summary": "Search for canvases within a team",
        "description": "Get all canvases of a specific project\n\nCanvases are Figma files managed by a specific team.\n\nThis connector allows users to see which canvases are managed within their Figma team, along with their canvas names and thumbnail links.",
        "tags": [
          "Figma"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/figma/get-projects",
                "jmesPath": "proejcts[].{value:id, label:name}"
              }
            },
            "required": true,
            "description": " The ID of the project to search"
          }
        ],
        "requestBody": {
          "description": "Search conditions for projects",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IFigma.Secret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "All files in the project",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IFigma.IGetProjectFileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Figma_full.svg"
      }
    },
    "/connector/figma/get-statistics": {
      "post": {
        "summary": "Retrieve team-level Figma statistics",
        "description": "Retrieve team-level statistics",
        "tags": [
          "Figma"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for retrieving team-level statistics",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IFigma.IGetProjectStatisticsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Results of team-level statistics retrieval",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IFigma.IGetStatisticsOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Figma_full.svg"
      }
    },
    "/connector/figma/get-projects": {
      "post": {
        "summary": "Search for projects within a team",
        "description": "Search for projects within a team\n\nAs an argument, it should receive teamId, which is the team ID, and can be found by looking at the URL path of figma.\nWhen accessing the link `https://www.figma.com/files/team`, a number is automatically added after the `team` keyword, which is the team ID.\nA user can belong to multiple teams, so if you do not want to automate the search for these projects, you need to get a different team ID.",
        "tags": [
          "Figma"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Project search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IFigma.IGetProjectInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Project list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IFigma.IGetProejctOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Figma_full.svg"
      }
    },
    "/connector/zoom/meetings": {
      "post": {
        "summary": "Create a zoom meeting.",
        "description": "Create a zoom meeting.",
        "tags": [
          "Zoom"
        ],
        "parameters": [],
        "requestBody": {
          "description": "DTO of the user information and conditions for creating a meeting.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IZoom.ICreateMeetingInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "DTO of the created zoom meeting information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPartialIZoom.Meeting"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Zoom_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/sweet-tacker/get-companies/recommended": {
      "post": {
        "summary": "Search for a list of couriers matching the invoice number",
        "description": "Search for a list of couriers matching the invoice number\n\nA courier code is essential to search for an invoice.\nTherefore, if a user knows the invoice number but does not know which courier will deliver his or her parcel, he or she cannot search for the invoice.\nTo solve this problem, this connector provides a function that infers the courier matching the invoice number.\nHowever, even if this function is called, multiple couriers that may be couriers may appear, so it is impossible to know which company will transport this parcel.\n\nOf course, if there is only one target in the list, the probability that it will be that courier is almost 100%.",
        "tags": [
          "SweetTracker"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for courier search",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISweetTracker.IGetRecommendedCompanyListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of couriers",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISweetTracker.IGetRecommendedCompanyListOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/delivery_full.svg"
      }
    },
    "/connector/sweet-tacker/get-companies": {
      "post": {
        "summary": "Search for courier list",
        "description": "Search for the courier list\n\nSearch for all domestic and international courier companies in Korea.\nWhen searching for delivery through the invoice number later, you will need the courier code, so you must search for the courier list first.\nAfter searching for the courier list, find your courier and provide the courier code when searching for the invoice.",
        "tags": [
          "SweetTracker"
        ],
        "parameters": [],
        "responses": {
          "201": {
            "description": "List of couriers",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISweetTracker.IGetCompanyListOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/delivery_full.svg"
      }
    },
    "/connector/sweet-tacker/tracking-info": {
      "post": {
        "summary": "Invoice search",
        "description": "Search for the invoice number\n\nTo search for an invoice, you need the courier code in addition to the invoice number you want to search for.\nIf you know which courier will transport your package, you can search for the courier and get the courier code from the courier whose name matches the courier code.\nIf you know the invoice number but do not know the courier code, you can use 'Search for a list of couriers matching the invoice number' to infer the courier that will transport your package.\nWhen you search for a package, you can find out the current location and time of the package, as well as who is transporting the package.\nIn some cases, there may be a phone number, but it is not absolute.\nIn addition, in cases where the product is delivered directly by an commerce company such as Coupang, there are cases where you cannot search even if you have the invoice number.",
        "tags": [
          "SweetTracker"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching the invoice number",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISweetTracker.IGetTrackingInfoInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The movement path of the package",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISweetTracker.IGetTrackingInfoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/delivery_full.svg"
      }
    },
    "/connector/hancell/sheet": {
      "post": {
        "summary": "Modify Hansel",
        "description": "Modify a Hansel sheet.\n\nIf the sheet already exists, modify it, or add it if it did not exist before.",
        "tags": [
          "Hancel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Hansel information to modify",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IHancell.IUpsertSheetInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Link to the newly created file after modification",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IHancell.IUpsertSheetOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Hancel_full.svg"
      }
    },
    "/connector/hancell/read": {
      "post": {
        "summary": "Read a Hansel file",
        "description": "Read a Hansel file.",
        "tags": [
          "Hancel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Hansel file information to read",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IHancell.IReadHancellInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Hansel file information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IHancell.IReadHancellOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Hancel_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/message/text": {
      "post": {
        "summary": "Send a message to a KakaoTalk(카카오톡) friend",
        "description": "Sends a text type KakaoTalk(카카오톡) message to a friend\n\nKakaoTalk(카카오톡) is a mobile messenger application in South Korea, which also provides various additional services.\nIf it is not specified who the user wants to send the message, it should not be sent at will.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for sending the message",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.ISendKakaoTalkToFriendsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response and failure information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.ISendKakaoTalkToFriendsOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg"
      }
    },
    "/connector/kakao-talk/memo/commerce": {
      "post": {
        "summary": "Send a message to myself on KakaoTalk(카카오톡)",
        "description": "Sends a commerce type message to myself on KakaoTalk(카카오톡)\n\nWhen sending a KakaoTalk(카카오톡) message, there are buttons. If you want to add a link to the button, you should use a URL starting with `https://studio-pro.wrtn.ai/` or a redirect link. If the link starts with `https://studio-pro.wrtn.ai/`, the page will be viewed, otherwise, it will redirect to the new link. This is because only links registered in our domain are allowed according to the KakaoTalk(카카오톡) API specifications.\n\nKakaoTalk(카카오톡) is a mobile messenger application in South Korea, which also provides various additional services.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for sending the message",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.ISendKakaoTalkCommerceInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response code",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IMemoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/memo/location": {
      "post": {
        "summary": "Send a message to myself on KakaoTalk(카카오톡)",
        "description": "Sends a location type message to myself on KakaoTalk(카카오톡)\n\nWhen sending a KakaoTalk(카카오톡) message, there are buttons. If you want to add a link to the button, you should use a URL starting with `https://studio-pro.wrtn.ai/` or a redirect link. If the link starts with `https://studio-pro.wrtn.ai/`, the page will be viewed, otherwise, it will redirect to the new link. This is because only links registered in our domain are allowed according to the KakaoTalk(카카오톡) API specifications.\n\nKakaoTalk(카카오톡) is a mobile messenger application in South Korea, which also provides various additional services.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for sending the message",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.ISendKakaoTalkLocationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response code",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IMemoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/memo/list": {
      "post": {
        "summary": "Send a message to myself on KakaoTalk(카카오톡)",
        "description": "Sends a list type message to myself on KakaoTalk(카카오톡)\n\nWhen sending a KakaoTalk(카카오톡) message, there are buttons. If you want to add a link to the button, you should use a URL starting with `https://studio-pro.wrtn.ai/` or a redirect link. If the link starts with `https://studio-pro.wrtn.ai/`, the page will be viewed, otherwise, it will redirect to the new link. This is because only links registered in our domain are allowed according to the KakaoTalk(카카오톡) API specifications.\n\nKakaoTalk(카카오톡) is a mobile messenger application in South Korea, which also provides various additional services.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for sending the message",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.ISendKakaoTalkListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response code",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IMemoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/memo/feed": {
      "post": {
        "summary": "Send a message to myself on KakaoTalk(카카오톡)",
        "description": "Sends a feed type message to myself on KakaoTalk(카카오톡)\n\nWhen sending a KakaoTalk(카카오톡) message, there are buttons. If you want to add a link to the button, you should use a URL starting with `https://studio-pro.wrtn.ai/` or a redirect link. If the link starts with `https://studio-pro.wrtn.ai/`, the page will be viewed, otherwise, it will redirect to the new link. This is because only links registered in our domain are allowed according to the KakaoTalk(카카오톡) API specifications.\n\nKakaoTalk(카카오톡) is a mobile messenger application in South Korea, which also provides various additional services.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for sending the message",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.ISendKakaoTalkFeedInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response code",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IMemoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/memo/text": {
      "post": {
        "summary": "Send a message to myself on KakaoTalk(카카오톡)",
        "description": "Sends a text type message to myself on KakaoTalk(카카오톡)\n\nWhen sending a KakaoTalk(카카오톡) message, there are buttons. If you want to add a link to the button, you should use a URL starting with `https://studio-pro.wrtn.ai/` or a redirect link. If the link starts with `https://studio-pro.wrtn.ai/`, the page will be viewed, otherwise, it will redirect to the new link. This is because only links registered in our domain are allowed according to the KakaoTalk(카카오톡) API specifications.\n\nKakaoTalk(카카오톡) is a mobile messenger application in South Korea, which also provides various additional services.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for sending the message",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.ISendKakaoTalkTextInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response code",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IMemoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/calendars/events": {
      "post": {
        "summary": "Add an event to the KakaoTalk(카카오톡) calendar",
        "description": "Adds an event to the KakaoTalk(카카오톡) calendar\n\nKakaoTalk(카카오톡) is a mobile messenger application in South Korea, which also provides various additional services.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Input conditions for creating an event",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.ICreateEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Created event ID condition",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.ICreateEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/get-friends": {
      "post": {
        "summary": "Retrieve the list of friends on KakaoTalk(카카오톡)",
        "description": "Retrieves the list of friends on KakaoTalk(카카오톡)\n\nKakaoTalk(카카오톡) is a mobile messenger application in South Korea, which also provides various additional services.\nWhen looking up your friends, only those who linked Kakao Talk in studio-pro will be searched, so you may not be able to check the target.\nIn this case, it might be better to send a message by email or other means.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for retrieving the friend list",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.IGetFriendsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Retrieved friend list",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IGetFriendsOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/get-events": {
      "post": {
        "summary": "Retrieve KakaoTalk(카카오톡) calendar events",
        "description": "Retrieves KakaoTalk(카카오톡) calendar events.\n\nThe user needs to provide the calendar ID as an input parameter.\nIf no calendar is provided, it defaults to retrieving the user's own calendar.\nTherefore, this feature can be used even if no calendar ID is specified.\n\nThe conditions for retrieving events include specifying the period for which events are to be fetched.\nThis connector is designed to view data for either a week or a month.\n\nKakaoTalk(카카오톡) is a mobile messaging application in South Korea, and it also provides additional services.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "DTO for event retrieval.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ISecretkakaotalk_calendarcalender_id(stringDefaultprimaryPlaceholderprimaryPrerequisitemethodpostpath/connector/kakao-talk/get-calendarsjmesPathcalendars.valueidlabelnamesubscribe_calendars.valueidlabelname)undefinedpres..."
                  },
                  {
                    "$ref": "#/components/schemas/ISecretkakaotalk_calendarcalender_id(stringDefaultprimaryPlaceholderprimaryPrerequisitemethodpostpath/connector/kakao-talk/get-calendarsjmesPathcalendars.valueidlabelnamesubscribe_calendars.valueidlabelname)undefinedpres....o1"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "DTO containing event information.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/get-calendars": {
      "post": {
        "summary": "Retrieve KakaoTalk(카카오톡) calendar lists",
        "description": "Retrieves all KakaoTalk(카카오톡) calendar lists\n\nThere are two types of calendars: your primary calendars and calendars you are subscribed to.\nAll Kakao users have their own personal calendars, so there will be at least one calendar.\nThe primary calendar has an ID of `primary`, which is the user's own calendar.\n\nKakaoTalk(카카오톡) is a mobile messenger application from South Korea that also provides additional services.",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Request DTO to retrieve calendars.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICommon.ISecretkakaotalk_calendar"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Calendar list object.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IGetCalendarOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-talk/auth": {
      "get": {
        "description": "Issues a KakaoTalk(카카오톡) access token",
        "tags": [],
        "parameters": [
          {
            "name": "code",
            "in": "query",
            "schema": {
              "type": "string"
            },
            "required": true,
            "title": "KakaoTalk OAuth2 authorization code."
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IGetAccessTokenOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/kakao-talk/refresh": {
      "post": {
        "description": "Refreshes the KakaoTalk(카카오톡) access token",
        "tags": [
          "KakaoTalk"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Request DTO for refresh.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoTalk.IRefreshAccessTokenInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoTalk.IRefreshAccessTokenOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/kakaoTalk_full.svg"
      }
    },
    "/connector/kakao-map/search": {
      "post": {
        "summary": "Kakao Map Search",
        "description": "Search with Kakao Map\n\nIn addition to the place name company, category, and phone number,\nit also provides lot number and road name addresses in the Korean address system.\nIt can be used with public data or other address-based connectors.",
        "tags": [
          "Kakao Map"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search condition",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoMap.SearchByKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoMap.SearchByKeywordOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/KakaoMap_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/kakao-navi/get-future-directions": {
      "post": {
        "summary": "Kakao Navi Directions",
        "description": "Finding directions with Kakao Navi",
        "tags": [
          "Kakao Navi"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Request conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKakaoNavi.IGetFutureDirectionsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Directions results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IKakaoNavi.SuccessCase"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/KakaoNavi_full.svg"
      }
    },
    "/connector/google-slides/presentations/{id}/export/hanshow": {
      "post": {
        "summary": "Export presentations to Hanshow files",
        "description": "Export Google Slides presentations to Hanshow format!",
        "tags": [
          "Google Slide"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " Presentation ID to convert"
          }
        ],
        "requestBody": {
          "description": "Authentication information",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.IExportPresentationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Link to download Hanshow files",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.IExportHanshowOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/presentations/{id}/export/power-point": {
      "post": {
        "summary": "Export presentations to PPT files",
        "description": "Export Google Slides presentations to PowerPoint format!\n\nA connector that can be used when creating stories or picture books.",
        "tags": [
          "Google Slide"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " Presentation ID to convert"
          }
        ],
        "requestBody": {
          "description": "Authentication information",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.IExportPresentationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Link to download PowerPoint files",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.IExportPresentationOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/get-presentations": {
      "post": {
        "summary": "Retrieve a Google Slides presentation.",
        "description": "Retrieve a Google Slides presentation.",
        "tags": [
          "Google Slide"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Condition DTO for retrieving a presentation.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.IGetPresentationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Retrieve presentation information DTO.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.ISimplePresentationIdOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/presentations/{id}/slides/quarter-divisions": {
      "put": {
        "summary": "Add \"QuarterDivision\" type image slides to a Google Slides presentation.",
        "description": "Add \"QuarterDivision\" type slides to a Google Slides presentation\n\nThe \"QuarterDivision\" type slides are templates that are designed to place images and text in the upper left, upper right, lower left, and lower right, like a four-cut cartoon.\nFour images are required for this template, and the text is located right under each image.\n\nYou may need an image when the user asks you to add a slide.\nIn this case, rather than inserting any image, you should first secure the image using a search connector or an image creation connector.\nIt is safe to ask the user for consent to this process.",
        "tags": [
          "Google Slide"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " Presentation id to add slides to"
          }
        ],
        "requestBody": {
          "description": "Template to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.AppendQuarterDivisionSlideInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.ISimplePresentationIdOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/presentations/{id}/slides/entires": {
      "put": {
        "summary": "Add entire type image slides to a Google Slides presentation.",
        "description": "Add \"Entire\" type slides to a Google Slides presentation\n\nThe \"Entire\" type of slide is a template that packs an image all over, and you can't put any extra text in it. Maybe it's usually suitable for putting a cover.\nBecause ordinary presentations have longer horizontal lengths, if you put a square image, gaps on the left and right can appear large.\n\nYou may need an image when the user asks you to add a slide.\nIn this case, rather than inserting any image, you should first secure the image using a search connector or an image creation connector.\nIt is safe to ask the user for consent to this process.",
        "tags": [
          "Google Slide"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " Presentation id to add slides to"
          }
        ],
        "requestBody": {
          "description": "Template to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.AppendEntireSlideInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.ISimplePresentationIdOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/presentations/{id}/slides/landscapes": {
      "put": {
        "summary": "Add \"Landscape\" type image slides to a Google Slides presentation.",
        "description": "Add \"Landscape\" type slides to a Google Slides presentation\n\nThe \"Landscape\" type template fits text underneath with a longer horizontal image tightly packed like a background.\nIt is suitable when the image is highlighted and the text is short.\nIt is suitable for marking images and titles as if they were on display.\n\nYou may need an image when the user asks you to add a slide.\nIn this case, rather than inserting any image, you should first secure the image using a search connector or an image creation connector.\nIt is safe to ask the user for consent to this process.",
        "tags": [
          "Google Slide"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " Presentation id to add slides to"
          }
        ],
        "requestBody": {
          "description": "Template to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.AppendLandscapeSlideInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.ISimplePresentationIdOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/presentations/{id}/slides/squares": {
      "put": {
        "summary": "Add \"Square\" type image slides to a Google Slides presentation.",
        "description": "Add \"Square\" type slides to a Google Slides presentation\n\nThe \"Square\" type slides put square images and text. In this case, you should put at least four to five lines of text, because there is so much space to put text.\nThe picture is on the left, and the text is on the right.\n\nYou may need an image when the user asks you to add a slide.\nIn this case, rather than inserting any image, you should first secure the image using a search connector or an image creation connector.\nIt is safe to ask the user for consent to this process.",
        "tags": [
          "Google Slide"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " Presentation id to add slides to"
          }
        ],
        "requestBody": {
          "description": "Template to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.AppendSquareSlideInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.ISimplePresentationIdOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/presentations/{id}/slides/verticals": {
      "put": {
        "summary": "Add \"Vertical\" type image slides to a Google Slides presentation.",
        "description": "Add \"Vertical\" type slides to a Google Slides presentation\n\nThe \"Vertical\" type is like a square type slide, with an image on the left and text on the right.\nIn this case, unlike the square type, the image is filled to the height of the presentation while maintaining the proportion.\nThis also allows for enough text.\n\nYou may need an image when the user asks you to add a slide.\nIn this case, rather than inserting any image, you should first secure the image using a search connector or an image creation connector.\nIt is safe to ask the user for consent to this process.",
        "tags": [
          "Google Slide"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " Presentation id to add slides to"
          }
        ],
        "requestBody": {
          "description": "Template to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.AppendVerticalSlideInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.ISimplePresentationIdOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/presentations/{id}/image-slide": {
      "put": {
        "summary": "Add image and text slides to a Google Slides presentation.",
        "description": "Add slides to a Google Slides presentation\n\nUse this connector with connector/google-slides/presentations when creating a story or picture book.\nWhen creating a story or picture book, insert the story and pictures created using this connector into the presentation created from connector/google-slides/presentations connector.\nBe careful not to use this connector when creating a story or picture book, as it may result in an empty picture book.\nSlide type must be one of: \"Vertical\", \"Square\", \"Landscape\", \"Entire\", \"QuarterDivision\".\nIt is common to choose a \"Square\" type when there is one image.\n\nYou may need an image when the user asks you to add a slide.\nIn this case, rather than inserting any image, you should first secure the image using a search connector or an image creation connector.\nIt is safe to ask the user for consent to this process.",
        "deprecated": true,
        "tags": [
          "Google Slide"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " Presentation id to add slides to"
          }
        ],
        "requestBody": {
          "description": "Template to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.AppendSlideInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.ISimplePresentationIdOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/google-slides/presentations": {
      "post": {
        "summary": "Create a Google Slides presentation.",
        "description": "Create a Google Slides presentation.\n\nThis connector can be used when creating a story or picture book.\nPlease use it with the connector/google-slides/image-slide connector when creating a story or picture book.\nWhen creating a story or picture book, create a new presentation with this connector and insert the created story and picture into the slide using other connector.\nThis creates a blank presentation file, which is basically created with the first slide with no text.",
        "tags": [
          "Google Slide"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Condition DTO for creating a presentation.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSlides.ICreatePresentationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Generated presentation information DTO.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleSlides.ISimplePresentationIdOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSlides_full.svg"
      }
    },
    "/connector/imweb/get-products": {
      "post": {
        "summary": "Get my sales product from `Imweb`",
        "description": "Look up the sales product\n\nThe `Imweb` seller uses the seller's authentication key and secret to import his or her product.\n`Imweb` is a Korean webbuilder site that offers a similar experience to the service called Wix.\nIf a commerce site is opened using `Imweb`,\nsellers can register the items they are selling,\nwhich is only available to sellers who open `Imweb` pages and is intended to bring up their products.\nSellers must provide their API keys and secrets to import `Imweb` products.",
        "tags": [
          "Imweb"
        ],
        "parameters": [],
        "requestBody": {
          "description": "key and secret",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IImweb.IGetProductInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "the seller's own goods",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IImweb.Product"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Imweb_full.svg"
      }
    },
    "/connector/imweb/auth": {
      "post": {
        "summary": "Issue Aimweb Access Token",
        "description": "Issue Aimweb Access Token.",
        "tags": [
          "Imweb"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Request DTO for access token issuance.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IImweb.Credential"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response DTO containing access token.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IImweb.IGetAccessTokenOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Imweb_full.svg"
      }
    },
    "/connector/open-data/getAddress": {
      "post": {
        "summary": "Search for the address system of the Republic of Korea",
        "description": "Search for the address system of the Republic of Korea\n\n- If you enter a postal address, you can convert it to a street address and a road name address.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMSIT.IGetAddressInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMSIT.IGetAddressOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getRTMSDataSvcSHRent": {
      "post": {
        "summary": "Retrieve multi-family lease and rental information",
        "description": "[Ministry of Land, Infrastructure and Transport] Retrieves information on single-family homes and multi-family homes for lease or rent.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\n\nYou need to look up the city, county, and district code first. (POST /connector/open-data/getStandardRegionCodeList connector)\nA connector that looks up the distirct code already exists, so call the preceding connector.\n\nSince this is Korean public data, most searches may have to be done in Korean.\nPlease be aware of this.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Query conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMOLIT.IGetRTMSDataSvcAptRentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information on leases and rents",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMOLIT.IgetRTMSDataSvcSHRentOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getRTMSDataSvcOffiRent": {
      "post": {
        "summary": "Retrieve officetel lease and rental information",
        "description": "[Ministry of Land, Infrastructure and Transport] Retrieves officetel lease and rent information.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\n\nYou need to look up the city, county, and district code first. (POST /connector/open-data/getStandardRegionCodeList connector)\nA connector that looks up the distirct code already exists, so call the preceding connector.\n\nSince this is Korean public data, most searches may have to be done in Korean.\nPlease be aware of this.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Query conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMOLIT.IGetRTMSDataSvcAptRentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information on leases and rents",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMOLIT.IGetRTMSDataSvcOffiRentOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getRTMSDataSvcAptRent": {
      "post": {
        "summary": "Retrieve apartment lease and rental information",
        "description": "[Ministry of Land, Infrastructure and Transport] Retrieves apartment lease and rent information.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\n\nYou need to look up the city, county, and district code first. (POST /connector/open-data/getStandardRegionCodeList connector)\nA connector that looks up the distirct code already exists, so call the preceding connector.\n\nSince this is Korean public data, most searches may have to be done in Korean.\nPlease be aware of this.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Query conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMOLIT.IGetRTMSDataSvcAptRentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information on leases and rents",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMOLIT.IGetRTMSDataSvcAptRentOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getLHLeaseInfo": {
      "post": {
        "summary": "Retrieve LH rental housing information",
        "description": "[Korea Land and Housing Corporation] Retrieves information on LH rental housing complexes.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\n\nSince this is Korean public data, most searches may have to be done in Korean.\nThe types of houses you can choose from here are one of the following: '국민임대','공공임대','영구임대','행복주택','장기전세','매입임대','전세임대'.\nIn addition, you can inquire by city, county, and region(=시도군)\n\nIn the Korean urban system, inquiries can only be made at the level of '특별시', '광역시', '자치시', '자치도', '도', so if you want to see it in more detail, you should ask the user for pagenation.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for querying rental housing",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ILH.IGetLHLeaseInfoInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "LH rental housing information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ILH.IGetLHLeaseInfoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getParkingLot": {
      "post": {
        "summary": "Retrieve parking lot information",
        "description": "[National Information Society Agency] Retrieves parking lot information.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\nIf you don't know the exact road name(도로명주소) or lot number address(지번주소), you can't search it.\nLook up other public data connectors first or use map connectors to look up the correct address. (ex. kakao-map connector)\n\nSince this is Korean public data, most searches may have to be done in Korean.\nPlease be aware of this.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for querying parking lots",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/IPaginationInputMyPickParkingLotrdnmadr"
                  },
                  {
                    "$ref": "#/components/schemas/IPaginationInputMyPickParkingLotlnmadr"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Parking lot information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INIA.IGetParkingLotOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getBuildingInfo": {
      "post": {
        "summary": "Retrieve building registration information",
        "description": "[Ministry of Land, Infrastructure and Transport] Retrieves building registration information.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\n\nYou need to look up the city, county, and district code first. (POST /connector/open-data/getStandardRegionCodeList connector)\nA connector that looks up the distirct code already exists, so call the preceding connector.\n\nSince this is Korean public data, most searches may have to be done in Korean.\nPlease be aware of this.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for querying building information",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMOLIT.GetBuildingInfoInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Building information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMOLIT.GetBuildingInfoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getStandardRegionCodeList": {
      "post": {
        "summary": "Retrieve administrative standard codes",
        "description": "[Ministry of the Interior and Safety] Retrieves administrative standard codes for domestic regions.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\nPublic data operating in a specific area-based class, such as building ledger information or building lease on a deposit basis information,\nmay all need to know the legal building code and the city, county, and district code (법정동 코드, 시군구 코드를 의미한다.).\nIn this case, this connector call must be preceded.\n\nSince this is Korean public data, most searches may have to be done in Korean.\nPlease be aware of this.\n\nFor the search, you should use the exact name that means the administrative district, just like the \"서울특별시\", not \"서울\".",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for querying regions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IOpenData.MinistryOfTheInteriorAndSafety.IGetStandardRegionCodeListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Region codes",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IOpenData.MinistryOfTheInteriorAndSafety.IGetStandardRegionCodeListOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getStockPriceInfo": {
      "post": {
        "summary": "Retrieve market capitalization and stock information",
        "description": "[Financial Services Commission] Retrieves market capitalization and stock information.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\n\nSince this is Korean public data, most searches may have to be done in Korean. for example \"삼성전자\".\nAlso, since this is based on the closing of the stock market, you can only look up from about two months ago (9 days ago) to yesterday from today's date.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for querying market capitalization",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/IPaginationInputlikeItmsNm(stringMaxLength120PlaceholderSamsungElectronics)undefinedbasDt(stringPlaceholder...)undefined"
                  },
                  {
                    "$ref": "#/components/schemas/IPaginationInputlikeItmsNm(stringMaxLength120PlaceholderSamsungElectronics)undefinedbeginBasDt(stringPlaceholder...)undefinedendBasDt(stringPlaceholder...)undefined"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Market capitalization and stock information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IOpenData.FinancialServicesCommission.IGetStockPriceInfoOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getShortTermForecast": {
      "post": {
        "summary": "Retrieve today's weather from the Korea Meteorological Administration",
        "description": "[Korea Meteorological Administration] Retrieves today's weather information.\n\nLatitude and longitude coordinates are required for querying.\nWhen provided, the latitude and longitude will be used to get current weather data based on the 00 minute mark of each hour for that region.\nThe output will be converted from grid coordinates to latitude and longitude, and provide weather-related information such as current weather, wind direction, and wind speed for the region.\nThe currently provided information includes:\n\n- POP: Probability of Precipitation\n- PTY: Precipitation Type\n- PCP: Precipitation Amount in the Last Hour\n- REH: Humidity\n- SNO: Snowfall in the Last Hour\n- SKY: Sky Condition\n- TMP: Temperature in the Last Hour\n- TMN: Daily Minimum Temperature\n- TMX: Daily Maximum Temperature\n- UUU: Wind Speed (East-West Component)\n- VVV: Wind Speed (North-South Component)\n- WAV: Wave Height\n- VEC: Wind Direction\n- WSD: Wind Speed\n- T1H: Temperature\n- RN1: Precipitation Amount in the Last Hour\n- VEC: Wind Direction\n- T1H: Temperature\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\n\nThere are two types in request body.\nOne is 'latitude_and_longitude' and the other is 'grid_coordinates'.\nThis function uses grid coordinate values to express Korean geographical conditions inside,\nso grid coordinates must be entered.\nHowever, grid coordinates also allow for latitude values because it is difficult for users to know their local coordinates. In this case,\nyou must deliver the values of nx and ny together with the values of 'latitude_and_longitude'.\nIf the latitude hardness value is delivered,\nit is converted to grid coordinate value from the inside and used.\n\nSince this is Korean public data, most searches may have to be done in Korean.\nPlease be aware of this.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "DTO for weather query location",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IKoreaMeteorologicalAdministration.IGetVillageForecastInformationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Weather information for the specified region",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/IKoreaMeteorologicalAdministration.IGetForecastOutput"
                      }
                    },
                    {
                      "$ref": "#/components/schemas/IOpenWeather.IResponse"
                    }
                  ]
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/open-data/getCopyRight": {
      "post": {
        "summary": "[Copyright Registration Information Service (New)]",
        "description": "[Korea Copyright Commission] Searches for copyright information.\n\nThis Connect is based on data obtained from public data portals in Korea.\nIf you talk about a specific organization here, it is an organization in Korea, and information or deducible facts that data or statistics point to can also be limited to Korea.\n\nSince this is Korean public data, most searches may have to be done in Korean.\nPlease be aware of this.\n\n- 제호(명칭) : 저작물의 명칭을 의미하는 말로, 사용자가 어려워할 수 있기 때문에 쉽게 풀어 말하는 것이 좋습니다.",
        "tags": [
          "Open Data"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for querying copyright",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KoreaCopyrightCommission.IGetCopyRightInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Copyright information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KoreaCopyrightCommission.IGetCopyRightOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/open_data.svg"
      }
    },
    "/connector/prompt/generate": {
      "post": {
        "summary": "prompt node",
        "description": "Enter the request you want to give to LLM.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "user's prompt",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IPrompt.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "response via prompt",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IPrompt.IResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Prompt_prompt_full.svg"
      }
    },
    "/connector/korea-eximbank/exchange": {
      "get": {
        "summary": "Korea Export-Import Bank Current Exchange Rate Inquiry",
        "tags": [
          "Korea Eximbank"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Exchange Rate Information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "result": {
                        "oneOf": [
                          {
                            "const": 1,
                            "title": "성공"
                          },
                          {
                            "const": 2,
                            "title": "데이터 코드 오류"
                          },
                          {
                            "const": 3,
                            "title": "인증코드 오류"
                          },
                          {
                            "const": 4,
                            "title": "일일 제한 횟수 마감"
                          }
                        ],
                        "title": "Summary of query results"
                      },
                      "cur_unit": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string",
                            "x-wrtn-placeholder": "KRW"
                          }
                        ],
                        "title": "currency code"
                      },
                      "ttb": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string"
                          }
                        ],
                        "title": "When receiving a wire transfer (remittance)"
                      },
                      "tts": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string"
                          }
                        ],
                        "title": "When sending a wire transfer (remittance)"
                      },
                      "deal_bas_r": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string"
                          }
                        ],
                        "title": "Trading standard rate"
                      },
                      "bkpr": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string"
                          }
                        ],
                        "title": "Book Price"
                      },
                      "yy_efee_r": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string"
                          }
                        ],
                        "title": "Annual Conversion Rate"
                      },
                      "ten_dd_efee_r": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string"
                          }
                        ],
                        "title": "10-day redemption rate"
                      },
                      "kftc_bkpr": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string"
                          }
                        ],
                        "title": "Seoul Foreign Exchange Brokerage Book Price"
                      },
                      "kftc_deal_bas_r": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string"
                          }
                        ],
                        "title": "Seoul Foreign Exchange Brokerage Trading Standard Rate"
                      },
                      "cur_nm": {
                        "oneOf": [
                          {
                            "type": "null"
                          },
                          {
                            "type": "string",
                            "x-wrtn-placeholder": "한국 원"
                          }
                        ],
                        "title": "Country/Currency Name"
                      }
                    },
                    "required": [
                      "result",
                      "cur_unit",
                      "ttb",
                      "tts",
                      "deal_bas_r",
                      "bkpr",
                      "yy_efee_r",
                      "ten_dd_efee_r",
                      "kftc_bkpr",
                      "kftc_deal_bas_r",
                      "cur_nm"
                    ]
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/ExchangeRate_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/story-generator": {
      "post": {
        "summary": "Create a story",
        "description": "Create a story based on user input.\n\nThis connector can be used when creating a chatbot workflow for creating picture books or stories.\n\nPlease use it in conjunction with the Story Image Generation connector.\n\nPlease create an image based on the story created using the connector/story-image-generator connector.\n\nPlease export the created story and image using Google Slides.\n\nPlease export the created story and image using the connector/google-slides/presentations connector to Google Slides.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Input for creating a story",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IStoryGeneratorRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The generated story or a request for additional information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IStoryGeneratorResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Marketing_full.svg"
      }
    },
    "/connector/story-image-generator": {
      "post": {
        "summary": "Generate story image",
        "description": "Generates an image from given input.\n\nA connector that can be used when creating a chatbot workflow for picture book or story generation.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "description": "Input for image generation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGenerateStoryImageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Generated image",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IStoryImage"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/image.svg"
      }
    },
    "/connector/stable-diffusion-beta/generate": {
      "post": {
        "summary": "Stable diffusion image generator node",
        "description": "Generate an image using the stable diffusion model.",
        "tags": [
          "Stable Diffusion"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for image generation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IStableDiffusionBeta.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "URL of the generated image",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IStableDiffusionBeta.IResponse"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/StableDifusion_full.svg"
      }
    },
    "/connector/dall-e-3/generate": {
      "post": {
        "summary": "dall-e-3 image generator node",
        "description": "Generate an image using the dall-e-3 model.",
        "tags": [
          "Dall-e-3"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for image generation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDallE3.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "URL of the generated image",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDallE3.IResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Dall-e3_full.svg"
      }
    },
    "/connector/google-search": {
      "post": {
        "summary": "Google search",
        "description": "Search Google for the search term you entered.",
        "tags": [
          "Google Search"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Google search terms",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Google search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleSearch_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-search/wanted": {
      "post": {
        "summary": "Wanted job posting search",
        "description": "Search for job postings on Wanted.",
        "tags": [
          "Wanted"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Wanted job posting search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/_wanted_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-search/incruit": {
      "post": {
        "summary": "Search Incruit job postings",
        "description": "Search for job postings on Incruit.",
        "tags": [
          "Incruit"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results for Incruit job postings",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Incruit_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-search/saramin": {
      "post": {
        "summary": "Search for Saramin job postings",
        "description": "Search for job postings in Saramin.",
        "tags": [
          "Saramin"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search for Saramin job postings results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Saramin_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-search/jumpit": {
      "post": {
        "summary": "Jumpfit job posting search",
        "description": "Search for job postings on Jumpfit.",
        "tags": [
          "Jumpit"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Jumpfit job posting search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/jumpit_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-search/careerly": {
      "post": {
        "summary": "Careerly Search",
        "description": "Search for posts in Careerly.",
        "tags": [
          "Careerly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleSearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Careerly Post Search Results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleSearch.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/careerly_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/aladine": {
      "post": {
        "summary": "Aladdin Search",
        "description": "Search for products in Aladdin.",
        "tags": [
          "Aladin"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/aladin_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/ali-express": {
      "post": {
        "summary": "Search for AliExpress",
        "description": "Search for products on AliExpress.",
        "tags": [
          "AliExpress"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/AliExpress_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/coupang": {
      "post": {
        "summary": "Coupang Search",
        "description": "Search for products on Coupang.",
        "tags": [
          "Coupang"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Coupang_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/eql": {
      "post": {
        "summary": "EQL search",
        "description": "Search for products in EQL.",
        "tags": [
          "EQL"
        ],
        "parameters": [],
        "requestBody": {
          "description": "search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/ECL_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/iherb": {
      "post": {
        "summary": "iHerb Search",
        "description": "Search for products on iHerb.",
        "tags": [
          "iHerb"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/iHerb_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/market-kurly": {
      "post": {
        "summary": "Market Kurly Search",
        "description": "Search for products on Market Kurly.",
        "tags": [
          "Market Kurly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Kurly_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/oco": {
      "post": {
        "summary": "OCO search",
        "description": "Search for products in OCO.",
        "tags": [
          "OCO"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/OCO_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/olive-young": {
      "post": {
        "summary": "Olive Young Search",
        "description": "Search for products at Olive Young.",
        "tags": [
          "Olive Young"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/oliveYoung_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/twenty-nine-centimeter": {
      "post": {
        "summary": "29cm search",
        "description": "Search for products from 29cm.",
        "tags": [
          "29CM"
        ],
        "parameters": [],
        "requestBody": {
          "description": "search condition",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "search result",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/29cm_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/uniqlo": {
      "post": {
        "summary": "Uniqlo Search",
        "description": "Search for products in Uniqlo.",
        "tags": [
          "Uniqlo"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Uniqlo_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/yes-twenty-four": {
      "post": {
        "summary": "yes24 search",
        "description": "Search for products on yes24.",
        "tags": [
          "yes24"
        ],
        "parameters": [],
        "requestBody": {
          "description": "search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/yes24_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-shopping/musinsa": {
      "post": {
        "summary": "Musinsa Search",
        "description": "Search for products in Musinsa.",
        "tags": [
          "Musinsa"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleShopping.IRequestStandAlone"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleShopping.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Musinsa_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-ads/generateKeywordIdeas/keywordsAndUrl": {
      "post": {
        "summary": "Create keywords using keywords and URL",
        "description": "Recommend keywords for Google Ads!\n\nIn order to execute ads in Google Ads, you need to register keywords.\nA keyword must be registered to target the end users of the ad, and it is one of the `adGroupCriteria` mapped to `adGroup` among the resources of Google Ads.\nThis connector is a function to recommend such keywords, and when the user enters the keywords and URL that he or she wanted to register, it recommends other keywords that can be derived from them.\n\nThe request result is a list of keywords, the competition index, unit price, and the expected index values for each keyword when registering an ad.\n\nThis connector excludes keywords for adult ads, and the language condition is set to Korean and the geographical condition is set to Korea (South Korea).\n\nBefore calling the function, you need to ask the user for `customerId`, so you need to suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Object containing URL",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGenerateKeywordIdeaByKeywordsAndUrlInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of recommended keywords, competition index and index, and unit price information for each keyword",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleAds.IGenerateKeywordIdeaOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-ads/generateKeywordIdeas/keywords": {
      "post": {
        "summary": "Create keywords using keywords",
        "description": "Get keyword recommendations for Google Ads!\n\nIn order to execute ads in Google Ads, you need to register keywords.\nA keyword must be registered to target the end users of the ad, and it is one of the `adGroupCriteria` mapped to `adGroup` among the resources of Google Ads.\nThis connector is a function to recommend such keywords, and when the user enters the keywords that he or she wanted to register, it recommends other keywords that can be derived from them.\n\nThe request result is a list of keywords, the competition index, unit price, and the expected index values when registering an ad for each keyword.\n\nThis connector excludes keywords for adult ads, and the language condition is set to Korean and the geographical condition is set to Korea (South Korea).\n\nBefore calling the function, you need to ask the user for `customerId`, so you need to suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Object containing URL",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGenerateKeywordIdeaByKeywordsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of recommended keywords, competition index and index, and unit price information for each keyword",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleAds.IGenerateKeywordIdeaOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-ads/generateKeywordIdeas/url": {
      "post": {
        "summary": "Create keywords through URL",
        "description": "Get keyword recommendations for Google Ads!\n\nIn order to execute ads in Google Ads, you need to register keywords.\nA keyword must be registered to target the end users of the ad, and it is one of the `adGroupCriteria` mapped to `adGroup` among the resources of Google Ads.\nThis connector is a function to recommend such keywords, and when the user enters the URL that he or she wanted to register, it recommends other keywords that can be derived from it.\n\nThe request result is a list of keywords, competition index, unit price, and expected index values for each keyword when registering an ad.\n\nThis connector excludes keywords for adult ads, and the language condition is set to Korean and the geographical condition is set to Korea (South Korea).\n\nBefore calling the function, you need to ask the user for `customerId`, so you need to suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Object containing the URL",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGenerateKeywordIdeaByURLInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of recommended keywords, competition index and index, and unit price information for each keyword",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleAds.IGenerateKeywordIdeaOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-ads/customerClientLink": {
      "post": {
        "summary": "Register Rutten as an administrator",
        "description": "Designate Rutten as the advertising account manager of the user\n\nTo call the Google Ads API for a specific Google account, you must own the advertising account or be registered as an administrator.\nThis connector is a connector that sends a kind of invitation to all of the user's Google advertising accounts to register the `Wrtn` advertising account as the customer's administrator.\nAfter the connector is executed, an email registered to the customer account will be sent via Gmail.\nThose who receive the email can go to the dashboard through the email and give the `Wrtn` account administrator rights.\nIf `Wrtn` is registered as an administrator, he will be able to use other APIs created in Google Ads.\n\nThis administrator designation must be done before calling all Google Ads connectors except for connectors that do not receive `customerId` as an argument, such as keyword recommendations.\nHowever, even if this connector is called, `Wrtn` will not be designated as an administrator without the user's approval, so there is no need to worry.\n\nBefore calling the function, we need to ask the user for his `customerId`, so we need to suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Customer information",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/get-customers": {
      "post": {
        "summary": "Get ad account",
        "description": "Get the customer's advertising account\n\nUsing the user's access token, search for the user's advertising account, i.e., `customer`, among the accounts where `Wrtn` is an administrator.\nEven if the user has an advertising account, if `Wrtn` is not an administrator, it will not be listed.\nTherefore, if `Wrtn` has never been registered as an administrator, you must call the `POST connector/google-ads/customerClientLink` connector.\n\nIn addition, this connector filters out advertising accounts that do not use the Korean currency unit `KRW`.\nThe reason for this is to prevent mistakes from occurring in other campaign budget modification or ad status change connectors in the future.\nWhen creating ads through the Google Ads connector, human errors may occur in budget settings depending on the currency unit of each account.\nFor example, if you register a budget for an account with a currency unit of `USD` as an account with a currency unit of `KRW`, a budget difference of the exchange rate may occur.\n\nBefore calling the function, we need to ask the user for his `customerId`, so we need to suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Customer information",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGetCustomerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of ad accounts",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleAds.CustomerClient"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-ads/get-campaigns": {
      "post": {
        "summary": "Search for a list of campaigns",
        "description": "Get a list of campaigns for a Google customer account\n\nPass `customerId` to the user and search for campaigns in the customer's advertising account.\nIf `customerId` is not passed, `Wrtn` will automatically select only one advertising account that the user can access.\nA campaign corresponds to `campaign` among Google resources and is in charge of advertising channels, budgets, and the start and end dates of advertising execution.\nA channel refers to Google advertising products such as responsive search ads (=responsive search ads) and responsive display ads (=responsive display ads).\nIf a campaign is a search ad, there are only search ads in the ad group and ads.\nA user can use this connector to search for their campaigns and the status of the campaigns, and create ad groups for the desired campaigns, etc., for subsequent actions.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Customer information",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of campaigns",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleAds.IGetCampaignsOutputResult"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/get-ad-groups": {
      "post": {
        "summary": "Search for a list of ad groups.",
        "description": "Get a list of ad groups in a Google customer account\n\nPass `customerId` to the user and search for ad groups (=adGroup) in the customer ad account.\nIf `customerId` is not passed, it will automatically select only one ad account that `Wrtn` can access from the user.\nIf `campaignId` is also passed, it will search only the child ad groups of the campaign.\nAd groups are the area in charge of targeting and are also the parents of ads (ads).\nThe result of this connector contains simple information about the campaign that is the parent of the ad group, information about the ad group,\na list of ads belonging to the ad group, their current status, and simple information.\nIt also contains information about keywords connected to the ad group.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Ad group list query condition",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGetAdGroupInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Ad group list",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleAds.IGetAdGroupsOutputResult"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/get-ads": {
      "post": {
        "summary": "Retrieves a list of campaign ads",
        "description": "Get the list of ads from the Google customer account\n\nPass the `customerId` to the user and search for the ads (=ad) in the customer's ad account.\nIf `customerId` is not passed, it will be automatically selected only if there is only one ad account accessible to `Wrtn` from the user.\nAn ad is a node at the end of a tree structure consisting of campaigns, ad groups, and ads, and is a section in charge of materials,\nand is also a unit exposed to end users.\nIf the resource name of an ad group (=adGroup) is passed as an argument, only the ads belonging to that ad group will be searched.\nThe purpose of this connector is to determine whether the user's ad is currently running or not.\nIn the case of `Wrtn` managers, campaigns and ad groups are not changed to `PAUSED` status unless the user directly changes the campaign and ad group status in the Google Ads dashboard.\nTherefore, in general, if the ad status is `ENABLED`, the ad is running, and if it is `PAUSED`, the ad is stopped. Again, the `Wrtn` connector does not change the status of a campaign or ad group.\n\nThis function can also be used to check whether an ad is being properly executed in addition to viewing the ad.\n\nEach ad has an evaluation history for ad review and policy, which exists as a property called `PolicySummary`.\n\nThis property contains whether the ad has been approved, and the `APPROVED` status means that Google has approved the review and determined it is eligible.\n\nYou can change the ad status in `PATCH connector/google-ads/campaigns/ads/status`.\n\nBefore calling the function, you should ask the user for their `customerId`, so you should suggest a connector that can check their `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Condition for retrieving the ad list",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGetAdGroupAdInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Ad list",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MyPickIGoogleAds.AdGroupAdresourceNamestatuspolicySummary"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/ad-groups/get-metrics": {
      "post": {
        "summary": "Get the performance (metrics) of the ad group",
        "description": "View metrics per Google customer account ad\n\nPass `customerId` to the user and view statistical metrics for the customer ad group.\nIf `customerId` is not passed, `Wrtn` will automatically select only one ad account that the user can access.\nUsers can view ad metrics for a specific date through this connector,\nand these metrics include impressions, clicks, video views, views based on video playback range, and average page count.\nYou can also check simple information about the searched content, such as the resource name of the ad group.\nIn addition, `costMicros` information is provided, which is the advertising expenditure in micro units and means the amount actually executed.\nIf this figure is `1,000,000`, if the currency unit is `KRW`, 1 won was used.\nThis figure is the actual amount used, unlike the campaign budget, and according to Google policy, advertising costs may be slightly more than the budget. Also, the total spend of the ad group in the campaign must be equal to the total spend of the campaign.\n\nThis connector allows the user to check whether their ads are being executed efficiently in terms of cost and performance.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Ad metrics query conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGetMetricInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of metrics",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleAds.IGetMetricOutputResult"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/campaigns/ads/get-keywords": {
      "post": {
        "summary": "Add keywords to the ad",
        "description": "Add search keywords to ads in Google customer accounts\n\nStrictly speaking, add ad keywords to ad groups (=adGroup).\n\nFor convenience, this connector receives the resource name of the ad, finds the parent ad group of the ad, and then inserts the keyword.\nThe result value of this connector helps users check whether all keywords have been added properly by re-checking them after adding the keyword.\nHowever, not all keywords added are used in ads.\nKeywords are reviewed by Google and used for targeting, and at this time, keywords may be excluded from ad keywords due to inappropriate reviews.\nHowever, since ads will work properly if there are other keywords, it is advantageous to register various keywords so that users can be attracted.\n\nThere are also recommended connectors for keywords.\n\nThis connector receives an ad account as an argument from the user as authentication for the customer account, but this is also optional.\n\nIf `customerId` is not passed, it is automatically selected only if `Wrtn` has only one ad account accessible to the user.\n\nBefore calling the function, we need to ask the user for `customerId`, so we need to suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Add keyword condition",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGetKeywordsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of keywords",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleAds.IGetKeywordsOutputResult"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/campaigns/ads/status": {
      "patch": {
        "summary": "Change the status of the ad",
        "description": "Change the ad status of a Google customer account\n\nChange the ad status by receiving the ID of the ad account and the resource name of the ad in the ad group (=`adGroupAd```ResourceName`).\n\nIf `customerId` is not passed, it is automatically selected only if there is only one ad account that `Wrtn` can access from the user.\n\nThe ad status supported by this connector is `ENABLED` and `PAUSED`, which means the execution and suspension of the ad, respectively.\nSince the `Wrtn` manager account only changes the status of the ad without changing the status of the campaign and ad group,\nunless the user changes the status of the campaign and ad group directly in the Google Ads dashboard, the ad status means whether or not spending occurs.\nIf the user wants to change the status of the ad group, instead of changing the status of the ad group, query the ad group and change the status of all ads in the ad group.\nIf the user wants to change the status of the campaign, instead of changing the status of the campaign, query the campaign and change the status of all ads in the campaign. However, if you change the status of a campaign, you must go down the campaign and ad group in the Google Ads ad structure and terminate all ads.\n\nAlso, our connector does not support deleting ads.\n\nIf there is a user who wants to delete a campaign, ad group, or ad, we recommend changing all child ads of the corresponding node to the `PAUSED` status.\n\nSince deleting an ad means losing the means to check previous performance and indicators, it is advantageous to terminate the ad instead of deleting it for future ad re-execution.\n\nBefore calling the function, you must ask the user for `customerId`, so you must suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The status of the ad to be changed",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.ISetOnOffInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/campaigns/ads/keywords": {
      "delete": {
        "summary": "Delete keywords from an ad",
        "description": "Delete keywords from specific ads in Google customer account\n\nReceive the resource name of keyword (=`AdGroupCriterion`) from the user and delete all of them.\nKeywords are `AdGroupCriterion` whose `type` is `KEYWORD`, so you should be careful because there may be other types of resources.\nIf all keywords are deleted in an ad, you should be careful because deleting keywords may affect ad execution, etc.\n\nIn addition, if you delete keywords from an ad, other ads that share the ad group that is the parent of the ad may also be affected.\n\nIf `customerId` is not passed, `Wrtn` will automatically select only one ad account that the user can access.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Keyword deletion condition",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IDeleteAdGroupCriteriaInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      },
      "post": {
        "summary": "Add keywords to ads",
        "description": "Add search keywords to ads in Google customer accounts\n\nStrictly speaking, add keywords to the ad group (=adGroup), which is the parent of the ad.\nSince keywords are added to ad groups, they are applied to all child ads.\n\nIf `customerId` is not passed, it is automatically selected only if there is only one ad account accessible to `Wrtn` from the user.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Condition for adding keywords",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.ICreateAdGroupCriteriaInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Name of the added keyword resource",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "pattern": "(customers\\/(.*)\\/adGroupCriteria\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                    "x-wrtn-placeholder": "customers/1/adGroupCriteria/1"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/campaigns/ads/get-details": {
      "post": {
        "summary": "View ad details",
        "description": "View ad details\n\nDepending on the campaign, it is either a responsive search ad or a responsive display ad.\n\nIf `customerId` is not passed, it will be automatically selected only if the user has only one ad account that `Wrtn` can access.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for viewing ad details",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IGetAdGroupAdDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Ad details",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleAds.IGetAdGroupAdDetailOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/campaigns/ads": {
      "post": {
        "summary": "Create an ad",
        "description": "Create an ad for a Google customer account\n\nThe `Wrtn` manager creates one ad per ad group for convenience.\nTherefore, this connector does not receive the resource name or ID of the ad group (=adGroup) to create the ad, and the ad group is created first when creating the ad.\nSince the types of ads that can be created depend on the campaign, you must create them after checking the campaign.\nFor example, search ads must be created in a search campaign.\n\nIf `customerId` is not passed, `Wrtn` will automatically select only one ad account that the user can access.\n\nThe ad is immediately moved to the review stage after creation, and if Google's review is passed, the ad will be executed and expenses will be incurred.\nHowever, when creating an ad with this connector, the ad status is set to `PAUSED`.\nThis is to allow users to check the campaign, ad group, ad, etc. again to check if they have been created in the desired state in case of an emergency.\nTherefore, even if the ad review is complete, the ad will not be executed, and no performance or expenses will be incurred. If the ad is checked to be correct, the user can change the ad status to `ENABLED` using the `ad edit connector`.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Ad creation conditions",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ISecretICreateAdGroupSearchAdInput"
                  },
                  {
                    "$ref": "#/components/schemas/ISecretICreateAdGroupDisplayAdInput"
                  }
                ],
                "discriminator": {
                  "propertyName": "type",
                  "mapping": {
                    "SEARCH_STANDARD": "#/components/schemas/ISecretICreateAdGroupSearchAdInput",
                    "DISPLAY_STANDARD": "#/components/schemas/ISecretICreateAdGroupDisplayAdInput"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Generated ad information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleAds.IGetAdGroupsOutputResult"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/campaigns": {
      "patch": {
        "summary": "Modify the campaign",
        "description": "Edit an ad campaign for your Google customer account\n\nEdit a campaign.\nThe only things you can edit in a campaign are the campaign name, budget, and end date.\nThe campaign name is a value for people to recognize and has no effect on the ad, so you can specify it as you like.\nFor the budget, you can enter the budget you want to advertise in Korean Won (KRW), and in this case, the daily ad spending will be formed above and below the budget.\nIn some cases, you may spend more than the budget, or if the ad optimization is not done, you may spend less than the budget.\nThe last end date can be used as a scheduled end date because the ad will not end and will continue to run if it is not specified.\nHowever, if you do not delete the end date that you have already specified, the ad may not be executed even if you turn it on later.\nIf you want to turn on the ad for a campaign that has ended, you must also change the campaign's scheduled end date.\n\nIf you do not pass `customerId`, it will be automatically selected only if there is only one ad account that `Wrtn` can access from the user.\n\nBefore calling the function, we need to ask the user for `customerId`, so we need to suggest a connector that can check `customerId`.\n\nOriginally, there is no amount limit, but in case of an emergency, we currently limit the function to 100,000 won per campaign.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Campaign modification conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.IUpdateCampaignInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      },
      "post": {
        "summary": "Create a campaign",
        "description": "Create an ad campaign for your Google customer account\n\nCreate a campaign (=campaign).\nA campaign is located under an account in Google Ads, and is located at the top of the tree structure consisting of campaigns, ad groups, and ads.\nA campaign is a parent object for grouping ad groups, and is responsible for the duration, budget, purpose, channel, etc. of the ad.\nIf you do not specify a campaign name, a random name will be assigned. In this case, it may be difficult to identify.\nTherefore, it is recommended to give different names to each campaign according to its purpose so that you can distinguish them.\nThe name of the campaign is only for the user to easily identify, and does not affect the effectiveness of the ad at all, so you can rest assured.\n\nIf you do not pass `customerId`, it will be automatically selected only if there is only one ad account accessible to `Wrtn` from the user.\n\nYou should ask the user for `customerId` before calling the function, so you should suggest a connector that can check `customerId`.\n\nOriginally, there was no limit on the amount, but in preparation for an emergency, the function is currently limited to 100,000 won per campaign.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Campaign creation conditions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.ICreateCampaignInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Created campaign information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleAds.IGetCampaignsOutputResult"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/search-ads": {
      "post": {
        "summary": "Create responsive search ads for your Google customer account all at once",
        "description": "Create search ads in Google customer accounts at once\n\nCreating Google ads at once means creating campaigns, ad groups, and ads that exist in the Google Ads tree structure at once.\n\nIn this case, you do not need to specify which campaign to create ads for.\n\nThis is because everything from the first resource, the campaign, to the ad is created at once.\n\nThe campaign tree structure of Google Ads is such that the top campaign node is in charge of the budget, and when the ad is optimized, the ad group and ad share the budget of the campaign.\nIn simple terms, this means that the ad within the campaign learns and optimizes itself to determine which ad will be exposed to the end user.\n\nTherefore, it is easy to create ads in the connector structure that creates them at once, but it may not be suitable if you want to create multiple ads.\n\nHowever, if you have multiple ad materials and do not intend to create and compare multiple ads, it will be very convenient because you can easily execute the ad.\n\nIn most cases, there is no problem creating ads in this way.\n\nIf `customerId` is not passed, it is automatically selected only if there is only one ad account accessible to `Wrtn` from the user.\n\nThe ad is immediately reviewed after being created, and if Google's review is passed, the ad will be executed and expenses will be incurred.\nHowever, if an ad is created with this connector, the ad status is set to `PAUSED`.\nThis is to prepare for an emergency so that the user can check the campaign, ad group, ad, etc. again to see if they are in the desired state.\nTherefore, even if the ad review is complete, the ad will not be executed and no performance or expenses will be incurred.\n\nIf the ad is checked to be correct, the user can change the ad status to `ENABLED` using the `Ad Edit Connector`.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.\n\nOriginally, there was no amount limit, but in preparation for an emergency, the function is currently limited to 100,000 won per campaign.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for creating ads from campaigns all at once",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.ICreateAdGroupSearchAdAtOnceInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information from created campaigns to ads",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeepStrictMergeHelperIGoogleAds.IGetCampaignsOutputResultIGoogleAds.AdWrapper"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/google-ads/display-ads": {
      "post": {
        "summary": "Create responsive display ads in Google Account Ads at once",
        "description": "Create display ads in your Google customer account at once\n\nCreating Google ads at once means creating campaigns, ad groups, and ads that exist in the Google Ads tree structure at once.\n\nIn this case, you do not need to specify which campaign to create ads for.\n\nThis is because everything from the first resource, the campaign, to the ad is created at once.\n\nThe campaign tree structure of Google Ads is such that the top campaign node is in charge of the budget, and when the ad is optimized, the ad group and ad share the budget of the campaign.\nIn simple terms, this means that the ad within the campaign learns and optimizes itself to determine which ad will be exposed to the end user.\n\nTherefore, it is easy to create ads in the connector structure that creates them at once, but it may not be suitable if you want to create multiple ads.\n\nHowever, if you have multiple ad materials and do not intend to create and compare multiple ads, it will be very convenient because you can easily execute the ad.\n\nIn most cases, there is no problem creating ads in this way.\n\nIf `customerId` is not passed, it is automatically selected only if there is only one ad account accessible to `Wrtn` from the user.\n\nThe ad is immediately reviewed after being created, and if Google's review is passed, the ad will be executed and expenses will be incurred.\nHowever, if an ad is created with this connector, the ad status is set to `PAUSED`.\nThis is to prepare for an emergency so that the user can check the campaign, ad group, ad, etc. again to see if they are in the desired state.\nTherefore, even if the ad review is complete, the ad will not be executed and no performance or expenses will be incurred.\n\nIf the ad is checked to be correct, the user can change the ad status to `ENABLED` using the `Ad Edit Connector`.\n\nBefore calling the function, you should ask the user for `customerId`, so you should suggest a connector that can check `customerId`.\n\nOriginally, there was no amount limit, but in preparation for an emergency, the function is currently limited to 100,000 won per campaign.",
        "tags": [
          "Google Ads"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for creating ads from campaigns at once",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleAds.ICreateAdGroupDisplayAdAtOnceInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information from created campaigns to ads",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeepStrictMergeHelperIGoogleAds.IGetCampaignsOutputResultIGoogleAds.AdWrapper"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/googleAD_full.svg"
      }
    },
    "/connector/arxiv-search": {
      "post": {
        "summary": "Archive Paper Search",
        "description": "Searches the archive for papers based on the search criteria you entered.",
        "tags": [
          "Arxiv"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Archive Paper Search Criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IConnector.ISearchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of papers found in the archive based on the search criteria.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IConnector.ISearchOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Arxiv_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/daum/blog": {
      "post": {
        "summary": "Search the following blog",
        "description": "Search the following blog content.",
        "tags": [
          "Daum"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching the following blog",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDaum.ISearchDaumInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDaum.IBlogDaumOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/DaumBlog_full.svg"
      }
    },
    "/connector/daum/cafe": {
      "post": {
        "summary": "Search for the following cafe",
        "description": "Search for the following cafe content.",
        "tags": [
          "Daum"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching the following cafe",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDaum.ISearchDaumInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDaum.ICafeDaumOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/DaumCafe_full.svg"
      }
    },
    "/connector/naver/cafe": {
      "post": {
        "summary": "Naver Cafe search",
        "description": "Search Naver Cafe contents.",
        "tags": [
          "Naver"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for Naver Cafe search",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INaver.INaverKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INaver.ICafeNaverOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/NaverCafe_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/naver/blog": {
      "post": {
        "summary": "Naver blog search",
        "description": "Search Naver blog content.",
        "tags": [
          "Naver"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for Naver blog search",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INaver.INaverKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INaver.IBlogNaverOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/NaverBlog_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/naver/news": {
      "post": {
        "summary": "Search Naver News",
        "description": "Search Naver News.",
        "tags": [
          "Naver"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching Naver News",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INaver.INaverKeywordInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INaver.INewsNaverOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/NaverNews_full.svg"
      }
    },
    "/connector/youtube-search": {
      "post": {
        "summary": "YouTube video search",
        "description": "Get YouTube video search results.\n\nThe search results have the video title and link.\nIf most users are going to use this feature, they probably want to watch the video, so it's better to provide a URL.",
        "tags": [
          "Youtube"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for YouTube video search",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IYoutubeSearch.ISearchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of YouTube video search results.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IConnector.ISearchOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Youtube_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-scholar": {
      "post": {
        "summary": "Search Google Scholar paper list",
        "description": "Get a list of papers in Google Scholar.",
        "tags": [
          "Google Scholar"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Google Scholar paper search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleScholar.ISearchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Google Scholar paper list",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleScholar.ISearchOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleScholar_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/csv/read": {
      "post": {
        "summary": "Read CSV file",
        "description": "Read CSV file contents",
        "tags": [
          "CSV"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information for reading CSV file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICsv.IReadInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "CSV file contents.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICsv.IReadOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/CSV_full.svg"
      }
    },
    "/connector/csv/write": {
      "post": {
        "summary": "Create a CSV file",
        "description": "Create a CSV file",
        "tags": [
          "CSV"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information to create a CSV file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICsv.IWriteInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICsv.IWriteOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/CSV_full.svg"
      }
    },
    "/connector/csv/csv-to-excel": {
      "post": {
        "summary": "Convert CSV file to Excel file",
        "description": "Convert CSV file to Excel file.",
        "tags": [
          "CSV"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information to convert CSV file to Excel file",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICsv.ICsvToExcelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "excel file url",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICsv.ICsvToExcelOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/CSV_full.svg"
      }
    },
    "/connector/notion/page/block": {
      "delete": {
        "summary": "Delete a block",
        "description": "Delete a block\n\nSets a Block object, including page blocks,\nto archived: true using the ID specified. Note: in the Notion UI application, this moves the block to the \"Trash\" where it can still be accessed and restored.",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IDeleteBlockInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/connector/notion/page/markdown": {
      "post": {
        "summary": "Append block by markdown format",
        "description": "Append block by markdown format\n\nYou can add blocks to the page immediately with only the markdown grammar.\nYou can create pages more effectively than other connectors, so you can prioritize this.\nIf there are unique blocks of the note that cannot be created with the grammar of the markdown, it must be associated with other block generation connectors.\n\nSince users may not know the markdown grammar, it is more desirable to use the markdown grammar instead of guiding them.\nMarkdown supports text and heading 1, 2, 3, and various grammar such as table or bull list, number list, image attachment, boldface, italics, etc.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IAppendPageByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/file": {
      "post": {
        "summary": "Append an file type child node",
        "description": "Append an file type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `file`.\n\nUploading a file exposes it to the Notion page as an icon in the file format, but there is no Preview.\nIf you want the internal elements to be seen as soon as you enter the page, it is better to create the image, pdf format for each format, and consider embed for other formats.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/embed": {
      "post": {
        "summary": "Append an embed type child node",
        "description": "Append an embed type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `embed`.\n\nThis is suitable when you want an internal element to be rendered immediately, such as an imprame within a page.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeEmbedInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/bookmark": {
      "post": {
        "summary": "Append an bookmark type child node",
        "description": "Append an bookmark type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `bookmark`.\n\nBookmarks are visually better and more organized because they have previews, images, and explanations than just saving url as text.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeBookmarkInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/image": {
      "post": {
        "summary": "Append an image type child node",
        "description": "Append an image type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `image`.\n\nimage file's extension is one of: 'bmp', 'gif', 'heic', 'jpg', 'jpeg', 'png', 'svg', 'tif', 'tiff'.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeImageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/video": {
      "post": {
        "summary": "Append an video type child node",
        "description": "Append an video type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `video`.\n\nvideo file must be one of: 'amv' ,'asf' ,'avi' ,'f4v' ,'flv' ,'gifv' ,'mkv' ,'mov' ,'mpg' ,'mpeg' ,'mpv' ,'mp4' ,'m4v' ,'qt' ,'wmv'\nOR\nYouTube video links that include embed or watch.\nE.g. https://www.youtube.com/watch?v=[id], https://www.youtube.com/embed/[id]\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeVideoInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/pdf": {
      "post": {
        "summary": "Append an pdf type child node",
        "description": "Append an pdf type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `pdf`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypePdfInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/code": {
      "post": {
        "summary": "Append an code type child node",
        "description": "Append an code type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `code`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "deprecated": true,
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeCodeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/equation": {
      "post": {
        "summary": "Append an equation type child node",
        "description": "Append an equation type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `equation`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeEquationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/divider": {
      "post": {
        "summary": "Append an divider type child node",
        "description": "Append an divider type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `divider`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeDividerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/breadcrumb": {
      "post": {
        "summary": "Append an breadcrumb type child node",
        "description": "Append an breadcrumb type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `breadcrumb`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeBreadcrumbInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/table_of_contents": {
      "post": {
        "summary": "Append an table_of_contents type child node",
        "description": "Append an table_of_contents type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `table_of_contents`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeTableOfContentsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/link_to_page": {
      "post": {
        "summary": "Append an link_to_page type child node",
        "description": "Append an link_to_page type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `link_to_page`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeLinkToPageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page/toggle": {
      "post": {
        "summary": "Append an toggle type child node",
        "description": "Append an toggle type child node\n\nNotion is a very complex type, so you have to create a page in a block coding manner.\nTherefore, this connector is designed to create a page by taking only the page ID and one block of the corresponding block and continuously adding it to the bottom.\nThe type of block you can put in here is `toggle`.\n\nCalling this connector requires the correct page ID, so it should only be called if you have previously created a page to obtain that ID, viewed the page, or obtained a link or page ID from the user in advance.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateChildContentTypeToggleInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/page": {
      "post": {
        "summary": "Create page",
        "description": "Create a Notion page\n\nSince a parent ID is required, when a user gives you a link to the page,\nyou should take out the ID from it and use it, or first look up the list of pages accessible to the user.\nSince Notion prioritizes accessible pages during authentication, creating pages must be sub-pages within the page, which means that there must be a parent page.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Information needed to create the page",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreatePageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Unique ID of the generated page",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.ICreatePageOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/page/contents": {
      "post": {
        "summary": "Retrieve block children",
        "description": "Retrieve block children\n\nReturns a paginated array of child block objects contained in the block using the ID specified.\nIt is used to check the contents of the page by inquiring about the children of the page or block.\nIt recursively traverses and looks for all blocks. Here, we are ready to combine online blocks and blocks containing text.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IReadPageContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IMarkdownBlock"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/page": {
      "post": {
        "summary": "Retrieve a list of pages",
        "description": "Retrieve a list of all pages in your Notion workspace.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Page information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IReadPageOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/users": {
      "post": {
        "summary": "Retrieve the list of users",
        "description": "Retrieve the list of users in the workspace.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "User information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IUserOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/database-info": {
      "post": {
        "summary": "Query the database list",
        "description": "Query the database list to create items in the database.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of database information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IDatabaseInfo"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get/database-info/{databaseId}": {
      "post": {
        "summary": "Retrieves database information",
        "description": "Retrieves database information to create items in the database.",
        "tags": [
          "Notion"
        ],
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/notion/get/database-info",
                "jmesPath": "[].{value:id, label:title || ''}"
              }
            },
            "required": true,
            "description": " Unique id of the database"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Database information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IDatabaseInfo"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/database-item/{databaseId}": {
      "post": {
        "summary": "Create a database item",
        "description": "Create an item in the Notion Table database.",
        "tags": [
          "Notion"
        ],
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/notion/get/database-info",
                "jmesPath": "[].{value:id, label:title || ''}"
              }
            },
            "required": true,
            "description": " Unique id of the database in which to create the item"
          }
        ],
        "requestBody": {
          "description": "Information needed to create a database item",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreateDatabaseItemInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information about the created database item",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IDatabaseItemOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      },
      "patch": {
        "summary": "Modify database item",
        "description": "Modify item information in the database.",
        "tags": [
          "Notion"
        ],
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/notion/get/database-info",
                "jmesPath": "[].{value:id, label:title || ''}"
              }
            },
            "required": true,
            "description": " Unique id of the database to modify"
          }
        ],
        "requestBody": {
          "description": "Database item information to modify",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IUpdateDatabaseItemInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Modified database item information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IDatabaseItemOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/get-page-by-title": {
      "post": {
        "summary": "Search for pages by title",
        "description": "Search for pages by title.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Page title",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IFindPageOrDatabaseItemInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Searched page information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IFindPageByTitleOutput"
                }
              }
            }
          }
        },
        "x-wrtn-standalone": true,
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/find-item-list/{databaseId}": {
      "post": {
        "summary": "Retrieve a list of database items",
        "description": "Retrieve a list of items that exist in a table database.",
        "tags": [
          "Notion"
        ],
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/notion/get/database-info",
                "jmesPath": "[].{value:id, label:title || ''}"
              }
            },
            "required": true,
            "description": " Unique id of the database"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of retrieved database items",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/INotion.IDatabaseItemOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/find-item/{databaseId}": {
      "post": {
        "summary": "Retrieval of database items",
        "description": "Retrieves an item that exists in a table database.",
        "tags": [
          "Notion"
        ],
        "parameters": [
          {
            "name": "databaseId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/notion/get/database-info",
                "jmesPath": "[].{value:id, label:title || ''}"
              }
            },
            "required": true,
            "description": " Unique id of the database"
          }
        ],
        "requestBody": {
          "description": "Information required to retrieve database items",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.IFindDatabaseItemInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Information on retrieved database items",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.IDatabaseItemOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/notion/markdown": {
      "post": {
        "summary": "Create page by markdown format",
        "description": "Create page by markdown format\n\nReceive the markdown text and immediately create it as a notation page.\nYou can create pages more effectively than other connectors, so you can prioritize this.\nIf there are unique blocks of the note that cannot be created with the grammar of the markdown, it must be associated with other block generation connectors.\n\nSince users may not know the markdown grammar, it is more desirable to use the markdown grammar instead of guiding them.\nMarkdown supports text and heading 1, 2, 3, and various grammar such as table or bull list, number list, image attachment, boldface, italics, etc.\n\nSince Notion prioritizes accessible pages during authentication, creating pages must be sub-pages within the page, which means that there must be a parent page.",
        "tags": [
          "Notion"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/INotion.ICreatePageByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/INotion.ICreatePageOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Notion_full.svg"
      }
    },
    "/connector/google-hotel": {
      "post": {
        "summary": "Google Hotels Search",
        "description": "Search for accommodations using Google Hotels service",
        "tags": [
          "Google Hotel"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Google Hotels search criteria",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleHotel.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Google Hotels Search Results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleHotel.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleHotel_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/airport-information/search": {
      "post": {
        "summary": "Search for airport information",
        "description": "Search for airport information using the entered search term.",
        "tags": [
          "Search Airport Information"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions for searching for airport information",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IAirportInformation.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results for airport information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IAirportInformation.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/AirportInformation_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-flight/one-way": {
      "post": {
        "summary": "Search for one-way flights",
        "description": "Search for one-way flights.",
        "tags": [
          "Google Flight"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions required to search for flights",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleFlight.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Search results for one-way flights",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleFlight.IFinalResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleFlight_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-flight/round-trip": {
      "post": {
        "summary": "Search for round-trip flights",
        "description": "Search for round-trip flights.",
        "tags": [
          "Google Flight"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The conditions required to search for flights",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleFlight.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The results of the round-trip flight search",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGoogleFlight.IFinalResponse"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleFlight_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/slack/interactivity": {
      "post": {
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.Payload"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "array of slack block types",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {}
                }
              }
            }
          }
        }
      }
    },
    "/connector/slack/vote": {
      "post": {
        "summary": "Send Slack Custom Template Messages for Voting",
        "description": "Send Slack Custom Template Messages for Voting",
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IHoldVoteInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IHoldVoteOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/slack/conversation/mark": {
      "post": {
        "summary": "Marks a specific message in a Slack channel as read",
        "description": "Marks a specific message in a Slack channel as read\n\nYou need to know both the channel ID and the ts value of the message.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IMarkInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/scheduleMessage/text": {
      "post": {
        "description": "Create a schduled message\n\nBy default,\nit is not much different from sending a message except for specifying a schduled time,\nand requires a channel ID and message content.\nIf the message you want to schedule is within a specific thread, you must pass the ts value of the parent message.\n\nMessages booked through this feature are not visible in the Slack desktop app and can only be canceled through the API.\nTherefore, be careful in writing messages.\nIf you want to cancel, please refer to the message created through another connector and call the delete connector again.\n\nUsers may be embarrassed if the message you booked is not viewed in the Slack desktop app,\nso although it cannot be viewed before and after transmission,\nit would be a good idea to let them know that it will actually be transmitted in our service.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.ISCheduleMessageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "scheduled message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPickISlack.ScheduledMessagepost_at"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/scheduleMessage": {
      "delete": {
        "summary": "Delete the scheduled message",
        "description": "Delete the scheduled message\n\nTo clear a scheduled message,\nyou must get the exact id of that message, so you must first use the scheduled message lookup connector.\nWhen using this connector,\nthe ID of the channel is also required, which can be retrieved from the message object by querying the channel or by querying the scheduled message.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IDeleteSCheduleMessageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/postMessage/text/myself": {
      "post": {
        "summary": "post text message to myself",
        "description": "send message to myself\n\nHere, you can send a message as long as you have the message.\nThis feature identifies who the token's users are inside and sends a message to themselves.\nTherefore, even if you don't specify a channel,\nyou send a message to the `im` channel that corresponds to your own user id.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IPostMessageToMyselfInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "created message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPickISlack.Messagets"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/postMessage/reply": {
      "post": {
        "summary": "post reply message to thread",
        "description": "send reply message to thread\n\nCreates a reply.\nTo reply, you must first look up the thread.\nYou can look up the thread and pass on the 'ts' value of that thread.\nYou still need the channel's ID here.\nThe channel's ID will start with a C or D and be an unknown string,\nnot a natural language name recognized by the user.\nTherefore, if you don't know the channel ID, you should also look up the channel.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IPostMessageReplyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "created message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPickISlack.Messagets"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/postMessage/text": {
      "post": {
        "summary": "post text message",
        "description": "send message to channel\n\nHere, you can send a message as long as you have the message and channel information you want to send.\nSlack is a very close service to work, so it's dangerous to send messages that haven't been confirmed.\nYou must send the contents after receiving confirmation from the user.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IPostMessageInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "created message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyPickISlack.Messagets"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-scheduled-messages": {
      "post": {
        "summary": "Get a list of scheduled messages",
        "description": "Get a list of scheduled messages\n\nLook up the messages you booked.\nYou can use `post_at` and `post_at_date` to find out when the message will be sent.\nIf you want to clear the message, use the `id` value in the scheduled message.\n\nIf a user wants to send a reservation message to himself,\nhe or she should look up both the user and the 'im' channel, then find the 'im' channel with his or her user ID and send it to that channel.\nWhat is on the 'im' channel includes not only the user's own channel, but also all the channels that can send and receive direct messages for each user.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetScheduledMessageListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetScheduledMessageListOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/slack/get-user-details": {
      "post": {
        "summary": "Inquire user details",
        "description": "Inquire user details\n\nInquire the user's detailed profile to acquire information such as phone number, email, and position.\nIt cannot be verified if the user has not filled in.\nThis function receives the user's ID in an array and inquires at once.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetUserDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ISlack.IGetUserDetailOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-users": {
      "post": {
        "summary": "Look up the list of users",
        "description": "Look up the list of users.\n\nUsers include bots and refer to all users in the team who are looking up.\nHere, you can look up the user's ID and name, the name the user wanted to display, the profile image, and whether the user has been deleted.\nIf you look up the user here, you can send a message to your colleagues on a specific direct channel, such as an `im` ( = channel type. )\n\nThis connector is essential because the `im` channel query only shows the user's ID and does not know who the direct channel is talking to.\n\nThe user has a separate display name.\nA display name is a name that the user has chosen to show.\nTherefore, it would be best to use this name as a courtesy.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetUserListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Users",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetUserListOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-replies": {
      "post": {
        "description": "Inquire the inside of the thread in History\n\nIf you have inquired the history of a channel,\nyou can use the 'ts' values of its history elements to query the internal thread for each history again.\nEach channel history has a number of replies, so if this number is more than 1, it is worth looking up.\n'Reply' is basically no different from the 'Message'(=Channel History).",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetReplyInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Replies",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetReplyOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-channel-link-histories": {
      "post": {
        "summary": "get links from channel histories",
        "description": "get channel links from channel histories\n\nLook up conversations that have been made in and out of the channel.\n\nThe 'channel' received as a factor means the channel's ID and is a character string that begins with a capital 'C', 'D' and so on.\nTherefore, if the user does not hand over the ID when looking for the conversation history of the channel,\nit is prioritized to find the channel ID.\nUsually, users don't know their channel ID.\nTherefore, most users will ask for a channel by its name or with only the keywords they remember.\nTherefore, unless it's an unknown string and begins with a 'C' or 'D' uppercase letter, look for the channel first.\n\nWhen you look up a conversation,\nyou can search only after a specific time or before a specific time in order to look up the time zone of the conversation you want to search for.\n\nMessages without links are removed, leaving only messages with links.\nThis is because it only leaves messages with links as connectors to find links in conversations.\nLinks are arranged in links properties.\n\nIf you want to filter by date, prioritize using the datetime format.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelHistoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetChannelLinkHistoryOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-channel-histories": {
      "post": {
        "summary": "get channel histories",
        "description": "get channel histories\n\nLook up conversations that have been made in and out of the channel.\n\nThe 'channel' received as a factor means the channel's ID and is a character string that begins with a capital 'C', 'D' and so on.\nTherefore, if the user does not hand over the ID when looking for the conversation history of the channel,\nit is prioritized to find the channel ID.\nUsually, users don't know their channel ID.\nTherefore, most users will ask for a channel by its name or with only the keywords they remember.\nTherefore, unless it's an unknown string and begins with a 'C' or 'D' uppercase letter, look for the channel first.\n\nWhen you look up a conversation,\nyou can search only after a specific time or before a specific time in order to look up the time zone of the conversation you want to search for.\n\nIn the conversation history, the link and code box are abbreviated to <LINK/> and <CODE/>, respectively.\nFor users, it is replaced by a user name, Like <@USERNAME>.\n<@USERNAME> is about calling someone else, and it's not the name of the person who started the conversation, so be careful.\n\nIf you want to filter by date, prioritize using the datetime format.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelHistoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "channel histories",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetChannelHistoryOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-private-channels": {
      "post": {
        "summary": "get private channels",
        "description": "get private channels\n\nView channels.\nThis connector will only look up its own `private` channel.\nThe channel ID is required to look up the conversation history within the channel later.\n`private` channel is a locked channel that can only be viewed by those invited to the channel.\n\nIf you can't find the channel ID by name, it might be because it's on the next page, not because you don't have a channel.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "private channels",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ISlack.PrivateChannel"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-public-channels": {
      "post": {
        "summary": "get public channels",
        "description": "get public channels\n\nView channels.\nThis connector will only look up its own `public` channel.\nThe channel ID is required to look up the conversation history within the channel later.\nThe `public` channel is anyone's accessible.\nThis does not require an invitation process, and users can join the channel themselves if necessary.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "public channels",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ISlack.PublicChannel"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-im-channels": {
      "post": {
        "summary": "get im channels",
        "description": "get im channels\n\nView channels.\nThis connector will only look up its own `im` channel.\nThe channel ID is required to look up the conversation history within the channel later.\n`im` channel is a conversation that takes place in one's profile and refers to a personal channel that can only be viewed by oneself.\nUsers also use chat as storage or notepad, such as storing files and images here.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetChannelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "im channels",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ISlack.ImChannel"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/slack/get-files": {
      "post": {
        "summary": "get files in workspace",
        "description": "get files in workspace\n\nYou can look up Slack workspace and channels, or all files sent from users.\nIt is pagenation and can filter by file type, and also provides thumbnail links, download links, and original message links.",
        "tags": [
          "Slack"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ISlack.IGetFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ISlack.IGetFileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/Slack_full.svg"
      }
    },
    "/connector/jira/issues/comments": {
      "delete": {
        "summary": "delete comment",
        "description": "Delete the comment\n\nDelete the comments on the issue.\nIn order to delete the comments on the issue, you need the issue ID or key and the ID of the comment to be deleted.\nPlease be careful because deleted comments will not be able to be viewed again.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIDeleteCommentInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/comments/markdown": {
      "put": {
        "summary": "modify comment body",
        "description": "modify comment\n\nModify the comment. You can only modify the body of the comment here.\nTo create comment in issue, Just write markdown string format contents.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.IUpdateCommentByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      },
      "post": {
        "summary": "creates a comment on an issue",
        "description": "Creates a comment on an issue\nHere, user can write the body of the comment you want to write with the ID or key of the issue.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "condition of creation",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.ICreateCommentByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.ICreateCommentOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/get-comments": {
      "post": {
        "summary": "get comments by issue id or key",
        "description": "Get comments by issue id or key\n\nThis connector uses the issue's key or ID value to query the comments written on the issue.\nComments are also visible when looking up issues,\nbut not all comments inside are visible,\nso user have to use this connector to look up them in pagination.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "issue id or key",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetCommentInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "comments of this issue",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetCommentOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/get-transitions": {
      "post": {
        "summary": "Inquire the transition of an issue",
        "description": "Inquire the transition of an issue, which is an edge on a workflow that allows you to change the status of an issue\nIf the person who designed the workflow for the project defined three states that could be moved from the current state, there would be three edges.\nIn Jira, just because there is a status that can be viewed in a project or issue does not mean that you can change the status unconditionally.\nWhen designing an edge, for example, you can also design an issue in the 'backoff' state to go through the 'in progress' state once.\nIn this case, you need to move two edges to turn the backoff issue into 'done'.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetTransitionInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetTransitionOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/asignee": {
      "delete": {
        "description": "Unassign the assignee from the Jira issue",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIUnAssignInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      },
      "put": {
        "summary": "assign the assignee",
        "description": "Assign the assignee from the Jira issue",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIAssignInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/status": {
      "put": {
        "summary": "change issue status",
        "description": "Change issue status\n\nChanging the status of an issue must be done after inquiring about changeable Transitions from the current issue.\nThis is forced by the person who designed the workflow in the project, so you must change the status in the order set.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIUpdateStatusInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/{id}": {
      "put": {
        "summary": "update issue in jira",
        "description": "Update an issue\n\nYou can modify any element in the field.\nIt can be used to modify the issue type, person in charge, summary, and description.\n\nIn order to write the body of an issue, you must create the body as if you were assembling several blocks.\nThere are pre-designated content types, so please check this type information carefully.",
        "tags": [
          "Jira"
        ],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "description": " issue id to update"
          }
        ],
        "requestBody": {
          "description": "fields to update",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIUpdateIssueInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/markdown": {
      "post": {
        "summary": "create issue by markdown in jira",
        "description": "Create an issue by markdown\n\nIssue type, project, and summary are essential properties.\nIf you don't know the issue type or priority type's id for generating the issue, you can look it up through other connectors.\n\nIn order to write the body of an issue, you must create the body as if you were assembling several blocks.\nThere are pre-designated content types, so please check this type information carefully.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "issue information to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IJira.ICreateIssueByMarkdownInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "id and key of created issue",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.ICreateIssueOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-detail": {
      "post": {
        "summary": "get detailed Issue Information",
        "description": "Get detailed issue information\n\nProvides more accurate and detailed information, including the title and body of the issue\n\nIt can be used to look up the issue list first, or if you already know the key or ID of the issue.\nIf you do not know the key or ID, it is recommended to use the issue inquiry connector first.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetIssueDetailInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Detailed Issue Information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueDetailOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issues": {
      "post": {
        "summary": "Find The Jira issues.",
        "description": "Find Jira issues\n\nIn order to inquire about any issues within the project, you must first inquire about the project and find out the key of the project.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "condition of request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetIssueInputByBasicAuthemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "paginated list of issues visible to the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-projects": {
      "post": {
        "summary": "Find the Jira projects.",
        "description": "Find the Jira projects\n\nThe Jira project has a unique key and can then be used to query issues with the key.\nReturns a paginated list of projects visible to the user.\n\nIn order to inquire about any issues within the project, you must first inquire about the project and find out the key of the project.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "description": "condition of request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetProjectInputByBasicAuthemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "paginated list of projects visible to the user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetProjectOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-labels": {
      "post": {
        "summary": "Find issue labels",
        "description": "Find issue labels",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetIssueLabelInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "paginated list of labels",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueLabelOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-types": {
      "post": {
        "summary": "Find issue types",
        "description": "Find issue types\n\nIn order for the user to inquire about the issue type, the ID of the project is required.\nIf the user mentioned the key or name of the project,\nit is necessary to first inquire the project and get the correct project ID.\nThe ID of the project is a numeric character type.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetIssueTypeInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "issue types",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueTypeOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-statuses": {
      "post": {
        "summary": "Find issue statuses",
        "description": "Find issue statuses for searching issue",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetIssueStatusInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "issue statuses",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IJira.IGetIssueStatusOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-issue-priorities": {
      "post": {
        "summary": "Inquire the priority levels that can be assigned to the issue.",
        "description": "There are five priorities: 'Highest', 'High', 'Medium', 'Low', and 'Lowest'.\nTherefore, it can be used as an enum value without requesting this API,\nand this API is already deprecated on the Jira REST API document.\nHowever, for projects that can already be specified by creating a priority level, this connector is added just in case.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitBasicAuthorizationemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "issue priorities",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MyPickIJira.Prioritynameid"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/issues/get-users-assignable": {
      "post": {
        "summary": "Find assignable users in issue",
        "description": "Find a person within the issue who can be assigned as assignee.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetIssueAssignableInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "assignable users",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/projects/get-users-assignable": {
      "post": {
        "summary": "Find assignable users in project",
        "description": "Find a person within the project who can be assigned as assignee.",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitIGetProjectAssignableInputemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "assignable users",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/jira/get-status-categories": {
      "post": {
        "summary": "get status categories",
        "description": "Get status categories",
        "tags": [
          "Jira"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StrictOmitBasicAuthorizationemaildomaintokenIBasicSecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IJira.StatusCategory"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/JIraCloud_full.svg"
      }
    },
    "/connector/google-trend/daily": {
      "post": {
        "summary": "Google Trends Daily Search",
        "description": "Get daily search results from Google Trends.",
        "tags": [
          "Google Trends"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search date",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleTrend.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Daily Trends Search Results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleTrend.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleTrend_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-map": {
      "post": {
        "summary": "Google Map restaurant search",
        "description": "Search for restaurants using Google Maps.",
        "tags": [
          "Google Map"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Search term to search for restaurants",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleMap.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Restaurant search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleMap.IResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMap_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/google-map/review": {
      "post": {
        "summary": "Search Google Map restaurant reviews",
        "description": "Search for restaurant reviews selected from Google Maps.",
        "tags": [
          "Google Map"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Unique id of the restaurant",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGoogleMap.IReviewRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Restaurant review search results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IGoogleMap.IReviewResponse"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/fulls/GoogleMap_full.svg",
        "x-wrtn-standalone": true
      }
    },
    "/connector/github/users/get-received-events": {
      "post": {
        "summary": "List events received by the authenticated user",
        "description": "List events received by the authenticated user\n\nThese are events that you've received by watching repositories and following users.\nIf you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events.\nIn this case, the \"received\" event includes the repository that the user is interested in or the activity of the user who is following,\nfor example, if the user has pushed to the repository, or if an issue has been created from the repository that the user is interested in.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetReceivedEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/users/get-pinned-repositories": {
      "post": {
        "summary": "Inquire the user's pinned repository names",
        "description": "Inquire the user's pinned repositories\n\nInquire up to 6 repositories where the user has pinned.\nHere, only the name of the repository is searched, so if necessary, find detailed information about the repository by pageing the user's repository list.\nPlacing a pin in a repository is most likely a repository that users are most confident in.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserPinnedRepositoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "repositories",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/users/get-repositories": {
      "post": {
        "summary": "Inquire the user's repositories",
        "description": "Inquire the user's repositories\n\nSince it contains only the simplest information of the repository here, there is no way to know the lead me of the repository or detailed information.\nIt is recommended to use additional connectors to explore because other connectors have the ability to read leads or internal files in the repository.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserRepositoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "repositories",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetUserRepositoryOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/organizations/users/get-events": {
      "post": {
        "summary": "Lists organization events for the authenticated user",
        "description": "Lists organization events for the authenticated user\n\nThis API endpoint retrieves events that have occurred within the organizations\nthe authenticated user is a member of. It includes activities such as issues,\npull requests, commits, and other actions taken within the organization's repositories.\n\nThe events cover all repositories within the organization that the user has access to,\nmaking it useful for tracking the organization's activity or monitoring the progress\nof projects that the user is involved in within the team.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetOrganizationEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of events from the organizations the authenticated user is a member of.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/organizations/get-issues": {
      "post": {
        "summary": "List organization issues assigned to the authenticated user",
        "description": "List organization issues assigned to the authenticated user\n\nSimilar to the 'get-issues' connector, it is suitable for inquiring only about issues assigned within a specific organization.\nNaturally, the user will have to be a member of that organization.\n\nHere, the result value can be inquired together with PR because PR on GitHub is essentially an issue-like object.\nIf you want to see the issue separately, you should use a connector that looks up the issue in the repo, not the organization.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetOrganizationAuthenticationUserIssueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetOrganizationAuthenticationUserIssueOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/organizations/get-repositories": {
      "post": {
        "summary": "List organization repositories",
        "description": "List organization repositories\n\nThis endpoint allows you to list all repositories that belong to a specified organization on GitHub.\nIt's useful for viewing all the repositories under an organization’s account, including both public and private repositories, depending on your access level.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetOrganizationEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetOrganizationRepositoryOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/organizations/get-events": {
      "post": {
        "summary": "List public organization events.",
        "description": "List public organization events\n\nIf you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.\n\nThis API endpoint retrieves a stream of public events that have occurred\nwithin a specified organization. These events include activities such as\nrepository creation, issues, pull requests, and other actions taken by members\nof the organization across all its public repositories.\n\nThis is useful for monitoring the public activity within an organization,\nproviding insights into how the organization is managing its projects,\nthe work being done by its members, and the overall public engagement with\nits repositories.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetOrganizationEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repos/get-collaborators": {
      "post": {
        "summary": "List repository collaborators",
        "description": "List repository collaborators\n\nFor organization-owned repositories, the list of collaborators includes outside collaborators,\norganization members that are direct collaborators, organization members with access through team memberships,\norganization members with access through default organization permissions, and organization owners.\nOrganization members with write, maintain, or admin privileges on the organization-owned repository can use this endpoint.\nTeam members will include the members of child teams.\n\nYou can refer to it before specifying a person in charge of the issue or a reviewer for PR.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCollaboratorInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetCollaboratorOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repos/commits/contents": {
      "delete": {
        "summary": "Delete file content and commit",
        "description": "Delete file content in github repository\n\nTo delete file content is the same as creating a single commit.\nCommit is a hash that must be created in github to save changes, such as uploading, modifying, deleting, and so on.\n\nAs the sha value of the file to be modified, a conflict may occur if it is not the latest sha value among the sha values of the file.\nIt's safe when you look up a list of files through API to check sha and put in a value, or want to re-modify the sha value of a file you just created.\n\nIf the user directly asks you to add, modify, or delete a file for a specific PR or specific branch, this connector should be considered.\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IDeleteFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      },
      "put": {
        "summary": "Update File content and commit",
        "description": "Update file content in github repository\n\nUpdating file content is the same as creating a single commit.\nCommit is a hash that must be created in github to save changes, such as uploading, modifying, deleting, and so on.\n\nAs the sha value of the file to be modified, a conflict may occur if it is not the latest sha value among the sha values of the file.\nIt's safe when you look up a list of files through API to check sha and put in a value, or want to re-modify the sha value of a file you just created.\n\nIf you modify a file, it's not like appending the code to the file, it's like overwriting the file.\nGenerally, if a user says he wants to modify it, it means that he wants to add the code to a specific file or refact it,\nso it's right to check the existing code and then change some of the contents to the original to reflect it.\nIn addition, it is recommended to receive confirmation from the user every time about the content and then modify or add it.\n\nIf the user directly asks you to add, modify, or delete a file for a specific PR or specific branch, this connector should be considered.\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IUpdateFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IUpsertFileContentOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      },
      "post": {
        "summary": "Create File content and commit",
        "description": "Create file content in github repository\n\nIf the file already exists in the same path, you should use the modification API and this connector is only responsible for generation.\nCreating file content is the same as creating a single commit.\nCommit is a hash that must be created in github to save changes, such as uploading, modifying, deleting, and so on.\n\nIf someone says they want to add a file to the repo it's like they want to commit.\nHowever, in this case, you should check which branch you want to add the file to, and you should not create it in the default branch if you do not specify the branch.\nUsers value branches that reflect their commitments.\nIn addition, it is recommended to receive confirmation from the user every time about the content and then modify or add it.\n\nIf the user directly asks you to add, modify, or delete a file for a specific PR or specific branch, this connector should be considered.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IUpsertFileContentOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repos/get-folder-structures": {
      "post": {
        "summary": "Review Repository Folder Structure",
        "description": "Review Repository Folder Structure\n\nIt allows you to know the overall folder structure by traversing files in the repository.\nThis feature is intended to navigate like a DFS based on folders.\nIf this function is so vast that you cannot see the entire folder, you can pass the `path` again to inquire.\nThe `path` delivered is treated like a Root folder and continues the navigation from this folder.\nThis feature is designed to navigate to the inside two more times, up to steps 0, 1 at a time, based on the root folder.\n\nIf you want to know the details of the file, it is recommended to use the get-contents connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetRepositoryFolderStructureInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/RepositoryFolderchildrenany"
                      },
                      {
                        "$ref": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                      }
                    ],
                    "discriminator": {
                      "propertyName": "type",
                      "mapping": {
                        "dir": "#/components/schemas/RepositoryFolderchildrenany",
                        "file": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repos/get-contents/bulk": {
      "post": {
        "summary": "Look up repository files(bulk)",
        "description": "Look up repository files(bulk)\n\nIf the file you want to inquire is a folder, internal files are provided in an array,\nand if it is a file, it inquires about the encoding method of the file and the body content of the file.\nSince there may be countless files and folders in the github repository, there may be many files that exceed the rate limit.\nIn this case, you can try to solve this problem by sequentially finding the folders one by one using the corresponding connector.\nYou can pass multiple file paths to view multiple files at the same time.\nThere is no limit to the number of files.\n\nThis is suitable for viewing files on specific branches, but if the user is for the purpose of viewing details of code reviews or PR, it is recommended to use a different connector.\nThere are connectors that view the list of files changed in PR, or see the changes.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetBulkFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "array",
                        "items": {
                          "oneOf": [
                            {
                              "$ref": "#/components/schemas/IGithub.RepositoryFolder"
                            },
                            {
                              "$ref": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                            }
                          ],
                          "discriminator": {
                            "propertyName": "type",
                            "mapping": {
                              "dir": "#/components/schemas/IGithub.RepositoryFolder",
                              "file": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                            }
                          }
                        }
                      },
                      {
                        "$ref": "#/components/schemas/IGithub.RepositoryFile"
                      },
                      {
                        "type": "object",
                        "properties": {
                          "type": {
                            "const": "null"
                          },
                          "size": {
                            "const": 0
                          },
                          "message": {
                            "const": "No files exist corresponding to the path."
                          }
                        },
                        "required": [
                          "type",
                          "size",
                          "message"
                        ]
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repos/get-contents": {
      "post": {
        "summary": "Look up repository files",
        "description": "Look up repository files\n\nIf the file you want to inquire is a folder, internal files are provided in an array,\nand if it is a file, it inquires about the encoding method of the file and the body content of the file.\nSince there may be countless files and folders in the github repository, there may be many files that exceed the rate limit.\nIn this case, you can try to solve this problem by sequentially finding the folders one by one using the corresponding connector.\n\nThis is suitable for viewing files on specific branches, but if the user is for the purpose of viewing details of code reviews or PR, it is recommended to use a different connector.\nThere are connectors that view the list of files changed in PR, or see the changes.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "array",
                      "items": {
                        "oneOf": [
                          {
                            "$ref": "#/components/schemas/IGithub.RepositoryFolder"
                          },
                          {
                            "$ref": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                          }
                        ],
                        "discriminator": {
                          "propertyName": "type",
                          "mapping": {
                            "dir": "#/components/schemas/IGithub.RepositoryFolder",
                            "file": "#/components/schemas/StrictOmitIGithub.RepositoryFilecontentencoding"
                          }
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/IGithub.RepositoryFile"
                    },
                    {
                      "type": "object",
                      "properties": {
                        "type": {
                          "const": "null"
                        },
                        "size": {
                          "const": 0
                        },
                        "message": {
                          "const": "No files exist corresponding to the path."
                        }
                      },
                      "required": [
                        "type",
                        "size",
                        "message"
                      ]
                    }
                  ]
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repos/get-readme": {
      "post": {
        "summary": "Read the README file",
        "description": "Read the README file in the repository\n\nREADME is one of the initial settings of the project and usually records a description of this repository,\nso it's useful if you want to see a rough description of the repository.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetReadmeFileContentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "$ref": "#/components/schemas/IGithub.RepositoryFile"
                    }
                  ],
                  "discriminator": {
                    "propertyName": "type",
                    "mapping": {
                      "file": "#/components/schemas/IGithub.RepositoryFile"
                    }
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repos/get-events": {
      "post": {
        "summary": "List events for the authenticated user",
        "description": "List events for the authenticated user\n\nIf you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.\nYou can check all events surrounding the repository, such as who inquired and who forked.\nIt is used in conjunction with a connector that inquires the activity details and is suitable for checking how active the repository is.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetRepoEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/networks/get-events": {
      "post": {
        "summary": "List public events for a network of repositories",
        "description": "Fetches events across all forks of a specified repository.\n\nThis API endpoint provides a stream of events that occur in any fork\nof the specified repository. It includes actions such as commits,\npull requests, issues, and other activity happening in the forked\nrepositories.\n\nUse this endpoint when you need to monitor the activity not just\nin the original repository, but also in all of its forks. This can\nbe particularly useful for understanding the broader impact or\nactivity surrounding a popular project that has been forked multiple\ntimes.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetRepoEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/users/get-events": {
      "post": {
        "summary": "List events for the authenticated user.",
        "description": "List events for the authenticated user\n\nThis API endpoint retrieves a stream of events related to the authenticated user,\nincluding activities such as issues, pull requests, commits, and repository actions\nthat the user has participated in or been mentioned in. The events reflect the user's\ninteractions across all repositories they have access to, both public and private (if\nthe user has appropriate permissions).\n\nThis is useful for tracking a user's activity on GitHub, allowing you to see a\npersonalized feed of their involvement in various projects and interactions with\nother users.\n\nIf you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.\nIt looks up users' public events. Username should be your own nickname because you can usually only see your own events.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/users/get-organizations": {
      "post": {
        "summary": "List organizations for a user",
        "description": "List organizations for a user\n\nLook up the user's organization list, but since you can't look up the user's private organization here,\nyou can't really conclude that there isn't an empty array.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserOrganizationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetUserOrganizationOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-events": {
      "post": {
        "summary": "List public events.",
        "description": "List public events\n\nThis API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.\nWhen I look up the events, they may not be of much value to the user because they are events that occurred on github.\n\nIt's looking up public events, and it's looking at events that occur on github regardless of the specific user.\nTherefore, it may not be of much use unless it is a special case.\nIf you want to get your information, it would be more advantageous to use the 'user/get-events' connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetEventOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/get-activities": {
      "post": {
        "summary": "Get Repository' activities",
        "description": "Get repository activities\n\nYou can use it to see how active your contribution is to the repository\nbecause it looks up all the activities that have occurred in the repository.\n\nThe types of activities that can be viewed here are as follows, and you can also find out by which user it was operated.\npush, force_push, branch_creation, branch_deletion, pr_merge, merge_queue_merge",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetRepositoryActivityInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetRepositoryActivityOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests": {
      "put": {
        "description": "Update pull request\n\nUse to change the title or body of a PR, or draft status or open-close status.\nIt can also be used for overwriting labels or modifying them.\nIt can also be used to close or reopen pull request.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Update pull request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IUpdatePullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IUpdatePullRequestOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      },
      "post": {
        "description": "Create pull request\n\nCreates a pull request from a branch to a particular branch.\nIf the branch has already generated a pull request to the base branch, an error of 422 may occur.\nThis error indicates a collision because only one pull request from branch to another branch can exist open at the same time.\n\nIf the user wants to see each PR unit, this connector will be suitable.\n\nWhen creating a PR, be sure to specify the base branch and the head branch, and even if it can be omitted, be sure to include Titles and bodies as much as possible.\nYou can also create a pull request in draft state if necessary.\n\nIn order to create PR, you may need to refer to the PULL_REQUEST_TEMPLATE.md file that you specified in the .github folder in advance, in which case refer to the connector 'POST /connector/github/repos/get-contents'.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Create pull request",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreatePullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.ICreatePullRequestOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/get-comments": {
      "post": {
        "summary": "List pull request comments",
        "description": "List pull request comments\n\nYou can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.\nIn any case, you can also view comments with the number on pull request.\nIssue comments are ordered by ascending ID.\n\nThis is actually the same as connector POST '/connector/github/repositories/issues/get-comments'.\nComments and reviews on PR are separate, you can only see comments on this connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetPullRequestCommentsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetIssueCommentsOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/comments": {
      "post": {
        "summary": "Create an pull request comment",
        "description": "Create an pull request comment",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateIssueCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IssueComment"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/get-requested-reviewers": {
      "post": {
        "summary": "Get all requested reviewers for a pull request",
        "description": "Get all requested reviewers\n\nGets the users or teams whose review is requested for a pull request.\nOnce a requested reviewer submits a review, they are no longer considered a requested reviewer.\nTheir review will instead be returned by the List reviews for a pull request operation.\n\nThe requested_reviewers are the ones who have been asked to review, but not yet.\nSo when you see someone who has reviewed a PR, if that person is someone who has already finished a review, he/she will be part of the reviewers, not the requested_reviewers.\nTherefore, when you look at a reviewer, you should look at it separately between someone who has not yet reviewed it and one person who has reviewed it, which you should also call other features to see together.\nRefer to connector `:post /connector/github/repositories/pull-requests/get-reviews`.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReadPullRequestRequestedReviewerOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/requested-reviewers": {
      "delete": {
        "summary": "Remove requested reviewers from a pull request",
        "description": "Removes review requests from a pull request for a given set of users and/or teams\n\nYou should check the person who has already been requested as a reviewer, i.e., requested_reviewers, and then send out the delete request.\nEven if you don't do that, there will be no error, but it doesn't mean anything if you delete the person who hasn't been requested as a reviewer.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IRequestReviewerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      },
      "post": {
        "summary": "Request reviewers for a pull request",
        "description": "Request reviewers for a pull request\n\nRequests reviews for a pull request from a given set of users and/or teams. This endpoint triggers notifications.\nYou can specify a reviewer by the user's name alone, but not by anyone, so use a connector that looks up collaborators first.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IRequestReviewerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/reviews/get-comments": {
      "post": {
        "summary": "List comments for a pull request review",
        "description": "List comments for a pull request review\n\nLists comments for a specific pull request review.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetReviewCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetReviewCommentOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/get-reviews": {
      "post": {
        "summary": "List reviews for a pull request",
        "description": "List reviews for a pull request\n\nPull Request Reviews are groups of pull request review comments on a pull request, grouped together with a state and optional body comment.\nLists all reviews for a specified pull request. The list of reviews returns in chronological order.\nSince github distinguishes requested_reviewers from those who have already completed the review,\nif you want to see a review for any PR, you should look up both of these connectors.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestReviewInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReadPullRequestReviewOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/reviews": {
      "post": {
        "summary": "Create a review for a pull request",
        "description": "Create a review for a pull request\n\nPull request reviews created in the PENDING state are not submitted and therefore do not include the submitted_at property in the response. To create a pending review for a pull request, leave the event parameter blank.\nThe position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReviewPullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReviewPullRequestOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/get-files": {
      "post": {
        "summary": "List pull requests files",
        "description": "List pull requests files\n\nThis is useful to see what files are contained in that PR.\nEach file's patch contains the entire format of the file.\nHowever, if you want to know the changes, you should look up diff, which is implemented with a different connector, so you'd better refer to it.\n\nIf the user wants to see each PR unit, this connector will be suitable.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReadPullRequestFileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/get-commits": {
      "post": {
        "description": "List commits on a pull request\n\nLists a maximum of 250 commits for a pull request.\nTo receive a complete commit list for pull requests with more than 250 commits, use the List commits endpoint.\n\nIf the user wants to see each PR unit, this connector will be suitable.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestCommitInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IReadPullRequestCommitOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/get-diff": {
      "post": {
        "summary": "Get a diff of pull request",
        "description": "Get a diff of pull-request info\n\nThis is the same as PR's ability to query files,\nbut the format that this function returns is a string, which is more suitable for identifying changes to each file than viewing each file object,\nand in github, this is called the application/vnd.github.diff format.\nThis helps you see at a glance what codes have disappeared and been added in a form suitable for code review.\n\nIf the user wants to see each PR unit, this connector will be suitable.\n\nIf there are too many changes, the connector can export a 406 error.\nIn this case, it may be difficult to determine each change, but it is recommended to use the List pull requests connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/pull-requests/get-detail": {
      "post": {
        "summary": "Get a pull request",
        "description": "Get a deatiled pull-request info\n\nYou can view detailed PR information using the PR number.\nHere, you can see the branch to be merged and the information on the branch it points to, and you can see information such as the status of the PR, the time of each state, and the person who created the PR.\nHowever, it should be used with other connectors because it provides information close to the header of PR and does not provide information about each file or commit of PR.\n\nIf the user wants to see each PR unit, this connector will be suitable.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IReadPullRequestDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.PullRequest"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/get-pull-requests": {
      "post": {
        "summary": "Get Repository' pull request",
        "description": "List repository pull requests\n\nQuery pool requests to specific repositories.\nHere, you can filter issues and see only pool requests, and you can sort them by creation and inquiry dates, or filter by open or closed status.\nThe content of the body is omitted, so if you want to see it, you should use the detailed lookup connector.\nIf the user wants to see the body property, '/connector/github/repositories/pull-requests/get-detail' connector must be called.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IFetchRepositoryPullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IFetchRepositoryPullRequestOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/issues/get-detail": {
      "post": {
        "summary": "Get a issue",
        "description": "Get a deatiled issue info\n\nUnlike the body omitted from the issue list inquiry, it is suitable for viewing details as it can inquire all the contents.\nHowever, this connector alone cannot see all the comments or timelines inside, and other connectors must be used.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetIssueDetailInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.DetailedIssue"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/issues/get-comments": {
      "post": {
        "summary": "List issue comments",
        "description": "List issue comments\n\nYou can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.\nIn any case, you can also view comments with the number on pull request.\nIssue comments are ordered by ascending ID.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetIssueCommentsInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetIssueCommentsOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/issues/comments": {
      "post": {
        "summary": "Create an issue comment",
        "description": "Create an issue comment\n\nAdd a comment. If you put an issue number, you can add a comment to the issue, where the issue number is also the number of PR.\nIn other words, both issue and PR can add a comment through this connector.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateIssueCommentInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IssueComment"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/repositories/get-issues": {
      "post": {
        "summary": "List repository issues",
        "description": "List repository issues\n\nList issues in a repository.\nThis connector is perfect if you want to see the issue of the repository because it can be viewed without being authenticated.\nInformation on the issue comes out, but only 10 people and labels attached to the issue are provided.\nTherefore, if you want more detailed information, it's a good idea to look at it with a connector that looks at the details of the issue.\nWhen looking up an issue, you can view open and closed issues and sort them by creation time, correction time, comment count, and reaction count.\nFor more information, you should check the properties part of the request type.\n\nThe content of the body is omitted, so if you want to see it, you should use the detailed lookup connector.\nIf the user wants to see the body property, '/connector/github/repositories/issues/get-detail' connector must be called.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IFetchRepositoryInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IFetchRepositoryOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-users": {
      "post": {
        "summary": "Search for users by keyword in github",
        "description": "Search for users by keyword in github",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ISearchUserInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "list of user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.ISearchUserOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-user-profile": {
      "post": {
        "summary": "Look up the user's detailed profile",
        "description": "Look up the user's detailed profile",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetUserProfileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "detailed profile",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetUserProfileOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-organizations": {
      "post": {
        "summary": "List organizations for the authenticated user",
        "description": "List organizations for the authenticated user\n\nInquire the user's repository.\nHere, the user is an authenticated user, which means a user of that token.\nIf a user does not select an organization at login or ask the organization's admin to link it,\nthe resource might not be viewed even if the token scope has permissions.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetAuthenticatedUserOrganizationInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetAuthenticatedUserOrganizationOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-branches": {
      "post": {
        "summary": "Inquire the user's branch",
        "description": "Inquire the user's branch\nYou can look up a list of branches in a specific repository.\nBecause it says what the last commit is, and when and to whom it was made,\nyou can see which of the branches is the latest and managed.\n\nYou shouldn't call the main branch arbitrarily because there may be people who use the master branch.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetBranchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetBranchOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/branches": {
      "post": {
        "summary": "Create branch",
        "description": "Create branch\n\nCreates a reference for your repository. You are unable to create new references for empty repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories without branches.\nYou need to know the sha of the commit, so if you want to create a branch, you should first call another connector that looks up the commit list or header commitments to find out the sha value.\nIf you want to copy the branch, you should also look up the commit history of the branch and then retrieve the sha value from the branch's HEAD commit.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateBranchInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.ICreateBranchOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/github/get-pull-requests-associated-with-a-commit": {
      "post": {
        "summary": "get pull requests associated with a commit",
        "description": "List pull requests associated with a commit\n\nFetches the pull requests (PRs) associated with a specific commit in a GitHub repository.\nThis API endpoint retrieves a list of pull requests that include the specified commit.\nThis can be useful for tracking where and how a particular change was merged into a branch.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetPullRequestInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "pull requests associated with a commit",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/StrictOmitIGithub.PullRequestcommentsmaintainer_can_modifymergeablerebaseablemergeable_statemerged_byreview_commentscommitsadditionsdeletionschanged_files"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-commit-heads": {
      "post": {
        "summary": "Lists all branches that contain the HEAD commit",
        "description": "Lists all branches that contain the HEAD commit of a GitHub repository.\n\nThis function utilizes the GitHub API to retrieve a list of branches where the current\nHEAD commit (the latest commit on the checked-out branch) is included. This is useful for\ndetermining which branches contain the most recent changes.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCommitHeadInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A promise that resolves to an array of branch names that include the specified commit.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetCommitHeadOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-commit": {
      "post": {
        "summary": "Inquire the commit details of the user",
        "description": "Inquire the commit details of the user\nIt contains all the history of how the file changed, so you can see the details of a single commit node.\nIf you do not deliver ref, look up based on default_branch.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCommitInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "detailed commit history",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetCommitOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-commit-diff": {
      "post": {
        "summary": "Inquire the commit diff of the user",
        "description": "Inquire the commit diff of the user\ndiff is Github's own content type specification that allows you to identify changes per commit on the Github homepage.\nIf you do not deliver ref, look up based on default_branch.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCommitInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "commit diff",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-commit-list": {
      "post": {
        "summary": "Look up the list of commitments for a specific repo, a specific branch",
        "description": "Look up the list of commitments for a specific repo, a specific branch\n\nThis function can be used in general because it sees the commit list in units of branches, but if the user wants to see it in units of PR, it is better to use another connector.\nIf the user specifies to view in PR units, use other connectors because there are connectors for viewing files, commit lists, and changes in PR units elsewhere.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetCommitListInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "list of commit",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetCommitListOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-followers": {
      "post": {
        "summary": "Inquire the followers of the user",
        "description": "Inquire the followers of the user\n\nThis value can be viewed by about 100 people at a time because it is a page-nated result.\nIf you have someone you're looking for, it's important to keep looking for the next page, even if you haven't found the value on the first page.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetFollowerInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetFollowerOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-followees": {
      "post": {
        "summary": "Inquire the followees of the user",
        "description": "Inquire the followees of the user\n\nThis value can be viewed by about 100 people at a time because it is a page-nated result.\nIf you have someone you're looking for, it's important to keep looking for the next page, even if you haven't found the value on the first page.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetFolloweeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetFolloweeOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/get-labels": {
      "post": {
        "summary": "List labels for a repository",
        "description": "List labels for a repository\n\nView a list of issues created and used in that repository.\nEach issue will only have labels that are already registered in this repository.\nOf course, it doesn't necessarily mean that you have to use only the labels here when creating issues,\nbut it would be beneficial to assign them by referring to the labels here.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IGetLabelInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.IGetLabelOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/issues": {
      "patch": {
        "summary": "Update an issue",
        "description": "Update an issue in the repository\n\nUpdate an issue, where you can enter labels and assignes together.\nThe information you must enter is who will create the issue in the owner's repository and under what title.\nThe information in the text should follow the markdown grammar allowed by github.\n\nIn some cases, if you are not the owner of this repository, you may not be able to make any marking on issues such as labels, assignees, milestones, etc.\nIt can also be used to close or reopen issues.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.IUpdateIssueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.Issue"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      },
      "post": {
        "summary": "Create an issue",
        "description": "Leave an issue in the repository\n\nCreate an issue, where you can enter labels and assignes together.\nThe information you must enter is who will create the issue in the owner's repository and under what title.\nThe information in the text should follow the markdown grammar allowed by github.\n\nIn some cases, if you are not the owner of this repository, you may not be able to make any marking on issues such as labels, assignees, milestones, etc.\n\nIn order to create issue, you may need to refer to the issue template files that you specified in the .github folder in advance, in which case refer to the connector 'POST /connector/github/repos/get-contents'.",
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.ICreateIssueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IGithub.Issue"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/github.svg"
      }
    },
    "/connector/github/upload": {
      "post": {
        "tags": [
          "Github"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IGithub.UploadFileInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "/connector/short-link/create": {
      "post": {
        "tags": [],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IShortLink.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IShortLink.IResponse"
                }
              }
            }
          }
        }
      }
    },
    "/connector/discord/create-dm": {
      "post": {
        "summary": "Create a DM channel",
        "description": "Create a new DM channel.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.ICreateDMRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Channel information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDiscord.IChannel"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/modify-guild": {
      "post": {
        "summary": "Modify server information",
        "description": "Modify server information.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IModifyGuildRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Modified server information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDiscord.IGuild"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/get-guild-channels": {
      "post": {
        "summary": "Get a list of channels",
        "description": "Get a list of channels on the server.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of channels",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IDiscord.IChannel"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/create-guild-channel": {
      "post": {
        "summary": "Create a channel",
        "description": "Create a new channel on the server.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.ICreateGuildChannelRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Created channel information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDiscord.IChannel"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/get-list-guild-members": {
      "post": {
        "summary": "Get a list of members",
        "description": "Get a list of members on the server.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of server members",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IDiscord.IGuildMember"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/remove-guild-member": {
      "post": {
        "summary": "Kick members",
        "description": "Kicks selected members from the server.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IRemoveGuildMember"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/modify-channel": {
      "post": {
        "summary": "Modify channel information",
        "description": "Modify channel information.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IModifyChannelRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Modified channel information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDiscord.IChannel"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/delete-channel": {
      "post": {
        "summary": "Delete channel",
        "description": "Delete the selected channel.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IDeleteChannelRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/get-pinned-messages": {
      "post": {
        "summary": "Get a list of pinned messages",
        "description": "Get a list of pinned messages in a channel.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IGetPinnedMessagesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "a list of pinned messages",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IDiscord.IMessage"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/pin-message": {
      "post": {
        "summary": "Pin a message",
        "description": "Pin a message to a channel.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IPinOrUnpinMessagesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/unpin-message": {
      "post": {
        "summary": "Unpin message",
        "description": "Unpin a pinned message from a channel.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IPinOrUnpinMessagesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/get-channel-message-histories": {
      "post": {
        "summary": "Get a list of messages",
        "description": "Get the messages that exist in the channel.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IGetChannelMessageHistoriesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of messages",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IDiscord.IMessage"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/create-message": {
      "post": {
        "summary": "Send a message",
        "description": "Send a message.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.ICreateMessageRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The generated message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDiscord.IMessage"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/edit-message": {
      "post": {
        "summary": "Modify message",
        "description": "Modify the message.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IEditMessageRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Modified message",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IDiscord.IMessage"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/delete-message": {
      "post": {
        "summary": "Delete message",
        "description": "Delete message.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IDeleteMessageRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/discord/bulk-delete-message": {
      "post": {
        "summary": "Delete multiple messages",
        "description": "Delete multiple messages.",
        "tags": [
          "Discord"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IDiscord.IBulkDeleteMessagesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/discord.svg"
      }
    },
    "/connector/calendly/scheduling_links": {
      "post": {
        "summary": "Create a new scheduling link",
        "tags": [
          "Calendly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The necessary details to create the scheduling link.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.CreateSchedulingLinkInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created scheduling link details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.CreateSchedulingLinkOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/get-event-types": {
      "post": {
        "summary": "List all event types",
        "tags": [
          "Calendly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The input required to retrieve event types.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.IGetEventTypeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The list of event types.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.IGetEventTypeOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/events/{eventId}/invitees/{inviteeId}/get-cancel-link": {
      "post": {
        "summary": "Get cancel link for invitee",
        "tags": [
          "Calendly"
        ],
        "parameters": [
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/calendly/get-scheduled-events",
                "jmesPath": "collection[].{value:uuid, label:name}"
              }
            },
            "required": true,
            "title": "The ID of the event",
            "description": " The ID of the event."
          },
          {
            "name": "inviteeId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/calendly/get-scheduled-events",
                "jmesPath": "collection[].{value:uuid, label:name}"
              }
            },
            "required": true,
            "title": "The ID of the invitee",
            "description": " The ID of the invitee."
          }
        ],
        "requestBody": {
          "description": "Additional input for cancel link retrieval.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.Secret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The cancel link for the invitee.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "iri"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/get-events/{eventId}": {
      "post": {
        "summary": "Get details of a scheduled event",
        "tags": [
          "Calendly"
        ],
        "parameters": [
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "title": "The UUID of the event",
            "description": " The UUID of the event."
          }
        ],
        "requestBody": {
          "description": "Additional input for event retrieval.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.Secret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The detailed information of the scheduled event.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.IGetOneScheduledEventOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/get-scheduled-events": {
      "post": {
        "summary": "Get all scheduled events",
        "tags": [
          "Calendly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The input to filter scheduled events.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.IGetScheduledEventInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The list of scheduled events.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.IGetScheduledEventOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/events/{eventId}/invitees/{inviteeId}/no-show": {
      "post": {
        "summary": "Mark an invitee as no-show",
        "tags": [
          "Calendly"
        ],
        "parameters": [
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "title": "The UUID of the event",
            "description": " The UUID of the event."
          },
          {
            "name": "inviteeId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "title": "The UUID of the invitee",
            "description": " The UUID of the invitee."
          }
        ],
        "requestBody": {
          "description": "Additional input for no-show marking.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.Secret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The result of the no-show marking.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.ICheckNoShowOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/events/{eventId}/invitees/{inviteeId}": {
      "post": {
        "summary": "Get invitee details",
        "tags": [
          "Calendly"
        ],
        "parameters": [
          {
            "name": "eventId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "title": "The UUID of the event",
            "description": " The UUID of the event."
          },
          {
            "name": "inviteeId",
            "in": "path",
            "schema": {
              "type": "string"
            },
            "required": true,
            "title": "The UUID of the invitee",
            "description": " The UUID of the invitee."
          }
        ],
        "requestBody": {
          "description": "Additional input for invitee retrieval.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.Secret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The details of the invitee.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.IGetOneScheduledEventInviteeOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/events/get-invitees": {
      "post": {
        "summary": "Get all invitees for a scheduled event",
        "tags": [
          "Calendly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The input to filter invitees.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.IGetScheduledEventInviteeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The list of invitees for the event.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.IGetScheduledEventInviteeOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/one-off-event-types": {
      "post": {
        "summary": "Create a one-off event type",
        "tags": [
          "Calendly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The details needed to create a one-off event type.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.ICreateOneOffEventTypeInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created one-off event type details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.ICreateOneOffEventTypeOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/calendly/users/get-me": {
      "post": {
        "summary": "Get authenticated user details",
        "tags": [
          "Calendly"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The input required to get the user details.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ICalendly.Secret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The authenticated user's details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ICalendly.IGetUserInfoOutput"
                }
              }
            }
          }
        }
      }
    },
    "/connector/ai-search": {
      "post": {
        "summary": "AI search",
        "description": "Returns search results via AI search.",
        "tags": [
          "AI Search"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Conditions required for search",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IAISearch.IRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/connector/typeform/workspace": {
      "post": {
        "summary": "Create a Typeform workspace.",
        "description": "Create a workspace.",
        "tags": [
          "Typeform"
        ],
        "parameters": [],
        "requestBody": {
          "description": "Title of the workspace to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.ICreateWorkspaceInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created workspace ID, title, and URL.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ITypeform.ICreateWorkspaceOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/typeform/workspace/{workspaceId}": {
      "delete": {
        "summary": "Delete a Typeform workspace.",
        "description": "Delete a workspace.",
        "tags": [
          "Typeform"
        ],
        "parameters": [
          {
            "name": "workspaceId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/typeform/get-workspaces",
                "jmesPath": "[].{value:workspace_id, label:name || '워크스페이스 이름'}"
              }
            },
            "required": true,
            "title": "The workspace ID to delete",
            "description": " The workspace ID to delete."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/typeform/get-workspaces": {
      "post": {
        "summary": "Get Typeform workspace information.",
        "description": "Get workspace information.",
        "tags": [
          "Typeform"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Workspace ID, Title, URL.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ITypeform.IFindWorkspaceOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/typeform/empty-form": {
      "post": {
        "summary": "Typeform Create an empty form.",
        "description": "Create an empty form in the workspace.",
        "tags": [
          "Typeform"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The title of the form to be created.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.ICreateEmptyFormInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The ID, title, and type of the generated form.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ITypeform.ICreateFormOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/typeform/get-forms": {
      "post": {
        "summary": "Get a list of Typeform forms.",
        "description": "Get a list of forms that exist in the workspace.",
        "tags": [
          "Typeform"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "form ID, title.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ITypeform.IFindFormOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/typeform/duplicate-form": {
      "post": {
        "summary": "Copy a Typeform form.",
        "description": "Copy a form that exists in the workspace.",
        "tags": [
          "Typeform"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The name of the form to copy and create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.IDuplicateExistingFormInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The generated form ID, title, and type.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ITypeform.ICreateFormOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/typeform/forms/get-update-form-fields": {
      "post": {
        "summary": "Get the field information of the form to update Typeform.",
        "description": "Get the field information of the form to update the options of the ranking, dropdown, and multiple choice questions.",
        "tags": [
          "Typeform"
        ],
        "parameters": [],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.IGetFieldForUpdateFieldValueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The field ID and field name of the form.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ITypeform.IFieldInfoForUpdateFieldValueOutput"
                  }
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/typeform/form-field-value-update": {
      "post": {
        "summary": "Updates Typeform form field options.",
        "description": "Updates options for ranking, dropdown, and multiple choice questions.",
        "tags": [
          "Typeform"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The name of the form field to update and the value to update.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.IUpdateFormFieldValueInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ITypeform.IUpdateFormFieldValueOutput"
                }
              }
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/typeform/forms/{formId}": {
      "delete": {
        "summary": "Delete a typeform form.",
        "description": "Delete a form.",
        "tags": [
          "Typeform"
        ],
        "parameters": [
          {
            "name": "formId",
            "in": "path",
            "schema": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/typeform/get-forms",
                "jmesPath": "[].{value:formId, label:name || '폼 이름'}"
              }
            },
            "required": true,
            "title": "The ID of the form to delete",
            "description": " The ID of the form to delete."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ITypeform.ISecret"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-wrtn-icon": "https://ecosystem-connector.s3.ap-northeast-2.amazonaws.com/icon/typeform.svg"
      }
    },
    "/connector/marp/convert-to-ppt": {
      "post": {
        "summary": "Convert Marp markdown to PPT",
        "description": "Convert Marp markdown to PPT and store in S3\n\nWhen you write a markdown according to marp grammar, you convert it to create an html file that contains all of that content.\nBecause users won't know the markdown and marp grammar, this should be automatically generated by LLM, and users just need to provide the format, image, text, etc. they want.\nSo, instead of asking the user to provide marp or markdown grammar, ask for hints on how to organize the template and how to deploy it.\nAsking the user to write according to the Marp grammar directly can be difficult, even if the other person is the developer!\nAll tasks such as making presentation materials or organizing contents with slides, such as pptx, google slides, html, markdown (marp), and hanshow, may have to go through a connector that changes marp to this pptx.\n\nWarning: If you put too much content on a single slide, the content may be cut out and invisible. Split the content into several slides.",
        "tags": [
          "Marp",
          "pptx",
          "hanshow",
          "ppt",
          "powerpoint",
          "markdown",
          "marp"
        ],
        "parameters": [],
        "requestBody": {
          "description": "The Marp markdown string",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IMarp.IConvertInput"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The S3 link of the converted PPT",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IMarp.IConvertOutput"
                }
              }
            }
          }
        }
      }
    },
    "/swagger/update": {
      "post": {
        "summary": "Swagger.json update",
        "description": "Swagger.json update.",
        "tags": [],
        "parameters": [],
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "IRunWorkflowOutput": {
        "type": "object",
        "properties": {
          "workflowRunId": {
            "type": "string",
            "title": "Workflow run id.",
            "description": "Workflow run id."
          }
        },
        "required": [
          "workflowRunId"
        ]
      },
      "IRunWorkflowInput": {
        "type": "object",
        "properties": {
          "workflowId": {
            "oneOf": [
              {
                "const": "marketing"
              },
              {
                "const": "student-report"
              }
            ],
            "title": "Workflow id.",
            "description": "Workflow id.\nUsually this should be uuid, but for PoC we only have two fixed workflows."
          }
        },
        "required": [
          "workflowId"
        ]
      },
      "IWorkflowRunStatus": {
        "type": "object",
        "properties": {
          "workflowRunId": {
            "type": "string",
            "title": "Workflow run id.",
            "description": "Workflow run id."
          },
          "workflowId": {
            "type": "string",
            "title": "Workflow Id.",
            "description": "Workflow id."
          },
          "status": {
            "oneOf": [
              {
                "const": "running"
              },
              {
                "const": "finished"
              },
              {
                "const": "failed"
              }
            ],
            "title": "running status.",
            "description": "Workflow running status.\n\n- running: running.\n- finished: running completed.\n- failed: running failed."
          },
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGetNodeOutput"
            },
            "title": "Node execution result.",
            "description": "Node execution result."
          }
        },
        "required": [
          "workflowRunId",
          "workflowId",
          "status",
          "outputs"
        ]
      },
      "IGetNodeOutput": {
        "type": "object",
        "properties": {
          "result": {
            "title": "Node execution result.",
            "description": "Node execution result."
          }
        },
        "required": [
          "result"
        ]
      },
      "IGetWorkflowRunsOutput": {
        "type": "object",
        "properties": {
          "workflowRuns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IWorkflowRunStatus"
            },
            "title": "Workflow execution list.",
            "description": "Workflow execution list."
          }
        },
        "required": [
          "workflowRuns"
        ]
      },
      "IGetWorkflowRunsInput": {
        "type": "object",
        "properties": {
          "workflowId": {
            "type": "string",
            "title": "Workflow id.",
            "description": "If not specified, returns all runs."
          }
        }
      },
      "IKeywordExtraction.IExtractKeywordOutput": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "description": "Extracted Keywords"
          }
        },
        "required": [
          "keyword"
        ]
      },
      "IKeywordExtraction.IExtractKeywordInput": {
        "type": "object",
        "properties": {
          "referenceContent": {
            "$ref": "#/components/schemas/IConnector.IReferenceContent",
            "title": "References",
            "description": "References for keyword extraction"
          },
          "context": {
            "title": "Contextual information",
            "description": "Contextual information for keyword extraction"
          }
        },
        "required": [
          "referenceContent",
          "context"
        ],
        "title": "Input for keyword extraction"
      },
      "IConnector.IReferenceContent": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "description": "The title of the output."
          },
          "type": {
            "oneOf": [
              {
                "const": "video",
                "title": "video"
              },
              {
                "const": "image",
                "title": "image"
              },
              {
                "const": "news_article",
                "title": "news_article"
              },
              {
                "const": "research_paper",
                "title": "research_paper"
              }
            ],
            "title": "Output Type",
            "description": "Video, image, news article, research paper.\n\nIt must be one of: video, image, news_article, research_paper"
          },
          "source": {
            "oneOf": [
              {
                "const": "youtube",
                "title": "youtube"
              },
              {
                "const": "facebook",
                "title": "facebook"
              },
              {
                "const": "instagram",
                "title": "instagram"
              },
              {
                "const": "google_search",
                "title": "google_search"
              },
              {
                "const": "arxiv",
                "title": "arxiv"
              },
              {
                "const": "google_news",
                "title": "google_news"
              }
            ],
            "title": "Source of output",
            "description": "youtube, facebook, instagram, google_search, arxiv, google_news\n\nIt must be one of: youtube, facebook, instagram, google_search, arxiv, google_news"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "URL address",
            "description": "The URL address of the output."
          },
          "contents": {
            "type": "string",
            "title": "Output Content",
            "description": "Here is the content of the output."
          },
          "image": {
            "type": "string",
            "format": "iri",
            "title": "Output Image URL",
            "description": "The URL address of the image of the output."
          },
          "statistics": {
            "$ref": "#/components/schemas/MyPartialRecordIConnector.MetricTypenumberTypeint32",
            "title": "Output statistics information",
            "description": "Output statistics information.\n\nPossible values: view_count, like_count, rank"
          }
        },
        "required": [
          "title",
          "type",
          "source",
          "url"
        ]
      },
      "MyPartialRecordIConnector.MetricTypenumberTypeint32": {
        "type": "object",
        "properties": {
          "view_count": {
            "type": "integer"
          },
          "like_count": {
            "type": "integer"
          },
          "rank": {
            "type": "integer"
          }
        }
      },
      "IRanker.IRankOutput": {
        "type": "object",
        "properties": {
          "rankedIndices": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "title": "Array of indexes of sorted items",
            "description": "Array of indexes of sorted items"
          }
        },
        "required": [
          "rankedIndices"
        ],
        "title": "Sorted results"
      },
      "IRanker.IRankInput": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IRanker.IScoredItem"
            },
            "title": "List of items",
            "description": "List of items to sort"
          }
        },
        "required": [
          "items"
        ],
        "title": "Input for sorting"
      },
      "IRanker.IScoredItem": {
        "type": "object",
        "properties": {
          "score": {
            "type": "number",
            "title": "Score",
            "description": "Item Score"
          }
        },
        "required": [
          "score"
        ],
        "title": "Items to sort"
      },
      "MyPartialIMarketingCopyComponents": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "The title of your marketing copy.",
            "description": "The title of your marketing copy."
          },
          "cta": {
            "type": "string",
            "title": "This is the CTA phrase in your marketing copy.",
            "description": "This is the CTA phrase in your marketing copy."
          },
          "subtitle": {
            "type": "string",
            "title": "A description of the marketing copy.",
            "description": "Here is a description of the marketing copy."
          }
        }
      },
      "IMarketingCopyGenerator.IGenerateMarketingCopyInput": {
        "type": "object",
        "properties": {
          "keyword": {
            "$ref": "#/components/schemas/IKeywordExtraction.IExtractKeywordOutput",
            "title": "Keywords",
            "description": "Overall keywords in your marketing copy"
          },
          "marketingPurpose": {
            "$ref": "#/components/schemas/IMarketingPurpose",
            "title": "Marketing Purpose",
            "description": "Purpose of marketing and product information"
          },
          "distributionChannel": {
            "$ref": "#/components/schemas/IDistributionChannel",
            "title": "Marketing Channel",
            "description": "Channel information for using marketing copy"
          },
          "referenceContent": {
            "$ref": "#/components/schemas/IConnector.IReferenceContent",
            "title": "References",
            "description": "References for Creating Marketing Copy"
          }
        },
        "required": [
          "keyword",
          "marketingPurpose",
          "distributionChannel",
          "referenceContent"
        ],
        "title": "Input for creating marketing copy"
      },
      "IMarketingPurpose": {
        "type": "object",
        "properties": {
          "purpose": {
            "oneOf": [
              {
                "const": "sign_up"
              },
              {
                "const": "purchase"
              },
              {
                "const": "visit"
              }
            ],
            "title": "Marketing purpose.",
            "description": "The purpose is to do marketing.\n\nOnly three possible values are available: sign_up, purchase, and visit."
          },
          "product_name": {
            "type": "string",
            "title": "This is the product name to be marketed.",
            "description": "This is the product name to be marketed."
          },
          "unique_selling_point": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "This is the selling point of the product.",
            "description": "This is the selling point of the product."
          },
          "user_benefit": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Benefits of the product you are marketing.",
            "description": "Benefits of the product you are marketing."
          }
        },
        "required": [
          "purpose",
          "product_name",
          "unique_selling_point",
          "user_benefit"
        ]
      },
      "IDistributionChannel": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "const": "youtube"
              },
              {
                "const": "facebook"
              },
              {
                "const": "kakao"
              },
              {
                "const": "instagram_feed"
              },
              {
                "const": "instagram_story"
              },
              {
                "const": "naver"
              }
            ],
            "title": "Channels to use marketing copy.",
            "description": "Channels to use marketing copy.\n\nOnly 6 possible values are possible: facebook, instagram_feed, instagram_story, youtube, naver, kakao."
          },
          "components": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "title"
                },
                {
                  "const": "cta"
                },
                {
                  "const": "subtitle"
                }
              ]
            },
            "title": "Information to retrieve from the channel where the marketing copy will be used.",
            "description": "Information to retrieve from the channel where the marketing copy will be used.\n\nOnly three possible values are possible: title, cta, subtitle."
          }
        },
        "required": [
          "channel",
          "components"
        ]
      },
      "IMarketingCopyImage": {
        "type": "object",
        "properties": {
          "imageUrl": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Image URL of the generated marketing copy draft.",
            "description": "Image URL of the generated marketing copy draft."
          }
        },
        "required": [
          "imageUrl"
        ]
      },
      "IMarketingCopyGenerator.IGenerateMarketingCopyImageInput": {
        "type": "object",
        "properties": {
          "copy": {
            "$ref": "#/components/schemas/MyPartialIMarketingCopyComponents",
            "title": "Marketing Copy Creation Results",
            "description": "Marketing Copy Creation Results Related to Marketing Copy Image"
          },
          "keyword": {
            "$ref": "#/components/schemas/IKeywordExtraction.IExtractKeywordOutput",
            "title": "Keywords",
            "description": "Overall keywords for marketing copy images"
          },
          "marketingPurpose": {
            "$ref": "#/components/schemas/IMarketingPurpose",
            "title": "Marketing Purpose",
            "description": "Purpose of marketing and product information"
          },
          "distributionChannel": {
            "$ref": "#/components/schemas/IDistributionChannel",
            "title": "Marketing Channel",
            "description": "Channel information for using marketing copy"
          },
          "referenceContent": {
            "$ref": "#/components/schemas/IConnector.IReferenceContent",
            "title": "References",
            "description": "References for Creating Marketing Copy"
          }
        },
        "required": [
          "copy",
          "keyword",
          "marketingPurpose",
          "distributionChannel",
          "referenceContent"
        ],
        "title": "Input for generating marketing copy images"
      },
      "IAws.IGetPutObjectUrlOutput": {
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "format": "uuid",
            "title": "file uuid",
            "description": "This is the file uuid."
          },
          "uploadUrl": {
            "type": "string",
            "title": "upload url",
            "description": "This is the url for uploading the file."
          },
          "urlExpTsMillis": {
            "type": "number",
            "title": "url expiration time",
            "description": "url expiration time."
          }
        },
        "required": [
          "uuid",
          "uploadUrl",
          "urlExpTsMillis"
        ]
      },
      "IAws.IGetPutObjectUrlInput": {
        "type": "object",
        "properties": {
          "extension": {
            "type": "string",
            "title": "File extension",
            "description": "File extension."
          }
        },
        "required": [
          "extension"
        ]
      },
      "IStudentReportGeneratorResponse": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ITableRowData"
            },
            "title": "Generated life data.",
            "description": "Generated life data."
          }
        },
        "required": [
          "data"
        ]
      },
      "ITableRowData": {
        "type": "object",
        "properties": {},
        "additionalProperties": {
          "type": "string"
        }
      },
      "IStudentReportGeneratorRequest": {
        "type": "object",
        "properties": {
          "consideration": {
            "type": "string",
            "title": "Things to consider.",
            "description": "Here are some things to consider when generating your biometric data to pass on to your LLM."
          },
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IOutputStructure"
            },
            "title": "This is the data structure of the generated lifeblood.",
            "description": "This is the data structure of the generated lifeblood."
          },
          "reference_data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ITableRowData"
            },
            "title": "Reference data.",
            "description": "This is the data for the table to reference when creating the life data."
          }
        },
        "required": [
          "consideration",
          "outputs",
          "reference_data"
        ]
      },
      "IOutputStructure": {
        "type": "object",
        "properties": {
          "field_name": {
            "type": "string",
            "title": "The field name to be generated from LLM.",
            "description": "The field name to be generated from LLM."
          },
          "field_description": {
            "type": "string",
            "title": "Description of the field.",
            "description": "Description of the field and guidance on how LLM should fill it out."
          },
          "example": {
            "type": "string",
            "title": "Example for the field.",
            "description": "Here is an example for the field."
          }
        },
        "required": [
          "field_name",
          "field_description",
          "example"
        ]
      },
      "IStudentReportRowGeneratorResponse": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/ITableRowData",
            "title": "Generated life data.",
            "description": "Generated life data."
          }
        },
        "required": [
          "data"
        ]
      },
      "IStudentReportRowGeneratorRequest": {
        "type": "object",
        "properties": {
          "consideration": {
            "type": "string",
            "title": "Things to consider.",
            "description": "Here are some things to consider when generating your biometric data to pass on to your LLM."
          },
          "output_structure": {
            "$ref": "#/components/schemas/IOutputStructure",
            "title": "This is the data structure of the generated lifeblood.",
            "description": "This is the data structure of the generated lifeblood."
          },
          "reference_data": {
            "$ref": "#/components/schemas/ITableRowData",
            "title": "Reference data.",
            "description": "This is the data for the table to reference when creating the life data."
          }
        },
        "required": [
          "consideration",
          "output_structure",
          "reference_data"
        ]
      },
      "IRag.IAnalysisOutput": {
        "type": "object",
        "properties": {
          "chatId": {
            "type": "string",
            "title": "chat id.",
            "description": "Chat id required for RAG generation results.\nReturns the chat id for the analyzed file to generate chat results for the file analyzed by RAG.\nThe same chat id is required to analyze multiple files and generate results for multiple files in the same chat."
          }
        },
        "required": [
          "chatId"
        ],
        "title": "RAG analysis results"
      },
      "IRag.IAnalyzeInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "application/pdf, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.hancom.hwp, text/plain, text/html"
            },
            "title": "Knowledge that the chatbot will use to answer",
            "description": "Knowledge that the chatbot will use to answer"
          }
        },
        "required": [
          "url"
        ],
        "title": "Knowledge that the chatbot will use to answer"
      },
      "IRag.IStatusOutput": {
        "type": "object",
        "properties": {
          "status": {
            "oneOf": [
              {
                "const": "COMPLETED"
              },
              {
                "const": "FAILED"
              },
              {
                "const": "RUNNING"
              }
            ],
            "title": "Analysis status.",
            "description": "Analysis status.\n\n- RUNNING: Analysis in progress\n- COMPLETED: Analysis completed\n- FAILED: Analysis failed"
          }
        },
        "required": [
          "status"
        ],
        "title": "RAG Analysis Status"
      },
      "IRag.IGenerateOutput": {
        "type": "object",
        "properties": {
          "answer": {
            "type": "string",
            "title": "Response to utterance.",
            "description": "Response to RAG-based creation request."
          }
        },
        "required": [
          "answer"
        ],
        "title": "Chat results via RAG"
      },
      "IRag.IGenerateInput": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "title": "User utterance.",
            "description": "This is a user utterance."
          }
        },
        "required": [
          "query"
        ],
        "title": "Information required for chatting via RAG"
      },
      "IHwp.IParseOutput": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "text",
            "description": "Text of the parsed hwp file"
          }
        },
        "required": [
          "text"
        ],
        "title": "hwp file parsing result"
      },
      "IHwp.IParseInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.hancom.hwp",
            "title": "hwp file",
            "description": "hwp file to parse."
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "Information for parsing hwp files"
      },
      "IExcel.IReadExcelInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Excel file",
            "description": "Excel file to read"
          },
          "sheetName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "Sheet1"
              }
            ],
            "title": "sheet name",
            "description": "Sheet name to read"
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "file information"
      },
      "IExcel.IReadExcelOutput": {
        "type": "object",
        "properties": {
          "headers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "headers of this sheet"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IExcel.IReadExcelRowData"
            },
            "title": "Excel sheet data"
          }
        },
        "required": [
          "headers",
          "data"
        ],
        "title": "Excel file reading result"
      },
      "IExcel.IReadExcelRowData": {
        "type": "object",
        "properties": {},
        "title": "Read Excel row data",
        "additionalProperties": {}
      },
      "IExcel.IWorksheetListOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "sheetName": {
                  "type": "string",
                  "title": "sheet name",
                  "description": "Name of the imported worksheet"
                },
                "id": {
                  "type": "number",
                  "title": "sheet id",
                  "description": "The id of the imported worksheet."
                }
              },
              "required": [
                "sheetName",
                "id"
              ]
            },
            "title": "sheet list data"
          }
        },
        "required": [
          "data"
        ],
        "title": "List of imported worksheets"
      },
      "IExcel.IGetWorksheetListInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Excel file",
            "description": "File to import list of Excel worksheets"
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "file information"
      },
      "IExcel.IExportExcelFileOutput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Generated Excel file url"
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "Excel row addition result"
      },
      "IExcel.IInsertExcelRowByUploadInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "엑셀 파일",
            "description": "엑셀 행을 추가할 파일\n\nIf you have this address, take an Excel file from that path and modify it.\nThe modified file is saved as a new link and does not modify the original file in this path.\nIf this address does not exist, create a new file immediately."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Recordstringany"
            },
            "title": "Excel row data to add",
            "description": "An array of objects where the key is the header name and the value is the value of the corresponding row"
          },
          "sheetName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "Sheet1"
              }
            ],
            "title": "Excel sheet name",
            "description": "Sheet name to add Excel rows to\nIf no input is entered, the first sheet is used as the default."
          }
        },
        "required": [
          "data"
        ],
        "title": "Information for adding data"
      },
      "Recordstringany": {
        "type": "object",
        "properties": {},
        "description": "Construct a type with a set of properties K of type T",
        "additionalProperties": {}
      },
      "IExcel.IInsertExcelRowInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "iri",
            "title": "엑셀 파일",
            "description": "엑셀 행을 추가할 파일\n\nIf you have this address, take an Excel file from that path and modify it.\nThe modified file is saved as a new link and does not modify the original file in this path.\nIf this address does not exist, create a new file immediately."
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Recordstringany"
            },
            "title": "Excel row data to add",
            "description": "An array of objects where the key is the header name and the value is the value of the corresponding row"
          },
          "sheetName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "Sheet1"
              }
            ],
            "title": "Excel sheet name",
            "description": "Sheet name to add Excel rows to\nIf no input is entered, the first sheet is used as the default."
          }
        },
        "required": [
          "data"
        ],
        "title": "Information for adding data"
      },
      "IExcel.ICreateSheetInput": {
        "type": "object",
        "properties": {
          "sheetName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "Sheet1"
              }
            ],
            "title": "Excel sheet name",
            "description": "Sheet name to add Excel rows to\nIf no input is entered, the first sheet is used as the default."
          }
        }
      },
      "IGoogleDocs.ICreateGoogleDocsOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated docs id.",
            "description": "The ID of the generated docs."
          }
        },
        "required": [
          "id"
        ],
        "title": "Google Docs creation result"
      },
      "IGoogleDocs.ICreateGoogleDocsInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Google docs title.",
            "description": "The title of the docs to be generated."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Information required to create Google docs"
      },
      "IGoogleDocs.IPermissionGoogleDocsInput": {
        "type": "object",
        "properties": {
          "documentId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-docs/get-list",
              "jmesPath": "data[].{value:id, label:title}"
            },
            "title": "Google docs id.",
            "description": "The id of the Google docs to which you want to grant access."
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IPermission"
            },
            "title": "Here is a list of emails to make accessible and the permissions to grant.",
            "description": "Here is a list of emails to make accessible and the permissions to grant."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "documentId",
          "permissions",
          "secretKey"
        ],
        "title": "Information required to grant Google Docs permissions"
      },
      "IPermission": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "The email address of the user to grant permission to.",
            "description": "The email address of the user to grant permission to."
          },
          "role": {
            "oneOf": [
              {
                "const": "owner"
              },
              {
                "const": "writer"
              },
              {
                "const": "commenter"
              },
              {
                "const": "reader"
              },
              {
                "const": "organizer"
              },
              {
                "const": "fileOrganizer"
              }
            ],
            "title": "The permission to grant.",
            "description": "The type of permission to grant.\n\nowner: Grants owner permissions. Users with this permission can delete files or folders or grant permissions to other users.\norganizer: Grants operator permissions for the drive. Users with this permission can manage the organization of the drive.\nfileOrganizer: Grants operator permissions for files on the drive. Users with this permission can add or delete files.\nwriter: Grants write permissions. Users with this permission can modify or delete files.\ncommenter: Grants comment permissions. Users with this permission can read and comment on files.\nreader: Grants read permissions. Users with this permission can read files.\n\nThere are only six possible values: \"owner\", \"writer\", \"commenter\", \"reader\", \"organizer\", \"fileOrganizer\"."
          },
          "type": {
            "oneOf": [
              {
                "const": "user"
              },
              {
                "const": "group"
              },
              {
                "const": "domain"
              },
              {
                "const": "anyone"
              }
            ],
            "title": "The type of permission to grant.",
            "description": "The type of permission to grant.\n\nuser - a specific user, in this case you must specify the email address of the user to grant the permission to in the emailAddress field.\ngroup - a specific group, in this case you must specify the email address of the group to grant the permission to in the emailAddress field.\ndomain - a specific domain, in this case you must specify the domain to grant the permission to in the domain field.\nanyone - all users\n\nThere are only four possible values: \"user\", \"group\", \"domain\", \"anyone\"."
          }
        },
        "required": [
          "email",
          "role",
          "type"
        ],
        "title": "Authorization information"
      },
      "IGoogleDocs.IReadGoogleDocsOutput": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/IGoogleDocs",
            "title": "Google docs data.",
            "description": "This is data from Google docs that I read."
          }
        },
        "required": [
          "data"
        ],
        "title": "Google Docs search results"
      },
      "IGoogleDocs": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "text information.",
            "description": "Here is the text information from Google Docs."
          },
          "table": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "title": "Table Information.",
            "description": "Here is the table information from Google Docs."
          }
        }
      },
      "IGoogleDocs.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Authentication Information"
      },
      "IGoogleDocs.ICreateDocByTemplateOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated docs id.",
            "description": "The id of the copied docs."
          }
        },
        "required": [
          "id"
        ],
        "title": "Google Docs Duplication Results"
      },
      "IGoogleDocs.ICreateDocByTemplateInput": {
        "type": "object",
        "properties": {
          "templateId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-docs/get-list",
              "jmesPath": "data[].{value:id, label:title}"
            },
            "title": "Google docs to clone.",
            "description": "Google docs to clone."
          },
          "title": {
            "type": "string",
            "title": "The title of the docs to be created.",
            "description": "The title of the docs to be newly created by duplicating."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "templateId",
          "title",
          "secretKey"
        ],
        "title": "Information needed to duplicate Google Docs"
      },
      "IGoogleDocs.IListGoogleDocsOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google docs id.",
                  "description": "The id of the imported Google docs."
                },
                "title": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google docs title.",
                  "description": "The title of the imported Google docs."
                }
              }
            },
            "title": "List of Google docs.",
            "description": "Here is a list of Google docs that were searched."
          }
        },
        "required": [
          "data"
        ],
        "title": "Google docs list query results"
      },
      "IGoogleDocs.IAppendTextGoogleDocsInput": {
        "type": "object",
        "properties": {
          "documentId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-docs/get-list",
              "jmesPath": "data[].{value:id, label:title}"
            },
            "title": "Google docs.",
            "description": "Select the Google docs you want to add text to."
          },
          "text": {
            "type": "string",
            "title": "text.",
            "description": "The text to add."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive",
              "https://www.googleapis.com/auth/documents"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "documentId",
          "text",
          "secretKey"
        ],
        "title": "Information needed to add text to Google Docs"
      },
      "IGoogleSheet.IReadGoogleSheetOutput": {
        "type": "object",
        "properties": {
          "data": {
            "title": "Sheet data.",
            "description": "This is the data from the read sheet."
          }
        },
        "required": [
          "data"
        ],
        "title": "Google Sheet Reading Results"
      },
      "IGoogleSheet.IReadGoogleSheetHeadersInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "sheet url.",
            "description": "The url address of the sheet from which to read the header information."
          },
          "index": {
            "type": "number",
            "title": "Sheet header index.",
            "description": "The header index of the sheet to read."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "secretKey"
        ],
        "title": "Information needed to read Google Sheet header"
      },
      "IGoogleSheet.IAppendToSheetInput": {
        "type": "object",
        "properties": {
          "spreadSheetId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-sheet/create",
              "jmesPath": "[].{value:spreadsheetId, label:spreadsheetUrl}"
            },
            "title": "The sheet to add",
            "description": "This is the sheet to which you want to add content."
          },
          "range": {
            "type": "string",
            "title": "Range to add",
            "description": "This is the range to add.\n\nPlease enter in A1 notation format."
          },
          "values": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {}
            },
            "title": "These are the values to add",
            "description": "These are the values to add."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "spreadSheetId",
          "range",
          "values",
          "secretKey"
        ]
      },
      "IGoogleSheet.ICreateGoogleSheetOutput": {
        "type": "object",
        "properties": {
          "spreadsheetId": {
            "type": "string",
            "title": "Sheet ID",
            "description": "The ID of the generated Google Spreadsheet."
          },
          "spreadsheetUrl": {
            "type": "string",
            "title": "Sheet URL",
            "description": "The URL of the generated Google Spreadsheet."
          }
        },
        "required": [
          "spreadsheetId",
          "spreadsheetUrl"
        ],
        "title": "Google Spreadsheet Creation Results"
      },
      "IGoogleSheet.ICreateGoogleSheetInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Sheet Title",
            "description": "Please enter a title for the Google Spreadsheet you want to create."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Information needed to create a Google Spreadsheet"
      },
      "IGoogleSheet.IPermissionInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "iri",
            "title": "sheet url.",
            "description": "The url of the sheet to grant permission to."
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IPermission.o1"
            },
            "title": "Here is a list of emails to make accessible and permissions to grant.",
            "description": "Here is a list of emails to make accessible and permissions to grant."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "permissions",
          "secretKey"
        ],
        "title": "Information required to grant Google Sheets permissions"
      },
      "IPermission.o1": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "The email address of the user to grant permission to.",
            "description": "The email address of the user to grant permission to."
          },
          "role": {
            "oneOf": [
              {
                "const": "owner"
              },
              {
                "const": "writer"
              },
              {
                "const": "commenter"
              },
              {
                "const": "reader"
              }
            ],
            "title": "The permission to grant.",
            "description": "The type of permission to grant.\n\nowner: Grants owner permission. Users with this permission can delete files or folders, or grant permission to other users.\nwriter: Grants write permission. Users with this permission can modify or delete files.\ncommenter: Grants comment permission. Users with this permission can read files and post comments.\nreader: Grants read permission. Users with this permission can read files.\n\nThere are only four possible values: \"owner\", \"writer\", \"commenter\", and \"reader\"."
          }
        },
        "required": [
          "email",
          "role"
        ],
        "title": "Permissions Information"
      },
      "IGoogleSheet.IWriteGoogleSheetHeadersInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "sheet url.",
            "description": "The url of the sheet to which you want to add the header."
          },
          "index": {
            "type": "number",
            "title": "sheet index.",
            "description": "The index of the header to add."
          },
          "headerNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "A list of headers to add to the sheet.",
            "description": "A list of headers to add to the sheet."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "headerNames",
          "secretKey"
        ],
        "title": "Information needed to add a Google Sheet header"
      },
      "IGoogleSheet.IGetWorkSheetOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "List of worksheet titles.",
            "description": "Here is a list of titles for the sheets you've read."
          }
        },
        "required": [
          "data"
        ],
        "title": "Worksheet query results"
      },
      "IGoogleSheet.IGetWorkSheetInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "sheet url.",
            "description": "The url of the sheet to read."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "secretKey"
        ],
        "title": "Information required to view worksheets"
      },
      "IGoogleSheet.IReadGoogleSheetRowsOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleSheet.IReadGoogleSheetRowData"
            },
            "title": "Read Google Sheet row data.",
            "description": "This is the read Google Sheet row data."
          }
        },
        "required": [
          "data"
        ],
        "title": "Google Sheets Row Reading Results"
      },
      "IGoogleSheet.IReadGoogleSheetRowData": {
        "type": "object",
        "properties": {},
        "title": "Google Sheets Row Data Information",
        "additionalProperties": {}
      },
      "IGoogleSheet.IReadGoogleSheetRowsInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "sheet url.",
            "description": "The url of the sheet from which to read the rows."
          },
          "workSheetTitle": {
            "type": "string",
            "title": "The title of the sheet to work on.",
            "description": "The title of the sheet to work on."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/spreadsheets",
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "workSheetTitle",
          "secretKey"
        ],
        "title": "Information needed to read Google Sheet rows"
      },
      "IGoogleCalendar.IGoogleCalendarOutput": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Calendar id.",
            "description": "The id of the generated calendar."
          },
          "summary": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Calendar name.",
            "description": "The name of the generated calendar."
          }
        },
        "title": "Calendar creation result"
      },
      "IGoogleCalendar.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Authentication Information"
      },
      "IGoogleCalendar.ICreateCalendarInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "The title of the calendar to be created.",
            "description": "The title of the calendar to be created."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Information for creating a calendar"
      },
      "IGoogleCalendar.IReadGoogleCalendarEventOutput": {
        "type": "object",
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent"
            },
            "title": "Event List.",
            "description": "Here is a list of calendar events that were found."
          }
        },
        "required": [
          "events"
        ],
        "title": "Calendar Event Search Results"
      },
      "IGoogleCalendar.IGoogleCalendarEvent": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "event id.",
            "description": "The unique id of the event."
          },
          "htmlLink": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Event Link.",
            "description": "Here is the event link."
          },
          "color": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event color.",
            "description": "Event color."
          },
          "createdDate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The event creation date.",
            "description": "The event creation date."
          },
          "updatedDate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event update date.",
            "description": "Event update date."
          },
          "title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event title.",
            "description": "This is the event title."
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event description.",
            "description": "Event description."
          },
          "location": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event Location.",
            "description": "This is the event location."
          },
          "organizer": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IOrganizer"
              }
            ],
            "title": "Event Organizer.",
            "description": "Here is the information for the event organizer."
          },
          "creator": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.ICreator"
              }
            ],
            "title": "Event Creator.",
            "description": "Information about the event creator."
          },
          "startDate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "dateTime": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "Event start date.",
                    "description": "Event start date."
                  },
                  "timeZone": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "Event start date time zone.",
                    "description": "Event start date time zone."
                  }
                }
              }
            ],
            "title": "Event Start Date.\n\nThe start date information for the event."
          },
          "endDate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "dateTime": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "The event ends on this date.",
                    "description": "The event ends on this date."
                  },
                  "timeZone": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "title": "Event End Date Timezone.",
                    "description": "Event End Date Timezone."
                  }
                }
              }
            ],
            "title": "Event end date.",
            "description": "This is the event end date information."
          },
          "recurrence": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "Event repeat information.",
            "description": "Event repeat information."
          },
          "transparency": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event busy/free status.",
            "description": "Event busy/free status."
          },
          "guestsCanModify": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the inviter has permission to edit the event.",
            "description": "Whether the inviter has permission to edit the event."
          },
          "reminders": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IReminders"
              }
            ],
            "title": "Event notification information.",
            "description": "Event notification information."
          },
          "attendees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IAttendees"
                }
              }
            ],
            "title": "Event Attendee.",
            "description": "Here is the event attendee information."
          },
          "attachments": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IAttachments"
                }
              }
            ],
            "title": "Attachment information.",
            "description": "Event attachment information."
          },
          "hangoutLink": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Google Meet link.",
            "description": "Here is the Google Meet link."
          },
          "visibility": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The event is open.",
            "description": "The event is open."
          }
        },
        "title": "Google Calendar Event Information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IOrganizer": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event organizer profile id.",
            "description": "Event organizer profile id."
          },
          "displayName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The name of the event organizer.",
            "description": "The name of the event organizer."
          },
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "This is the event organizer's email.",
            "description": "This is the event organizer's email."
          },
          "self": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the event copy corresponds to the calendar on which it is displayed.",
            "description": "Whether the event copy corresponds to the calendar on which it is displayed."
          }
        },
        "title": "Host Information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.ICreator": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event Creator Profile Id.",
            "description": "The event creator profile id."
          },
          "displayName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The event creator name.",
            "description": "The event creator name."
          },
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The event creator email.",
            "description": "The event creator email."
          },
          "self": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the event copy corresponds to the calendar on which it is displayed.",
            "description": "Whether the event copy corresponds to the calendar on which it is displayed."
          }
        },
        "title": "Event creator information.",
        "description": "Event creator information."
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IReminders": {
        "type": "object",
        "properties": {
          "useDefault": {
            "type": "boolean",
            "title": "Whether to default notification.",
            "description": "Whether to default notification."
          },
          "overrides": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleCalendar.IGoogleCalendarEvent.IRemindersOverrides"
            },
            "title": "Notification settings information.",
            "description": "Here is the notification settings information."
          }
        },
        "title": "Notification information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IRemindersOverrides": {
        "type": "object",
        "properties": {
          "method": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Notification method.",
            "description": "This is the notification method."
          },
          "minutes": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "It's time to send notifications.",
            "description": "It's time to send notifications."
          }
        },
        "title": "Notification settings information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IAttendees": {
        "type": "object",
        "properties": {
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Event attendee email.",
            "description": "This is the event attendee email."
          },
          "organizer": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the event attendee is the host.",
            "description": "Whether the event attendee is the host."
          },
          "self": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Whether the calendar that the schedule copy is displayed on is indicated.",
            "description": "Whether the calendar that the schedule copy is displayed on is indicated."
          },
          "responseStatus": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attendee's attendance response status.",
            "description": "Attendee's attendance response status."
          }
        },
        "title": "Attendee Information"
      },
      "IGoogleCalendar.IGoogleCalendarEvent.IAttachments": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "file url.",
            "description": "This is the event attachment file url."
          },
          "title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "File title.",
            "description": "This is the title of the attached file."
          },
          "mimeType": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Internet Media Type.",
            "description": "Internet Media Type."
          },
          "iconLink": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "File icon link.",
            "description": "Attachment file icon link."
          },
          "fileId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "file id.",
            "description": "This is the id of the attached file."
          }
        },
        "title": "Attachment file information"
      },
      "IGoogleCalendar.IReadGoogleCalendarEventInput": {
        "type": "object",
        "properties": {
          "time_max": {
            "type": "object",
            "properties": {
              "year": {
                "type": "number",
                "title": "The year.",
                "description": "It's the year."
              },
              "month": {
                "type": "number",
                "title": "The Month.",
                "description": "It's the month.\n\nYou must enter a two-digit number. For example, if it is March, you should enter 03."
              },
              "date": {
                "type": "number",
                "title": "Date.",
                "description": "It's the date.\n\nYou must enter a two-digit number. For example, if it is 7th, you should enter 07."
              },
              "hour": {
                "type": "number",
                "title": "hour.",
                "description": "It's the hour.\n\nYou must enter a two-digit number. For example, if it is 2am, you should enter 02. If it is 2pm, you should enter 14."
              }
            },
            "required": [
              "year",
              "month",
              "date",
              "hour"
            ],
            "title": "Information about the last date from which events will be fetched.",
            "description": "Events after that date will not be fetched.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "time_min": {
            "type": "object",
            "properties": {
              "year": {
                "type": "number",
                "title": "The year.",
                "description": "It's the year."
              },
              "month": {
                "type": "number",
                "title": "The Month.",
                "description": "It's the month.\n\nYou must enter a two-digit number. For example, if it is March, you should enter 03."
              },
              "date": {
                "type": "number",
                "title": "Date.",
                "description": "It's the date.\n\nYou must enter a two-digit number. For example, if it is 7th, you should enter 07."
              },
              "hour": {
                "type": "number",
                "title": "hour.",
                "description": "It's the hour.\n\nYou must enter a two-digit number. For example, if it is 2am, you should enter 02. If it is 2pm, you should enter 14."
              }
            },
            "required": [
              "year",
              "month",
              "date",
              "hour"
            ],
            "title": "Information on the start date from which events will be retrieved.",
            "description": "Events prior to that date will not be retrieved.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "max_results": {
            "type": "integer",
            "title": "How many results to return.",
            "description": "Sets the maximum number of events to retrieve."
          },
          "orderBy": {
            "oneOf": [
              {
                "const": "startTime",
                "title": "시작 시간"
              },
              {
                "const": "updated",
                "title": "업데이트 날짜"
              }
            ],
            "title": "The order in which the events will be received.",
            "description": "The order in which the calendar events are sorted.\n\n- startTime: The start time of the event.\n- updated: The date the event was updated.\n\nOnly two possible values are possible: \"startTime\" and \"updated\"."
          },
          "query": {
            "type": "string",
            "title": "Event search terms.",
            "description": "You can search for events that contain your search terms.\n\nYou can search for events that contain your search terms in the title, description, location, attendees, etc."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "time_max",
          "time_min",
          "secretKey"
        ],
        "title": "Information needed to search for events"
      },
      "IGoogleCalendar.ICreateQuickEventInput": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "This is the text for creating a quick calendar event.",
            "description": "This is the text for creating a quick calendar event."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "text",
          "secretKey"
        ],
        "title": "Information needed to create a quick event"
      },
      "IGoogleCalendar.IEventRequestBodyInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Event title.",
            "description": "The title of the event to be generated."
          },
          "description": {
            "type": "string",
            "title": "Event description.",
            "description": "Description of the event to be generated."
          },
          "location": {
            "type": "string",
            "title": "Event Location.",
            "description": "This is the event location to be created."
          },
          "start": {
            "type": "object",
            "properties": {
              "year": {
                "type": "number",
                "title": "The year.",
                "description": "It's the year."
              },
              "month": {
                "type": "number",
                "title": "The Month.",
                "description": "It's the month.\n\nYou must enter a two-digit number. For example, if it is March, you should enter 03."
              },
              "date": {
                "type": "number",
                "title": "Date.",
                "description": "It's the date.\n\nYou must enter a two-digit number. For example, if it is 7th, you should enter 07."
              },
              "hour": {
                "type": "number",
                "title": "hour.",
                "description": "It's the hour.\n\nYou must enter a two-digit number. For example, if it is 2am, you should enter 02. If it is 2pm, you should enter 14."
              }
            },
            "required": [
              "year",
              "month",
              "date",
              "hour"
            ],
            "title": "Event start date.",
            "description": "The start date of the event to be created.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "end": {
            "type": "object",
            "properties": {
              "year": {
                "type": "number",
                "title": "The year.",
                "description": "It's the year."
              },
              "month": {
                "type": "number",
                "title": "The Month.",
                "description": "It's the month.\n\nYou must enter a two-digit number. For example, if it is March, you should enter 03."
              },
              "date": {
                "type": "number",
                "title": "Date.",
                "description": "It's the date.\n\nYou must enter a two-digit number. For example, if it is 7th, you should enter 07."
              },
              "hour": {
                "type": "number",
                "title": "hour.",
                "description": "It's the hour.\n\nYou must enter a two-digit number. For example, if it is 2am, you should enter 02. If it is 2pm, you should enter 14."
              }
            },
            "required": [
              "year",
              "month",
              "date",
              "hour"
            ],
            "title": "Event end date.",
            "description": "The end date of the event to be created.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "attendeesEmail": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Attendee Email.",
            "description": "This is the event attendee email."
          },
          "repeatFrequency": {
            "oneOf": [
              {
                "const": "DAILY"
              },
              {
                "const": "WEEKLY"
              },
              {
                "const": "MONTHLY"
              },
              {
                "const": "YEARLY"
              }
            ],
            "title": "The event repeat cycle.",
            "description": "The event repeat cycle.\n\n- DAILY: Daily\n- WEEKLY: Weekly\n- MONTHLY: Monthly\n- YEARLY: Yearly\n\nOnly 4 possible values are possible: \"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\"."
          },
          "repeatNum": {
            "type": "number",
            "title": "The number of times the event is repeated.",
            "description": "The number of times the event is repeated."
          },
          "repeatUntil": {
            "type": "object",
            "properties": {
              "year": {
                "type": "number",
                "title": "The year.",
                "description": "It's the year."
              },
              "month": {
                "type": "number",
                "title": "The Month.",
                "description": "It's the month.\n\nYou must enter a two-digit number. For example, if it is March, you should enter 03."
              },
              "date": {
                "type": "number",
                "title": "Date.",
                "description": "It's the date.\n\nYou must enter a two-digit number. For example, if it is 7th, you should enter 07."
              },
              "hour": {
                "type": "number",
                "title": "hour.",
                "description": "It's the hour.\n\nYou must enter a two-digit number. For example, if it is 2am, you should enter 02. If it is 2pm, you should enter 14."
              }
            },
            "required": [
              "year",
              "month",
              "date",
              "hour"
            ],
            "title": "Event repeat deadline.",
            "description": "Event repeat deadline.\n\nNote that all date/times are in UTC, so make sure that you have converted the date/time to UTC before using it."
          },
          "isBusy": {
            "type": "boolean",
            "title": "Whether the event is busy or not.",
            "description": "Whether the event is busy or not."
          },
          "isUseDefaultReminder": {
            "type": "boolean",
            "title": "Whether to use the default calendar notifications.",
            "description": "Whether to use the default calendar notifications."
          },
          "remindersType": {
            "oneOf": [
              {
                "const": "email"
              },
              {
                "const": "popup"
              }
            ],
            "title": "Event notification type.",
            "description": "Event notification type.\n\n- popup: Popup notification\n- email: Email notification\n\nOnly two possible values are possible: \"popup\" and \"email\"."
          },
          "minutesBeforeReminders": {
            "type": "number",
            "title": "It's time to set a notification before the schedule starts.",
            "description": "It's time to set a notification before the schedule starts."
          },
          "isConferencing": {
            "type": "boolean",
            "title": "Whether to create a Google Meet.",
            "description": "Whether to create a Google Meet."
          },
          "visibility": {
            "oneOf": [
              {
                "const": "default"
              },
              {
                "const": "public"
              },
              {
                "const": "private"
              }
            ],
            "title": "The event's public status.",
            "description": "The event's public status.\n\ndefault - The default public status\npublic - The event is public and the event details are visible to all readers of the calendar\nprivate - The event is private and only the event attendees can see the event details\n\nThere are only three possible values: \"default\", \"public\", \"private\"."
          },
          "colorId": {
            "type": "string",
            "title": "Event Color.",
            "description": "Event Color."
          },
          "isGuestCanModify": {
            "type": "boolean",
            "title": "Whether guest events can be modified.",
            "description": "Whether guest events can be modified."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "start",
          "end",
          "secretKey"
        ],
        "title": "Information required to create an event"
      },
      "IGoogleCalendar.IAddAttendeesToEventInput": {
        "type": "object",
        "properties": {
          "attendeesEmail": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "The email address of the attendee you wish to add.",
            "description": "The email address of the attendee you wish to add."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "attendeesEmail",
          "secretKey"
        ],
        "title": "Information required to add attendees"
      },
      "IGoogleDrive.IFolderListGoogleDriveOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google drive folder id.",
                  "description": "Google drive folder id."
                },
                "name": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google drive folder name.",
                  "description": "Google drive folder name."
                }
              }
            },
            "title": "Google Drive Folder Data.",
            "description": "List of folder data in Google Drive."
          }
        },
        "required": [
          "data"
        ],
        "title": "Folder list information in Google Drive"
      },
      "IGoogleDrive.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Authentication Information"
      },
      "IGoogleDrive.IFileListGoogleDriveOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google drive file id.",
                  "description": "Google drive file id."
                },
                "name": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "title": "Google drive file name.",
                  "description": "The name of the Google drive file."
                },
                "webContentLink": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string",
                      "format": "iri"
                    }
                  ],
                  "title": "webContentLink"
                }
              }
            },
            "title": "Google Drive File Data.",
            "description": "List of file data in Google Drive."
          }
        },
        "required": [
          "data"
        ],
        "title": "File list information in Google Drive"
      },
      "IGoogleDrive.IFileListGoogleDriveInput": {
        "type": "object",
        "properties": {
          "folderId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-drive/get/folders",
              "jmesPath": "data[].{value:id, label:name}"
            },
            "title": "Google Drive Folder.",
            "description": "Folder to load files from."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Information for loading a list of files in Google Drive"
      },
      "IGoogleDrive.ICreateFolderGoogleDriveOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated drive id.",
            "description": "Generated drive folder id."
          }
        },
        "required": [
          "id"
        ],
        "title": "Google Drive Folder Creation Results"
      },
      "IGoogleDrive.ICreateFolderGoogleDriveInput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Google drive folder name.",
            "description": "Drive folder name to be created."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "secretKey"
        ],
        "title": "Information required to create a Google Drive folder"
      },
      "IGoogleDrive.ICreateFileGoogleDriveOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated drive file id.",
            "description": "Generated drive file id."
          }
        },
        "required": [
          "id"
        ],
        "title": "Result of creating a file in Google Drive"
      },
      "IGoogleDrive.IUploadFileInput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Google drive file name.",
            "description": "File name to be created in drive."
          },
          "folderIds": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/google-drive/get/folders",
                "jmesPath": "data[].{value:id, label:name}"
              }
            },
            "minItems": 1,
            "title": "Google drive folder ids.",
            "description": "A list of folder ids that will contain the files to be created in the drive."
          },
          "fileUrl": {
            "type": "string",
            "format": "iri",
            "title": "fileToUpload"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "folderIds",
          "fileUrl",
          "secretKey"
        ],
        "title": "Information required to create a file in Google Drive"
      },
      "IGoogleDrive.IPermissionGoogleDriveInput": {
        "type": "object",
        "properties": {
          "fileId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-drive/get/files",
              "jmesPath": "data[].{value:id, label:name}"
            },
            "title": "Google drive file id.",
            "description": "The drive file id to grant access to."
          },
          "folderId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-drive/get/folders",
              "jmesPath": "data[].{value:id, label:name}"
            },
            "title": "Google drive folder id.",
            "description": "Drive folder id to grant access to."
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleDrive.IPermission"
            },
            "title": "Here is a list of emails to make accessible and permissions to grant.",
            "description": "Here is a list of emails to make accessible and permissions to grant."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "permissions",
          "secretKey"
        ],
        "title": "Information required for Google Drive access permission"
      },
      "IGoogleDrive.IPermission": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "The email address of the user to whom you wish to grant access.",
            "description": "The email address of the user to whom you wish to grant access to Google Drive.\nRequired only when the type is a user type."
          },
          "role": {
            "oneOf": [
              {
                "const": "owner"
              },
              {
                "const": "writer"
              },
              {
                "const": "commenter"
              },
              {
                "const": "reader"
              },
              {
                "const": "organizer"
              },
              {
                "const": "fileOrganizer"
              }
            ],
            "title": "The permission to grant.",
            "description": "The type of permission to grant.\n\nowner: Grants owner permissions. Users with this permission can delete files or folders or grant permissions to other users.\norganizer: Grants operator permissions for the drive. Users with this permission can manage the organization of the drive.\nfileOrganizer: Grants operator permissions for files on the drive. Users with this permission can add or delete files.\nwriter: Grants write permissions. Users with this permission can modify or delete files.\ncommenter: Grants comment permissions. Users with this permission can read and comment on files.\nreader: Grants read permissions. Users with this permission can read files.\n\nThere are only six possible values: \"owner\", \"organizer\", \"fileOrganizer\", \"writer\", \"commenter\", \"reader\"."
          },
          "type": {
            "oneOf": [
              {
                "const": "user"
              },
              {
                "const": "group"
              },
              {
                "const": "domain"
              },
              {
                "const": "anyone"
              }
            ],
            "title": "The type of permission to grant.",
            "description": "The type of permission to grant.\n\nuser - a specific user, in this case you must specify the email address of the user to grant the permission to in the emailAddress field.\ngroup - a specific group, in this case you must specify the email address of the group to grant the permission to in the emailAddress field.\ndomain - a specific domain, in this case you must specify the domain to grant the permission to in the domain field.\nanyone - all users\n\nThere are only four possible values: \"user\", \"group\", \"domain\", \"anyone\"."
          }
        },
        "required": [
          "role",
          "type"
        ],
        "title": "Access Rights Information"
      },
      "IGoogleDrive.IGetFileOutput": {
        "type": "object",
        "properties": {
          "userPermission": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "id"
              },
              "type": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "group"
                  },
                  {
                    "const": "domain"
                  },
                  {
                    "const": "anyone"
                  }
                ],
                "title": "type"
              },
              "role": {
                "oneOf": [
                  {
                    "const": "owner"
                  },
                  {
                    "const": "writer"
                  },
                  {
                    "const": "commenter"
                  },
                  {
                    "const": "reader"
                  },
                  {
                    "const": "organizer"
                  },
                  {
                    "const": "fileOrganizer"
                  }
                ],
                "title": "role"
              },
              "pendingOwner": {
                "type": "boolean",
                "title": "pendingOwner"
              }
            },
            "required": [
              "id",
              "type",
              "role",
              "pendingOwner"
            ],
            "title": "userPermission"
          },
          "fileExtension": {
            "type": "string",
            "title": "fileExtension"
          },
          "ownerNames": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "ownerNames"
          },
          "lastModifyingUserName": {
            "type": "string",
            "title": "lastModifyingUserName"
          },
          "editable": {
            "type": "boolean",
            "title": "editable"
          },
          "writersCanShare": {
            "type": "boolean",
            "title": "writersCanShare"
          },
          "mimeType": {
            "type": "string",
            "title": "mimeType"
          },
          "parents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "title": "id: string;"
                },
                "isRoot": {
                  "type": "boolean",
                  "title": "isRoot"
                }
              },
              "required": [
                "id",
                "isRoot"
              ]
            },
            "title": "parents"
          },
          "thumbnailLink": {
            "type": "string",
            "format": "iri",
            "title": "thumbnailLink"
          },
          "appDataContents": {
            "type": "boolean",
            "title": "appDataContents"
          },
          "shared": {
            "type": "boolean",
            "title": "shared"
          },
          "lastModifyingUser": {
            "$ref": "#/components/schemas/IGoogleDrive.User",
            "title": "lastModifyingUser"
          },
          "owners": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleDrive.User"
            },
            "title": "owners"
          },
          "copyable": {
            "type": "boolean",
            "title": "copyable"
          },
          "alternateLink": {
            "type": "string",
            "format": "iri",
            "title": "alternateLink\nA link to view the file in Google Drive's preview mode."
          },
          "embedLink": {
            "type": "string",
            "format": "iri",
            "title": "embedLink\nA link to embed the file in a webpage via an iframe."
          },
          "webContentLink": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "webContentLink\nA link to directly access or download the file content."
          },
          "fileSize": {
            "type": "string",
            "title": "fileSize"
          },
          "copyRequiresWriterPermission": {
            "type": "boolean",
            "title": "copyRequiresWriterPermission"
          },
          "spaces": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "spaces"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "title": {
            "type": "string",
            "title": "title(filename)"
          },
          "labels": {
            "type": "object",
            "properties": {
              "viewed": {
                "type": "boolean",
                "title": "viewed"
              },
              "restricted": {
                "type": "boolean",
                "title": "restricted"
              },
              "starred": {
                "type": "boolean",
                "title": "starred"
              },
              "hidden": {
                "type": "boolean",
                "title": "hidden"
              },
              "trashed": {
                "type": "boolean",
                "title": "trashed"
              }
            },
            "required": [
              "viewed",
              "restricted",
              "starred",
              "hidden",
              "trashed"
            ],
            "title": "labels"
          },
          "explicitlyTrashed": {
            "type": "boolean",
            "title": "explicitlyTrashed"
          },
          "createdDate": {
            "type": "string",
            "format": "date-time",
            "title": "createdDate"
          },
          "modifiedDate": {
            "type": "string",
            "format": "date-time",
            "title": "modifiedDate"
          },
          "modifiedByMeDate": {
            "type": "string",
            "format": "date-time",
            "title": "modifiedByMeDate"
          },
          "lastViewedByMeDate": {
            "type": "string",
            "format": "date-time",
            "title": "lastViewedByMeDate"
          },
          "markedViewedByMeDate": {
            "type": "string",
            "format": "date-time",
            "title": "markedViewedByMeDate"
          },
          "quotaBytesUsed": {
            "type": "string",
            "title": "quotaBytesUsed"
          },
          "version": {
            "type": "string",
            "title": "version"
          },
          "originalFilename": {
            "type": "string",
            "title": "originalFilename"
          },
          "capabilities": {
            "type": "object",
            "properties": {
              "canEdit": {
                "type": "boolean",
                "title": "canEdit"
              },
              "canCopy": {
                "type": "boolean",
                "title": "canCopy"
              }
            },
            "required": [
              "canEdit",
              "canCopy"
            ],
            "title": "capabilities"
          }
        },
        "required": [
          "userPermission",
          "ownerNames",
          "lastModifyingUserName",
          "editable",
          "writersCanShare",
          "mimeType",
          "parents",
          "appDataContents",
          "shared",
          "lastModifyingUser",
          "owners",
          "copyable",
          "alternateLink",
          "embedLink",
          "copyRequiresWriterPermission",
          "spaces",
          "id",
          "title",
          "labels",
          "explicitlyTrashed",
          "createdDate",
          "modifiedDate",
          "markedViewedByMeDate",
          "quotaBytesUsed",
          "version",
          "capabilities"
        ]
      },
      "IGoogleDrive.User": {
        "type": "object",
        "properties": {
          "displayName": {
            "type": "string",
            "title": "displayName"
          },
          "isAuthenticatedUser": {
            "type": "boolean",
            "title": "isAuthenticatedUser"
          },
          "permissionId": {
            "type": "string",
            "title": "permissionId"
          },
          "emailAddress": {
            "type": "string",
            "format": "email",
            "title": "emailAddress"
          },
          "picture": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url"
              }
            },
            "required": [
              "url"
            ],
            "title": "picture"
          }
        },
        "required": [
          "displayName",
          "isAuthenticatedUser",
          "permissionId",
          "emailAddress",
          "picture"
        ]
      },
      "ISelectorLlmResponse": {
        "type": "object",
        "properties": {
          "selection": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "title": "Selected candidate index information.",
            "description": "Here is a list of indexes for the selected candidates."
          }
        },
        "required": [
          "selection"
        ]
      },
      "ISelectorLlmRequest": {
        "type": "object",
        "properties": {
          "candidates": {
            "type": "array",
            "items": {},
            "title": "Choices.",
            "description": "Here is a list of candidates for selection."
          },
          "num_select": {
            "type": "number",
            "title": "Number of selections.",
            "description": "The number of candidates to select."
          },
          "context": {
            "title": "Considerations.",
            "description": "Here are some things to consider when choosing a candidate."
          }
        },
        "required": [
          "candidates",
          "num_select",
          "context"
        ]
      },
      "IGmail.ISendMailOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "The ID of the sent email.",
            "description": "The ID of the sent email."
          }
        },
        "required": [
          "id"
        ],
        "title": "Mail transmission result"
      },
      "IGmail.ICreateMailInput": {
        "type": "object",
        "properties": {
          "to": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Recipient's email address.",
            "description": "The email address of the recipient."
          },
          "subject": {
            "type": "string",
            "title": "Email subject.",
            "description": "Subject of the email to be sent."
          },
          "body": {
            "type": "string",
            "title": "Email body.</a>",
            "description": "The body of the email to be sent. It must be written in html. Otherwise, the body may not be displayed properly. Please apply the CSS format applicable to gmail. Please write the html length so that it is not too long. If it is too long, it may not be sent. If there is a link or url <a>, be sure to use the title attribute of the html tag to provide a link."
          },
          "cc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Email address of the person to be referenced.",
            "description": "Email address of the person to be referenced."
          },
          "Bcc": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Bcc email address.",
            "description": "Bcc email address."
          },
          "files": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "filename": {
                  "type": "string",
                  "title": "filename"
                },
                "fileUrl": {
                  "type": "string",
                  "format": "iri",
                  "title": "file uri"
                }
              },
              "required": [
                "filename",
                "fileUrl"
              ]
            },
            "title": "files"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "to",
          "subject",
          "body",
          "secretKey"
        ],
        "title": "Information required to send email"
      },
      "IGmail.IReplyInput": {
        "type": "object",
        "properties": {
          "replyText": {
            "type": "string",
            "title": "Phrase to reply.",
            "description": "Phrase to reply."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "replyText",
          "secretKey"
        ],
        "title": "Information required to reply to email"
      },
      "IGmail.IFindGmailOutput": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Email id.",
            "description": "Unique id of the email."
          },
          "labelIds": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "Email Label id.",
            "description": "Label id assigned to the email."
          },
          "from": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Sender Email.",
            "description": "The email address of the person who sent the email."
          },
          "subject": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Subject.",
            "description": "The subject of the email."
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Summary of the body.",
            "description": "Summary of the body of the email."
          },
          "attachments": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGmail.IAttachmentOutput"
                }
              }
            ],
            "title": "Attachments.",
            "description": "List of files attached to the email."
          }
        },
        "title": "Email search results"
      },
      "IGmail.IAttachmentOutput": {
        "type": "object",
        "properties": {
          "partId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The immutable ID of the message part.",
            "description": "The immutable ID of the message part."
          },
          "mimeType": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The MIME type of the message part.",
            "description": "The MIME type of the message."
          },
          "filename": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attachment name.",
            "description": "This message part will only be displayed if it indicates an attachment."
          },
          "headers": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGmail.IAttachmentHeader"
                }
              }
            ],
            "title": "Attachment header information.",
            "description": "The top-level message portion, which represents the entire message payload, contains standard RFC 2822 email headers such as To, From, and Subject."
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGmail.IAttachmentBody"
              }
            ],
            "title": "Attachment header body information.",
            "description": "The body of the message part of this section, which may be empty for container MIME message parts."
          }
        },
        "title": "Attachment file information"
      },
      "IGmail.IAttachmentHeader": {
        "type": "object",
        "properties": {
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attachment header type.",
            "description": "Attachment header type."
          },
          "value": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attachment header value.",
            "description": "Attachment header value."
          }
        },
        "title": "Attachment file header information"
      },
      "IGmail.IAttachmentBody": {
        "type": "object",
        "properties": {
          "attachmentId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Attachment file id.",
            "description": "The unique ID of the attached file."
          },
          "size": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "The number of bytes in the attachment data.",
            "description": "The number of bytes in the attachment data."
          }
        },
        "title": "Attached file body information"
      },
      "IGmail.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Authentication Information"
      },
      "IGmail.IFindGmailListOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGmail.IFindGmailOutput"
            },
            "title": "gmail search data information.",
            "description": "Searched gmail data information."
          }
        },
        "required": [
          "data"
        ],
        "title": "Email list search results"
      },
      "IGmail.IFindEmailListInput": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "title": "The email of the sender.",
            "description": "The email address of the sender of the email."
          },
          "to": {
            "type": "string",
            "title": "The email address of the recipient.",
            "description": "The email address of the recipient."
          },
          "subject": {
            "type": "string",
            "title": "Email Subject.",
            "description": "Email Subject."
          },
          "after": {
            "type": "string",
            "title": "After a specific date.",
            "description": "Returns only emails after a given date."
          },
          "before": {
            "type": "string",
            "title": "Before a specific date.",
            "description": "Returns only emails before a given date."
          },
          "label": {
            "type": "string",
            "title": "Label assigned to the email.",
            "description": "Label assigned to the email."
          },
          "maxResults": {
            "type": "number",
            "maximum": 500,
            "minimum": 1,
            "title": "Maximum number of returned mails.",
            "description": "Number of returned mails."
          },
          "labelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "A list of labels to filter by.",
            "description": "A list of labels to return only emails with labels that all match the specified label ID."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Information needed to search email lists"
      },
      "IGmail.ILabelOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Generated label id.",
            "description": "The id of the generated label."
          }
        },
        "required": [
          "id"
        ],
        "title": "Label Creation Result"
      },
      "IGmail.ILabelInput": {
        "type": "object",
        "properties": {
          "labelName": {
            "type": "string",
            "title": "Label name.",
            "description": "The name of the label to create."
          },
          "labelListVisibility": {
            "oneOf": [
              {
                "const": "labelHide"
              },
              {
                "const": "labelShow"
              },
              {
                "const": "labelShowIfUnread"
              }
            ],
            "title": "Visibility status of the label.",
            "description": "Visibility status of the label to be created.\n\nHidden / Visible / Visible when unread\n\n- labelHide: Hidden\n- labelShow: Visible\n- labelShowIfUnread: Visible when unread\n\nOnly three possible values are available: labelHide, labelShow, and labelShowIfUnread."
          },
          "messageListVisibility": {
            "oneOf": [
              {
                "const": "hide"
              },
              {
                "const": "show"
              }
            ],
            "title": "The visibility status of the labeled mail.",
            "description": "The visibility status of the generated labeled mail.\n\nHidden / Visible\n\n- hide: hidden\n- show: visible\n\nThere are only two possible values: hide and show."
          },
          "color": {
            "$ref": "#/components/schemas/IGmail.ILabelColor",
            "title": "Label Color.",
            "description": "Color of the mail label to be generated"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "labelName",
          "secretKey"
        ],
        "title": "Information required to create a label"
      },
      "IGmail.ILabelColor": {
        "type": "object",
        "properties": {
          "textColor": {
            "type": "string",
            "title": "Label text color.",
            "description": "Label text color."
          },
          "backgroundColor": {
            "type": "string",
            "title": "Label background color.",
            "description": "Label background color."
          }
        },
        "required": [
          "textColor",
          "backgroundColor"
        ],
        "title": "label color"
      },
      "IGmail.IMailLabelOperationInput": {
        "type": "object",
        "properties": {
          "labelIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "A list of labels.",
            "description": "A list of labels to assign or remove."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://mail.google.com/"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "labelIds",
          "secretKey"
        ],
        "title": "Information required to assign a label"
      },
      "ITool.IGenerateOutput": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string"
          }
        },
        "required": [
          "content"
        ],
        "description": "Here are the results of using the tool."
      },
      "ITool.IGenerateInput": {
        "type": "object",
        "properties": {},
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        }
      },
      "IChatbot.IChatbotGenerateOutput": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "title": "Chatbot response",
            "description": "Here is the chatbot response result."
          }
        },
        "required": [
          "content"
        ],
        "title": "Chatbot response"
      },
      "IChatbot.IChatbotEasyGenerateInput": {
        "type": "object",
        "properties": {
          "difficulty": {
            "const": "easy",
            "title": "Difficulty",
            "description": "This is the difficulty level at which the chatbot was created."
          },
          "role": {
            "type": "string",
            "title": "Role",
            "description": "The role of the chatbot."
          },
          "personality": {
            "type": "string",
            "title": "Personality",
            "description": "The personality of the chatbot."
          },
          "requirement": {
            "type": "string",
            "title": "Requirements",
            "description": "Here are the requirements for the chatbot."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the chatbot."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Here is the description of the chatbot."
          },
          "message": {
            "type": "string",
            "title": "User's speech",
            "description": "This is a user's speech."
          },
          "histories": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IChatbot.IHistory"
            },
            "title": "Chat History",
            "description": "This is the chat history."
          }
        },
        "required": [
          "difficulty",
          "role",
          "personality",
          "requirement",
          "name",
          "description",
          "message"
        ],
        "title": "Easy Difficulty Information for using the chatbot"
      },
      "IChatbot.IHistory": {
        "type": "object",
        "properties": {
          "role": {
            "oneOf": [
              {
                "const": "user"
              },
              {
                "const": "assistant"
              }
            ],
            "title": "The role of the speaker",
            "description": "The role of the speaker."
          },
          "content": {
            "type": "string",
            "title": "The speech content",
            "description": "Here is the speech content."
          }
        },
        "required": [
          "role",
          "content"
        ],
        "title": "Chat History"
      },
      "IChatbot.IChatBotHardGenerateInput": {
        "type": "object",
        "properties": {
          "difficulty": {
            "const": "hard",
            "title": "Difficulty",
            "description": "This is the difficulty level at which the chatbot was created."
          },
          "prompt": {
            "type": "string",
            "title": "prompt",
            "description": "This is the prompt required when requesting an LLM."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the chatbot."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Here is the description of the chatbot."
          },
          "message": {
            "type": "string",
            "title": "User's speech",
            "description": "This is a user's speech."
          },
          "histories": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IChatbot.IHistory"
            },
            "title": "Chat History",
            "description": "This is the chat history."
          }
        },
        "required": [
          "difficulty",
          "prompt",
          "name",
          "description",
          "message"
        ],
        "title": "Information for using the chatbot in the difficult difficulty level"
      },
      "IFigma.IReadFileOutput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "The name of the file in the editor.",
            "description": "The name of the file in the editor."
          },
          "role": {
            "oneOf": [
              {
                "const": "owner"
              },
              {
                "const": "editor"
              },
              {
                "const": "viewer"
              }
            ],
            "title": "The role of the user performing the request.",
            "description": "The role of the user performing the API request related to the file."
          },
          "lastModified": {
            "type": "string",
            "format": "date-time",
            "title": "The time the file was last modified.",
            "description": "The UTC ISO 8601 time the file was last modified."
          },
          "editorType": {
            "oneOf": [
              {
                "const": "figma"
              },
              {
                "const": "figjam"
              }
            ],
            "title": "The type of editor associated with the file.",
            "description": "The type of editor associated with this file."
          },
          "thumbnailUrl": {
            "type": "string",
            "title": "Thumbnail Image.",
            "description": "A URL to the thumbnail image for the file."
          },
          "version": {
            "type": "string",
            "title": "The version number of the file.",
            "description": "The version number of the file. This number is incremented each time the file is modified and can be used to determine if the file has changed between requests."
          },
          "components": {
            "type": "object",
            "properties": {},
            "title": "Mapping between component ID and component metadata.",
            "description": "Mapping between component ID and component metadata.",
            "additionalProperties": {
              "$ref": "#/components/schemas/Component"
            }
          },
          "componentSets": {
            "type": "object",
            "properties": {},
            "title": "A mapping between a component set ID and component set metadata.",
            "description": "A mapping between a component set ID and component set metadata.",
            "additionalProperties": {
              "$ref": "#/components/schemas/ComponentSet"
            }
          },
          "schemaVersion": {
            "type": "number",
            "title": "The version of the file schema used by this file.",
            "description": "The version of the file schema used by this file."
          },
          "styles": {
            "type": "object",
            "properties": {},
            "title": "Mapping between style ID and style metadata.",
            "description": "Mapping between style ID and style metadata.",
            "additionalProperties": {
              "$ref": "#/components/schemas/Style"
            }
          },
          "mainFileKey": {
            "type": "string",
            "title": "The primary file key of this file.",
            "description": "The primary file key of this file. If present, this file is a component or a set of components."
          },
          "branches": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string",
                  "title": "This is the key of the branch",
                  "description": "This is the key of the branch."
                },
                "name": {
                  "type": "string",
                  "title": "The name of the branch",
                  "description": "The name of the branch."
                },
                "thumbnail_url": {
                  "type": "string",
                  "title": "A URL to the thumbnail image of the branch",
                  "description": "A URL to the thumbnail image of the branch."
                },
                "last_modified": {
                  "type": "string",
                  "title": "The UTC ISO 8601 time when the branch was last modified",
                  "description": "The UTC ISO 8601 time when the branch was last modified."
                }
              },
              "required": [
                "key",
                "name",
                "thumbnail_url",
                "last_modified"
              ]
            },
            "title": "This is a list of branches for this file",
            "description": "This is a list of branches for this file."
          }
        },
        "required": [
          "name",
          "role",
          "lastModified",
          "editorType",
          "version",
          "components",
          "componentSets",
          "schemaVersion",
          "styles"
        ],
        "description": "DTO corresponding to the information in the read Figma file."
      },
      "Component": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The key of the component"
          },
          "name": {
            "type": "string",
            "description": "Name of the component"
          },
          "description": {
            "type": "string",
            "description": "The description of the component as entered in the editor"
          },
          "componentSetId": {
            "type": "string",
            "description": "The ID of the component set if the component belongs to one"
          },
          "documentationLinks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentationLink"
            },
            "description": "An array of documentation links attached to this component"
          },
          "remote": {
            "type": "boolean",
            "description": "Whether this component is a remote component that doesn't live in this file"
          }
        },
        "required": [
          "key",
          "name",
          "description",
          "documentationLinks",
          "remote"
        ],
        "description": "A description of a main component. Helps you identify which component instances are attached to."
      },
      "DocumentationLink": {
        "type": "object",
        "properties": {
          "uri": {
            "type": "string",
            "title": "Should be a valid URI (e.g. https://www.figma.com)",
            "description": "Should be a valid URI (e.g. https://www.figma.com)."
          }
        },
        "required": [
          "uri"
        ],
        "description": "Represents a link to documentation for a component or component set."
      },
      "ComponentSet": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The key of the component set"
          },
          "name": {
            "type": "string",
            "description": "Name of the component set"
          },
          "description": {
            "type": "string",
            "description": "The description of the component set as entered in the editor"
          },
          "documentationLinks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentationLink"
            },
            "description": "An array of documentation links attached to this component set"
          },
          "remote": {
            "type": "boolean",
            "description": "Whether this component set is a remote component set that doesn't live in this file"
          }
        },
        "required": [
          "key",
          "name",
          "description"
        ],
        "description": "A description of a component set, which is a node containing a set of variants of a component."
      },
      "Style": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "The key of the style"
          },
          "name": {
            "type": "string",
            "description": "Name of the style"
          },
          "description": {
            "type": "string",
            "description": "Description of the style"
          },
          "remote": {
            "type": "boolean",
            "description": "Whether this style is a remote style that doesn't live in this file"
          },
          "styleType": {
            "oneOf": [
              {
                "const": "FILL"
              },
              {
                "const": "TEXT"
              },
              {
                "const": "EFFECT"
              },
              {
                "const": "GRID"
              }
            ]
          }
        },
        "required": [
          "key",
          "name",
          "description",
          "remote",
          "styleType"
        ],
        "description": "A set of properties that can be applied to nodes and published. Styles for a property can be\ncreated in the corresponding property's panel while editing a file."
      },
      "IFigma.IReadFileInput": {
        "type": "object",
        "properties": {
          "fileKey": {
            "type": "string",
            "title": "A unique key value for each Figma file or component.",
            "description": "It means the key of the file.\n\nHere, the file key means the Figma frame."
          },
          "version": {
            "type": "string",
            "title": "The specific version ID to retrieve.",
            "description": "The specific version ID to retrieve. If omitted, the current version of the file is retrieved."
          },
          "ids": {
            "type": "string",
            "title": "A comma-separated list of nodes of interest in the document.",
            "description": "A comma-separated list of nodes of interest in the document. If specified, only the node, its children, and all subsets between the root node and the listed nodes will be returned.\n\nNote: Other nodes outside the ancestor chain of the desired node may be included in the returned JSON. The response may also include dependencies of things in the node's subtree. For example, if the node's subtree contains instances of local components located elsewhere in the file, those components and their ancestor chains will also be included.\n\nFor historical reasons, the top-level canvas node is always returned, regardless of whether it is listed in the `ids` parameter. This quirk may be removed in a future API version."
          },
          "depth": {
            "type": "integer",
            "title": "A positive integer indicating how deep to traverse the document tree.",
            "description": "A positive integer indicating how deep to traverse the document tree. For example, setting this to 1 will return only pages, while setting it to 2 will return the pages and all top-level objects for each page. If this parameter is not set, all nodes will be returned."
          },
          "geometry": {
            "type": "string",
            "title": "Vector data to export.",
            "description": "Set to \"paths\" when exporting vector data."
          },
          "plugin_data": {
            "type": "string",
            "title": "A comma-separated list of plugin IDs and/or the string \"shared\".",
            "description": "A comma-separated list of plugin IDs and/or the string \"shared\". All data in the document created by that plugin will be included in the `pluginData` and `sharedPluginData` properties of the result."
          },
          "branch_data": {
            "type": "boolean",
            "default": false,
            "title": "Indicates whether to return branch metadata for the requested file.",
            "description": "Returns branch metadata for the requested file. If the file is a branch, the returned response also includes the main file key. If the file has a branch, its metadata is also returned. Default: false."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "figma",
            "x-wrtn-secret-scopes": [
              "files:read",
              "file_variables:read",
              "file_variables:write",
              "file_comments:write",
              "file_dev_resources:read",
              "file_dev_resources:write",
              "library_analytics:read",
              "webhooks:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "fileKey",
          "secretKey"
        ],
        "description": "A DTO that retrieves files from a specific Figma frame.\n\nYou can read files from one frame at a time."
      },
      "Comment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Unique identifier for comment",
            "description": "Unique identifier for comment."
          },
          "client_meta": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/Vector"
              },
              {
                "$ref": "#/components/schemas/FrameOffset"
              },
              {
                "$ref": "#/components/schemas/Region"
              },
              {
                "$ref": "#/components/schemas/FrameOffsetRegion"
              }
            ],
            "description": "Positioning information of the comment. Includes information on the location of the comment pin,\nwhich is either the absolute coordinates on the canvas or a relative offset within a frame. If\nthe comment is a region, it will also contain the region height, width, and position of the\nanchor in regards to the region."
          },
          "file_key": {
            "type": "string",
            "description": "The file in which the comment lives"
          },
          "parent_id": {
            "type": "string",
            "description": "If present, the id of the comment to which this is the reply"
          },
          "user": {
            "$ref": "#/components/schemas/User",
            "description": "The user who left the comment"
          },
          "created_at": {
            "type": "string",
            "description": "The UTC ISO 8601 time at which the comment was left"
          },
          "resolved_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "description": "If set, the UTC ISO 8601 time the comment was resolved"
          },
          "message": {
            "type": "string",
            "description": "The content of the comment"
          },
          "order_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "description": "Only set for top level comments. The number displayed with the comment in the UI"
          },
          "reactions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Reaction"
            },
            "description": "An array of reactions to the comment"
          }
        },
        "required": [
          "id",
          "client_meta",
          "file_key",
          "user",
          "created_at",
          "message",
          "order_id",
          "reactions"
        ],
        "description": "A comment or reply left by a user."
      },
      "Vector": {
        "type": "object",
        "properties": {
          "x": {
            "type": "number",
            "title": "X coordinate of the vector",
            "description": "X coordinate of the vector."
          },
          "y": {
            "type": "number",
            "title": "Y coordinate of the vector",
            "description": "Y coordinate of the vector."
          }
        },
        "required": [
          "x",
          "y"
        ],
        "description": "A 2d vector."
      },
      "FrameOffset": {
        "type": "object",
        "properties": {
          "node_id": {
            "type": "string",
            "title": "Unique id specifying the frame",
            "description": "Unique id specifying the frame."
          },
          "node_offset": {
            "$ref": "#/components/schemas/Vector",
            "title": "2D vector offset within the frame from the top-left corner",
            "description": "2D vector offset within the frame from the top-left corner."
          }
        },
        "required": [
          "node_id",
          "node_offset"
        ],
        "description": "Position of a comment relative to the frame to which it is attached."
      },
      "Region": {
        "type": "object",
        "properties": {
          "x": {
            "type": "number",
            "title": "X coordinate of the position",
            "description": "X coordinate of the position."
          },
          "y": {
            "type": "number",
            "title": "Y coordinate of the position",
            "description": "Y coordinate of the position."
          },
          "region_height": {
            "type": "number",
            "title": "The height of the comment region. Must be greater than 0",
            "description": "The height of the comment region. Must be greater than 0."
          },
          "region_width": {
            "type": "number",
            "title": "The width of the comment region. Must be greater than 0",
            "description": "The width of the comment region. Must be greater than 0."
          },
          "comment_pin_corner": {
            "oneOf": [
              {
                "const": "top-left"
              },
              {
                "const": "top-right"
              },
              {
                "const": "bottom-left"
              },
              {
                "const": "bottom-right"
              }
            ],
            "title": "The corner of the comment region to pin to the node's corner as a string enum",
            "description": "The corner of the comment region to pin to the node's corner as a string enum."
          }
        },
        "required": [
          "x",
          "y",
          "region_height",
          "region_width"
        ],
        "description": "Position of a region comment on the canvas."
      },
      "FrameOffsetRegion": {
        "type": "object",
        "properties": {
          "node_id": {
            "type": "string",
            "title": "Unique id specifying the frame",
            "description": "Unique id specifying the frame."
          },
          "node_offset": {
            "$ref": "#/components/schemas/Vector",
            "title": "2D vector offset within the frame from the top-left corner",
            "description": "2D vector offset within the frame from the top-left corner."
          },
          "region_height": {
            "type": "number",
            "title": "The height of the comment region. Must be greater than 0",
            "description": "The height of the comment region. Must be greater than 0."
          },
          "region_width": {
            "type": "number",
            "title": "The width of the comment region. Must be greater than 0",
            "description": "The width of the comment region. Must be greater than 0."
          },
          "comment_pin_corner": {
            "oneOf": [
              {
                "const": "top-left"
              },
              {
                "const": "top-right"
              },
              {
                "const": "bottom-left"
              },
              {
                "const": "bottom-right"
              }
            ],
            "title": "The corner of the comment region to pin to the node's corner as a string enum",
            "description": "The corner of the comment region to pin to the node's corner as a string enum."
          }
        },
        "required": [
          "node_id",
          "node_offset",
          "region_height",
          "region_width"
        ],
        "description": "Position of a region comment relative to the frame to which it is attached."
      },
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Unique stable id of the user",
            "description": "Unique stable id of the user."
          },
          "handle": {
            "type": "string",
            "title": "Name of the user",
            "description": "Name of the user."
          },
          "img_url": {
            "type": "string",
            "title": "URL link to the user's profile image",
            "description": "URL link to the user's profile image."
          }
        },
        "required": [
          "id",
          "handle",
          "img_url"
        ],
        "description": "A description of a user."
      },
      "Reaction": {
        "type": "object",
        "properties": {
          "user": {
            "$ref": "#/components/schemas/User",
            "title": "The user who left the reaction",
            "description": "The user who left the reaction."
          },
          "emoji": {
            "type": "string"
          },
          "created_at": {
            "type": "string",
            "title": "The UTC ISO 8601 time at which the reaction was left",
            "description": "The UTC ISO 8601 time at which the reaction was left."
          }
        },
        "required": [
          "user",
          "emoji",
          "created_at"
        ],
        "description": "A reaction left by a user."
      },
      "IFigma.IAddCommentInput": {
        "type": "object",
        "properties": {
          "fileKey": {
            "type": "string",
            "title": "A unique key value for each Figma file or component.",
            "description": "It means the key of the file."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "figma",
            "x-wrtn-secret-scopes": [
              "files:read",
              "file_variables:read",
              "file_variables:write",
              "file_comments:write",
              "file_dev_resources:read",
              "file_dev_resources:write",
              "library_analytics:read",
              "webhooks:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "message": {
            "type": "string",
            "title": "The text contents of the comment to post",
            "description": "The text contents of the comment to post."
          },
          "comment_id": {
            "type": "string",
            "description": "The ID of the comment to reply to, if any. This must be a root comment. You cannot reply to other\nreplies (a comment that has a parent_id)."
          },
          "client_meta": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/Vector"
              },
              {
                "$ref": "#/components/schemas/FrameOffset"
              },
              {
                "$ref": "#/components/schemas/Region"
              },
              {
                "$ref": "#/components/schemas/FrameOffsetRegion"
              }
            ],
            "title": "The position where to place the comment",
            "description": "The position where to place the comment."
          }
        },
        "required": [
          "fileKey",
          "secretKey",
          "message"
        ],
        "description": "DTO for adding comments to a specific area.\n\nYou can write one comment at a time, and you can write comments using coordinate values, nodes, or parent comments (root comments)."
      },
      "GetCommentsResponse": {
        "type": "object",
        "properties": {
          "comments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Comment"
            },
            "title": "An array of comments",
            "description": "An array of comments."
          }
        },
        "required": [
          "comments"
        ],
        "description": "Response from the GET /v1/files/{file_key}/comments endpoint."
      },
      "IFigma.IReadCommentInput": {
        "type": "object",
        "properties": {
          "fileKey": {
            "type": "string",
            "title": "A unique key value for each Figma file or component.",
            "description": "It means the key of the file."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "figma",
            "x-wrtn-secret-scopes": [
              "files:read",
              "file_variables:read",
              "file_variables:write",
              "file_comments:write",
              "file_dev_resources:read",
              "file_dev_resources:write",
              "library_analytics:read",
              "webhooks:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "as_md": {
            "type": "boolean",
            "title": "If enabled, will return comments as their markdown equivalents when applicable",
            "description": "If enabled, will return comments as their markdown equivalents when applicable."
          }
        },
        "required": [
          "fileKey",
          "secretKey"
        ],
        "description": "A DTO that retrieves comments from a specific Figma frame.\n\nYou can read comments from one frame at a time."
      },
      "IFigma.IGetProjectFileOutput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Project Name"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IFigma.Canvas"
            },
            "title": "Canvas List",
            "description": "A list of canvases managed by the project."
          }
        },
        "required": [
          "name",
          "files"
        ]
      },
      "IFigma.Canvas": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "title": "Canvas Key",
            "description": "A key that uniquely identifies a file.\nThe files mentioned here refer to the canvases managed in the project.\nIn Figma, all child component elements of a canvas, including the canvas, are called files, so be careful not to confuse the terminology."
          },
          "name": {
            "type": "string",
            "title": "Canvas name",
            "description": "It means the name given by the user to identify the file.\nThe file mentioned here refers to the canvases managed in the project.\nIn Figma, all child component elements of the canvas, including the canvas, are called files, so be careful not to confuse the terminology."
          },
          "thumbnail_url": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "image/*",
            "title": "Thumbnail",
            "description": "As a thumbnail image, it provides the main screen of this canvas as a screenshot.\nHowever, if you want to save this thumbnail as a link and use it, please note that this image is provided only for a certain period of time."
          },
          "last_modified": {
            "type": "string",
            "format": "date-time",
            "title": "Last modification time",
            "description": "This refers to the last modification time of the canvas.\nBased on this, you can distinguish the canvas that has been most recently changed or communicated, etc., and is maintained.\nHowever, this value cannot be known unless a comment has been added or there has been a change to the canvas."
          }
        },
        "required": [
          "key",
          "name",
          "thumbnail_url",
          "last_modified"
        ]
      },
      "IFigma.Secret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "figma",
            "x-wrtn-secret-scopes": [
              "files:read",
              "file_variables:read",
              "file_variables:write",
              "file_comments:write",
              "file_dev_resources:read",
              "file_dev_resources:write",
              "library_analytics:read",
              "webhooks:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IFigma.IGetStatisticsOutput": {
        "type": "object",
        "properties": {
          "canvasList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IFigma.CanvasStatistics"
            },
            "title": "Statistics by canvas within the project"
          },
          "name": {
            "type": "string",
            "title": "Project Name"
          },
          "id": {
            "type": "string",
            "title": "Project ID"
          }
        },
        "required": [
          "canvasList",
          "name",
          "id"
        ]
      },
      "IFigma.CanvasStatistics": {
        "type": "object",
        "properties": {
          "comments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Comment"
            },
            "title": "List of comments in canvas"
          },
          "statistics": {
            "type": "object",
            "properties": {
              "users": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "List of people who participated in the discussion"
              },
              "counts": {
                "$ref": "#/components/schemas/Recordstringnumber",
                "title": "Number of comments per person"
              }
            },
            "required": [
              "users",
              "counts"
            ],
            "title": "Statistics on comments in canvas"
          },
          "key": {
            "type": "string",
            "title": "Canvas Key",
            "description": "A key that uniquely identifies a file.\nThe files mentioned here refer to the canvases managed in the project.\nIn Figma, all child component elements of a canvas, including the canvas, are called files, so be careful not to confuse the terminology."
          },
          "name": {
            "type": "string",
            "title": "Canvas name",
            "description": "It means the name given by the user to identify the file.\nThe file mentioned here refers to the canvases managed in the project.\nIn Figma, all child component elements of the canvas, including the canvas, are called files, so be careful not to confuse the terminology."
          },
          "thumbnail_url": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "image/*",
            "title": "Thumbnail",
            "description": "As a thumbnail image, it provides the main screen of this canvas as a screenshot.\nHowever, if you want to save this thumbnail as a link and use it, please note that this image is provided only for a certain period of time."
          },
          "last_modified": {
            "type": "string",
            "format": "date-time",
            "title": "Last modification time",
            "description": "This refers to the last modification time of the canvas.\nBased on this, you can distinguish the canvas that has been most recently changed or communicated, etc., and is maintained.\nHowever, this value cannot be known unless a comment has been added or there has been a change to the canvas."
          }
        },
        "required": [
          "comments",
          "statistics",
          "key",
          "name",
          "thumbnail_url",
          "last_modified"
        ]
      },
      "Recordstringnumber": {
        "type": "object",
        "properties": {},
        "description": "Construct a type with a set of properties K of type T",
        "additionalProperties": {
          "type": "number"
        }
      },
      "IFigma.IGetProjectStatisticsInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "figma",
            "x-wrtn-secret-scopes": [
              "files:read",
              "file_variables:read",
              "file_variables:write",
              "file_comments:write",
              "file_dev_resources:read",
              "file_dev_resources:write",
              "library_analytics:read",
              "webhooks:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "as_md": {
            "type": "boolean",
            "title": "If enabled, will return comments as their markdown equivalents when applicable",
            "description": "If enabled, will return comments as their markdown equivalents when applicable."
          },
          "teamId": {
            "type": "string",
            "title": "Team ID\n\nWhen accessing the link `https://www.figma.com/files/team`, it refers to the string attached after the `team` keyword.\n\nThe team ID is in numeric format, and there can be multiple projects within the team."
          }
        },
        "required": [
          "secretKey",
          "teamId"
        ]
      },
      "IFigma.IGetProejctOutput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Team Name"
          },
          "projects": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IFigma.Project"
            },
            "title": "Project List\n\nThis refers to the list of projects belonging to the team."
          }
        },
        "required": [
          "name",
          "projects"
        ]
      },
      "IFigma.Project": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Project ID"
          },
          "name": {
            "type": "string",
            "title": "Project Name"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "IFigma.IGetProjectInput": {
        "type": "object",
        "properties": {
          "teamId": {
            "type": "string",
            "title": "Team ID\n\nWhen accessing the link `https://www.figma.com/files/team`, it refers to the string attached after the `team` keyword.\n\nThe team ID is in numeric format, and there can be multiple projects within the team."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "figma",
            "x-wrtn-secret-scopes": [
              "files:read",
              "file_variables:read",
              "file_variables:write",
              "file_comments:write",
              "file_dev_resources:read",
              "file_dev_resources:write",
              "library_analytics:read",
              "webhooks:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "teamId",
          "secretKey"
        ],
        "title": "Project search conditions"
      },
      "MyPartialIZoom.Meeting": {
        "type": "object",
        "properties": {
          "agenda": {
            "type": "string",
            "maxLength": 2000,
            "title": "The meeting's agenda.",
            "description": "The meeting's agenda."
          },
          "default_password": {
            "type": "boolean",
            "default": false,
            "title": "Whether to create a default password.",
            "description": "If this value is true and the user has enabled PMI settings with passwords, the user's meetings will use the PMI password."
          },
          "duration": {
            "type": "integer",
            "title": "The scheduled time (duration) of the meeting.",
            "description": "The scheduled time of the meeting, in minutes.\n\nUsed only when a meeting is scheduled."
          },
          "password": {
            "type": "string",
            "maxLength": 10,
            "title": "Meeting password.",
            "description": "It means a password consisting of English uppercase and lowercase letters and '@', '-', '_', '*'."
          },
          "pre_schedule": {
            "type": "boolean",
            "default": false,
            "title": "Whether to create a scheduled meeting via the `GSuite` app."
          },
          "assistant_id": {
            "type": "string",
            "title": "The ID of the user who hosted this meeting."
          },
          "host_email": {
            "type": "string",
            "format": "email",
            "title": "The email address of the meeting organizer."
          },
          "id": {
            "type": "integer",
            "title": "Meeting ID."
          },
          "registration_url": {
            "type": "string",
            "format": "url",
            "title": "URL where participants can register."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "The date and time this meeting was created."
          },
          "encrypted_password": {
            "type": "string",
            "title": "Encrypted password for 3rd party endpoints (H323/SIP)."
          },
          "pstn_password": {
            "type": "string",
            "title": "Password to join the meeting via PSTN."
          },
          "h323_password": {
            "type": "string",
            "title": "H.323/SIP room system password."
          },
          "join_url": {
            "type": "string",
            "format": "url",
            "title": "The URL where participants can join the meeting."
          },
          "chat_join_url": {
            "type": "string",
            "format": "url",
            "title": "URL where you can join the chat."
          },
          "occurrences": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IZoom.Occurrence"
            },
            "title": "Information about recurring webinars."
          },
          "pmi": {
            "type": "string",
            "title": "Personal meeting ID (PMI)."
          },
          "recurrence": {
            "$ref": "#/components/schemas/IZoom.Recurrence",
            "title": "Information about the meeting's recurrence cycle."
          },
          "settings": {
            "$ref": "#/components/schemas/MyPartialIZoom.Settings",
            "title": "Zoom settings information."
          },
          "start_time": {
            "type": "string",
            "format": "date-time",
            "title": "Meeting start time."
          },
          "start_url": {
            "type": "string",
            "format": "url",
            "title": "URL that allows you to join as the meeting host.",
            "description": "This URL should only be used by the meeting host and should not be shared with other participants.\n\nAnyone with this URL can log into the Zoom client with host privileges."
          },
          "timezone": {
            "type": "string",
            "title": "`start_time`의 timezone."
          },
          "topic": {
            "type": "string",
            "title": "Topic of the meeting"
          },
          "tracking_fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IZoom.TrackingField"
            }
          },
          "type": {
            "oneOf": [
              {
                "const": 1,
                "default": 2
              },
              {
                "const": 2,
                "default": 2
              },
              {
                "const": 3,
                "default": 2
              },
              {
                "const": 8,
                "default": 2
              },
              {
                "const": 10,
                "default": 2
              }
            ],
            "title": "Type of meeting.",
            "description": "- 1: Instant meeting.\n- 2: Scheduled meeting.\n- 3: Recurring meeting without fixed time.\n- 8: Recurring meeting with fixed time.\n- 10: Meeting with screen sharing only."
          },
          "dynamic_host_key": {
            "type": "string",
            "title": "미팅의 dynamic_host_key."
          }
        }
      },
      "IZoom.Occurrence": {
        "type": "object",
        "properties": {
          "duration": {
            "type": "integer",
            "title": "An integer representing the duration of the webinar."
          },
          "occurrence_id": {
            "type": "string",
            "title": "A unique identifier that identifies each webinar occurrence."
          },
          "start_time": {
            "type": "string",
            "format": "date-time",
            "title": "Webinar start time."
          },
          "status": {
            "oneOf": [
              {
                "const": "deleted"
              },
              {
                "const": "available"
              }
            ],
            "title": "Status of webinar occurrence",
            "description": "Status of webinar occurrence."
          }
        },
        "required": [
          "duration",
          "occurrence_id",
          "start_time",
          "status"
        ],
        "title": "Information about recurring webinars."
      },
      "IZoom.Recurrence": {
        "type": "object",
        "properties": {
          "end_date_time": {
            "type": "string",
            "format": "date-time",
            "title": "This means the last day before the meeting ends.",
            "description": "If the meeting is not cancelled, this means the last day of the meeting.\n\nCannot be used with `end_times`."
          },
          "end_times": {
            "type": "integer",
            "maximum": 60,
            "default": 1,
            "title": "The number of repetitions before the meeting is finally terminated.",
            "description": "Indicates how many times the meeting will repeat before it is canceled.\n\nIf end_times is set to 0, it means there is no end time."
          },
          "type": {
            "oneOf": [
              {
                "const": 1
              },
              {
                "const": 2
              },
              {
                "const": 3
              }
            ],
            "title": "Meeting repetition cycle.",
            "description": "1 is daily, 2 is weekly, 3 is monthly, indicating the repetition type."
          },
          "monthly_day": {
            "type": "integer",
            "minimum": 1,
            "maximum": 31,
            "title": "The days from 1 to 31 of the month.",
            "description": "It means the days from 1 to 31 of the month, and is the value set when `type` is 3, that is, it repeats every month."
          },
          "monthly_week": {
            "oneOf": [
              {
                "const": -1
              },
              {
                "const": 1
              },
              {
                "const": 2
              },
              {
                "const": 3
              },
              {
                "const": 4
              }
            ],
            "title": "Indicates which week of each month.",
            "description": "Indicates which week of each month.\n\nThis is the value set when `type` is 3, that is, the meeting is repeated every month.\n\n- -1: Last week of the month.\n- 1: First week of the month.\n- 2: Second week of the month.\n- 3: Third week of the month.\n- 4: Fourth week of the month."
          },
          "monthly_week_day": {
            "type": "string",
            "title": "Indicates which day of the week it is each month.",
            "description": "This is the value set when `type` is 3, that is, a meeting that repeats every month.\n\nIf multiple days are selected, the numbers are connected using the `,` symbol in the form of '1,3'.\n\n- 1 - Sunday.\n- 2 - Monday.\n- 3 - Tuesday.\n- 4 - Wednesday.\n- 5 - Thursday.\n- 6 - Friday.\n- 7 - Saturday."
          },
          "repeat_interval": {
            "type": "integer",
            "title": "Interval between meetings.",
            "description": "When `type` is 1, i.e., for meetings set to daily, up to 90 (days) is possible.\n\nWhen `type` is 2, i.e., for meetings set to weekly, up to 12 (weeks) is possible.\n\nWhen `type` is 3, i.e., for meetings set to monthly, up to 3 (months) is possible."
          },
          "weekly_days": {
            "type": "string",
            "title": "Indicates which day of the week it is.",
            "description": "This is the value set when `type` is 2, that is, a meeting that repeats every week.\n\nIf multiple days are selected, the numbers are connected using the `,` symbol in the form of '1,3'.\n\n- 1 - Sunday.\n- 2 - Monday.\n- 3 - Tuesday.\n- 4 - Wednesday.\n- 5 - Thursday.\n- 6 - Friday.\n- 7 - Saturday."
          }
        },
        "required": [
          "type",
          "monthly_day",
          "monthly_week",
          "monthly_week_day",
          "repeat_interval",
          "weekly_days"
        ],
        "title": "Information about the meeting's recurrence cycle."
      },
      "MyPartialIZoom.Settings": {
        "type": "object",
        "properties": {
          "allow_multiple_devices": {
            "type": "boolean",
            "title": "Whether participants can join from multiple devices.",
            "description": "Sets whether participants can join from multiple devices in a meeting where registration is enabled."
          },
          "alternative_hosts": {
            "type": "string",
            "title": "A semicolon-separated list of email addresses or IDs for alternate hosts."
          },
          "alternative_hosts_email_notification": {
            "type": "boolean",
            "default": true,
            "title": "Whether to send email notifications to alternate hosts."
          },
          "alternative_host_update_polls": {
            "type": "boolean"
          },
          "approval_type": {
            "oneOf": [
              {
                "const": 0,
                "default": 2
              },
              {
                "const": 1,
                "default": 2
              },
              {
                "const": 2,
                "default": 2
              }
            ],
            "title": "Meeting registration approval settings.",
            "description": "- 0 : Automatic approval\n- 1 : Manual approval\n- 2 : No registration required (default)"
          },
          "approved_or_denied_countries_or_regions": {
            "type": "object",
            "properties": {
              "approved_list": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "List of approved countries or regions."
              },
              "denied_list": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "List of blocked countries or regions."
              },
              "enable": {
                "type": "boolean",
                "title": "Whether to enable or disable user authorization or blocking settings for specific countries and regions."
              },
              "method": {
                "oneOf": [
                  {
                    "const": "deny"
                  },
                  {
                    "const": "approve"
                  }
                ],
                "title": "method."
              }
            },
            "required": [
              "enable"
            ],
            "title": "Approved/rejected country or region."
          },
          "audio": {
            "oneOf": [
              {
                "const": "both",
                "default": "both"
              },
              {
                "const": "telephony",
                "default": "both"
              },
              {
                "const": "voip",
                "default": "both"
              },
              {
                "const": "thirdParty",
                "default": "both"
              }
            ],
            "title": "How participants join the audio portion of the meeting.",
            "description": "- `both` - Both telephony and VoIP.\n- `telephony` - Telephony only.\n- `voip` - VoIP only.\n- `thirdParty` - Third party audio conference."
          },
          "audio_conference_info": {
            "type": "string",
            "maxLength": 2048,
            "title": "Third party audio conference info."
          },
          "authentication_domains": {
            "type": "string",
            "title": "The meeting's authenticated domains",
            "description": "The meeting's authenticated domains.\n\nOnly Zoom users whose email address contains an authenticated domain can join the meeting.\n\nComma-separate multiple domains or use a wildcard for listing domains."
          },
          "authentication_exception": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "email": {
                  "type": "string",
                  "format": "email",
                  "title": "The participant's email address."
                },
                "name": {
                  "type": "string",
                  "title": "The participant's name."
                },
                "join_url": {
                  "type": "string",
                  "format": "url",
                  "title": "URL for participants to join the meeting."
                }
              },
              "required": [
                "email",
                "name",
                "join_url"
              ]
            },
            "title": "A list of participants that can bypass meeting authentication",
            "description": "A list of participants that can bypass meeting authentication.\n\nThese participants will receive a unique meeting invite."
          },
          "authentication_name": {
            "type": "string",
            "title": "Authentication name set in the authentication profile."
          },
          "authentication_option": {
            "type": "string",
            "title": "Meeting authentication option ID."
          },
          "auto_recording": {
            "oneOf": [
              {
                "const": "none",
                "default": "none"
              },
              {
                "const": "cloud",
                "default": "none"
              }
            ],
            "title": "Automatic recording. local - Record on local.",
            "description": "- `cloud` - Record on cloud.\n- `none` - Disabled."
          },
          "breakout_room": {
            "type": "object",
            "properties": {
              "enable": {
                "type": "boolean",
                "title": "Set this field's value to true to enable the breakout room pre-assign option",
                "description": "Set this field's value to true to enable the breakout room pre-assign option."
              },
              "rooms": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "title": "The breakout room's name",
                      "description": "The breakout room's name."
                    },
                    "participants": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "format": "email"
                      },
                      "title": "Email addresses of the participants who are to be assigned to the breakout room",
                      "description": "Email addresses of the participants who are to be assigned to the breakout room."
                    }
                  },
                  "required": [
                    "name",
                    "participants"
                  ]
                },
                "title": "Create a room or rooms",
                "description": "Create a room or rooms."
              }
            },
            "required": [
              "enable"
            ],
            "title": "Setting to pre-assign breakout rooms."
          },
          "calendar_type": {
            "oneOf": [
              {
                "const": 1
              },
              {
                "const": 2
              }
            ],
            "title": "The type of calendar integration used to schedule the meeting",
            "description": "The type of calendar integration used to schedule the meeting.\n\n- 1 - Zoom Outlook add-in\n- 2 - Zoom for Google Workspace add-on\n\nWorks with the private_meeting field to determine whether to share details of meetings or not."
          },
          "close_registration": {
            "type": "boolean",
            "default": false,
            "title": "Close registration after event date."
          },
          "cn_meeting": {
            "type": "boolean",
            "default": false,
            "deprecated": true,
            "title": "Host meeting in China."
          },
          "contact_email": {
            "type": "string",
            "format": "email",
            "title": "The contact email address for meeting registration."
          },
          "contact_name": {
            "type": "string",
            "title": "The contact name for meeting registration."
          },
          "custom_keys": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/keystringMaxLength64valuestringMaxLength256MaxItems10"
            },
            "title": "Custom keys and values assigned to the meeting."
          },
          "email_notification": {
            "type": "boolean",
            "default": true,
            "title": "Whether to send email notifications to alternative hosts and users with scheduling privileges",
            "description": "Whether to send email notifications to alternative hosts and users with scheduling privileges."
          },
          "encryption_type": {
            "oneOf": [
              {
                "const": "enhanced_encryption"
              },
              {
                "const": "e2ee"
              }
            ],
            "title": "Choose between enhanced encryption and end-to-end encryption when starting or a meeting",
            "description": "Choose between enhanced encryption and end-to-end encryption when starting or a meeting.\n\nWhen using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be automatically disabled.\n\n- enhanced_encryption - Enhanced encryption. Encryption is stored in the cloud if you enable this option.\n- e2ee - End-to-end encryption. The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also disables the join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions features."
          },
          "enforce_login": {
            "type": "boolean",
            "deprecated": true,
            "title": "Only signed in users can join this meeting",
            "description": "Only signed in users can join this meeting."
          },
          "enforce_login_domains": {
            "type": "string",
            "deprecated": true,
            "title": "Only signed in users with specified domains can join meetings",
            "description": "Only signed in users with specified domains can join meetings.\n\nThis field is deprecated and will not be supported in the future."
          },
          "focus_mode": {
            "type": "boolean",
            "title": "Whether the Focus Mode feature is enabled when the meeting starts."
          },
          "global_dial_in_countries": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "List of global dial-in countries."
          },
          "global_dial_in_numbers": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "city": {
                  "type": "string",
                  "title": "city of the number.",
                  "description": "City of the number, such as Chicago."
                },
                "country": {
                  "type": "string",
                  "title": "The country code.",
                  "description": "The country code, such as BR."
                },
                "country_name": {
                  "type": "string",
                  "title": "Full name of country.",
                  "description": "Full name of country, such as Brazil."
                },
                "number": {
                  "type": "string",
                  "title": "A phone number.",
                  "description": "A phone number, such as `+1 2332357613`."
                },
                "type": {
                  "oneOf": [
                    {
                      "const": "toll"
                    },
                    {
                      "const": "tollfree"
                    }
                  ],
                  "title": "Type of number."
                }
              },
              "required": [
                "city",
                "country",
                "country_name",
                "number",
                "type"
              ]
            },
            "title": "Global dial-in countries or regions."
          },
          "host_video": {
            "type": "boolean",
            "title": "Start video when the host joins the meeting."
          },
          "in_meeting": {
            "type": "boolean",
            "default": false,
            "deprecated": true,
            "title": "Host meeting in India."
          },
          "jbh_time": {
            "oneOf": [
              {
                "const": 0
              },
              {
                "const": 5
              },
              {
                "const": 10
              }
            ],
            "title": "If the value of join_before_host field is set to true, use this field to indicate time limits when a participant may join a meeting before a host",
            "description": "If the value of join_before_host field is set to true, use this field to indicate time limits when a participant may join a meeting before a host.\n\n- 0 - Allow participant to join anytime.\n- 5- Allow participant to join 5 minutes before meeting start time.\n- 10 - Allow participant to join 10 minutes before meeting start time."
          },
          "join_before_host": {
            "type": "boolean",
            "default": false,
            "title": "Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings",
            "description": "Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings."
          },
          "language_interpretation": {
            "type": "object",
            "properties": {
              "enable": {
                "type": "boolean",
                "title": "Whether to enable language interpretation for the meeting",
                "description": "Whether to enable language interpretation for the meeting."
              },
              "interpreters": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "email": {
                      "type": "string",
                      "format": "email",
                      "title": "The interpreter's email address",
                      "description": "The interpreter's email address."
                    },
                    "languages": {
                      "type": "string",
                      "title": "comma-separated list of the interpreter's languages",
                      "description": "comma-separated list of the interpreter's languages.\n\nThe string must contain two country IDs.\n\nFor example, if the interpreter will translate from English to Chinese, then this value will be US,CN."
                    }
                  },
                  "required": [
                    "email",
                    "languages"
                  ]
                },
                "title": "Information about the meeting's sign language interpreters",
                "description": "Information about the meeting's sign language interpreters."
              }
            },
            "required": [
              "enable"
            ]
          },
          "sign_language_interpretation": {
            "type": "object",
            "properties": {
              "enable": {
                "type": "boolean",
                "title": "Whether to enable sign language interpretation for the meeting",
                "description": "Whether to enable sign language interpretation for the meeting."
              },
              "interpreters": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "email": {
                      "type": "string",
                      "format": "email",
                      "title": "The interpreter's email address",
                      "description": "The interpreter's email address."
                    },
                    "sign_language": {
                      "type": "string",
                      "title": "The interpreter's sign language",
                      "description": "The interpreter's sign language.\n\nTo get this value, use the sign_language_interpretation object's languages and custom_languages values in the Get user settings API response."
                    }
                  },
                  "required": [
                    "email",
                    "sign_language"
                  ]
                },
                "title": "Information about the meeting's sign language interpreters",
                "description": "Information about the meeting's sign language interpreters."
              }
            },
            "required": [
              "enable"
            ],
            "title": "The meeting's sign language interpretation settings",
            "description": "The meeting's sign language interpretation settings.\n\nMake sure to add the language in the web portal in order to use it in the API. See link for details.\n\nNote: If this feature is not enabled on the host's account, this setting will not be applied to the meeting."
          },
          "meeting_authentication": {
            "type": "boolean",
            "title": "If true, only authenticated users can join the meeting",
            "description": "If true, only authenticated users can join the meeting."
          },
          "mute_upon_entry": {
            "type": "boolean",
            "default": false,
            "title": "Whether to mute participants upon entry",
            "description": "Whether to mute participants upon entry."
          },
          "participant_video": {
            "type": "boolean",
            "title": "Whether to start meetings with the participant video on",
            "description": "Whether to start meetings with the participant video on."
          },
          "private_meeting": {
            "type": "boolean",
            "title": "Whether to set the meeting as private",
            "description": "Whether to set the meeting as private."
          },
          "registrants_confirmation_email": {
            "type": "boolean",
            "title": "Whether to send registrants an email confirmation",
            "description": "Whether to send registrants an email confirmation.\n\n- true - Send a confirmation email.\n- false - Do not send a confirmation email."
          },
          "registrants_email_notification": {
            "type": "boolean",
            "title": "Whether to send registrants email notifications about their registration approval, cancellation, or rejection",
            "description": "Whether to send registrants email notifications about their registration approval, cancellation, or rejection.\n\n- true - Send an email notification.\n- false - Do not send an email notification.\n\nSet this value to true to also use the registrants_confirmation_email parameter."
          },
          "registration_type": {
            "oneOf": [
              {
                "const": 1,
                "default": 1
              },
              {
                "const": 2,
                "default": 1
              },
              {
                "const": 3,
                "default": 1
              }
            ],
            "title": "The meeting's registration type",
            "description": "The meeting's registration type.\n\n- 1 - Attendees register once and can attend any meeting occurrence.\n- 2 - Attendees must register for each meeting occurrence.\n- 3 - Attendees register once and can select one or more meeting occurrences to attend.\n\nThis field is only for recurring meetings with fixed times (8). This value defaults to 1."
          },
          "show_share_button": {
            "type": "boolean",
            "title": "Whether to include social media sharing buttons on the meeting's registration page",
            "description": "Whether to include social media sharing buttons on the meeting's registration page.\n\nThis setting is only applied to meetings with registration enabled."
          },
          "use_pmi": {
            "type": "boolean",
            "default": false,
            "title": "Whether to use a Personal Meeting ID (PMI) instead of a generated meeting ID",
            "description": "Whether to use a Personal Meeting ID (PMI) instead of a generated meeting ID.\n\nThis field is only used for scheduled meetings (2), instant meetings (1), or recurring meetings with no fixed time (3)."
          },
          "waiting_room": {
            "type": "boolean",
            "title": "Whether to enable the Waiting Room feature. If this value is true, this disables the join_before_host setting",
            "description": "Whether to enable the Waiting Room feature. If this value is true, this disables the join_before_host setting."
          },
          "watermark": {
            "type": "boolean",
            "default": false,
            "title": "Whether to add a watermark when viewing a shared screen",
            "description": "Whether to add a watermark when viewing a shared screen."
          },
          "host_save_video_order": {
            "type": "boolean",
            "title": "Whether the Allow host to save video order feature is enabled",
            "description": "Whether the Allow host to save video order feature is enabled."
          },
          "internal_meeting": {
            "type": "boolean",
            "default": false,
            "title": "Whether to set the meeting as an internal meeting",
            "description": "Whether to set the meeting as an internal meeting."
          },
          "meeting_invitees": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "email": {
                  "type": "string",
                  "format": "email",
                  "title": "The invitee's email address",
                  "description": "The invitee's email address."
                }
              },
              "required": [
                "email"
              ]
            },
            "title": "A list of the meeting's invitees",
            "description": "A list of the meeting's invitees."
          },
          "continuous_meeting_chat": {
            "type": "object",
            "properties": {
              "enable": {
                "type": "boolean",
                "title": "Whether to enable the Enable continuous meeting chat setting",
                "description": "Whether to enable the Enable continuous meeting chat setting."
              },
              "auto_add_invited_external_users": {
                "type": "boolean",
                "title": "Whether to enable the Automatically add invited external users setting",
                "description": "Whether to enable the Automatically add invited external users setting."
              },
              "channel_id": {
                "type": "string",
                "title": "The channel's ID",
                "description": "The channel's ID."
              }
            },
            "required": [
              "enable",
              "auto_add_invited_external_users"
            ],
            "title": "Information about the Enable continuous meeting chat feature",
            "description": "Information about the Enable continuous meeting chat feature."
          },
          "participant_focused_meeting": {
            "type": "boolean",
            "default": false,
            "title": "Whether to set the meeting as a participant focused meeting",
            "description": "Whether to set the meeting as a participant focused meeting."
          },
          "push_change_to_calendar": {
            "type": "boolean",
            "default": false,
            "title": "Whether to push meeting changes to the calendar",
            "description": "Whether to push meeting changes to the calendar.\n\nTo enable this feature, configure the Configure Calendar and Contacts Service in the user's profile page of the Zoom web portal and enable the Automatically sync Zoom calendar events information bi-directionally between Zoom and integrated calendars.\n\nsetting in the Settings page of the Zoom web portal.\n\n- true - Push meeting changes to the calendar.\n- false - Do not push meeting changes to the calendar."
          },
          "resources": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "resource_type": {
                  "const": "whiteboard",
                  "title": "The resource type",
                  "description": "The resource type."
                },
                "resource_id": {
                  "type": "string",
                  "title": "The resource ID",
                  "description": "The resource ID."
                },
                "permission_level": {
                  "oneOf": [
                    {
                      "const": "editor",
                      "default": "editor"
                    },
                    {
                      "const": "viewer",
                      "default": "editor"
                    },
                    {
                      "const": "commenter",
                      "default": "editor"
                    }
                  ],
                  "title": "The permission levels for users to access the whiteboard",
                  "description": "The permission levels for users to access the whiteboard.\n\n- `editor` - Users with link access can edit the board.\n- `commenter` - Users with link access can comment on the board.\n- `viewer` - Users with link access can view the board."
                }
              },
              "required": [
                "resource_type",
                "resource_id",
                "permission_level"
              ]
            },
            "title": "The meeting's resources."
          },
          "auto_start_meeting_summary": {
            "type": "boolean",
            "default": false,
            "title": "Whether to automatically start a meeting summary",
            "description": "Whether to automatically start a meeting summary."
          },
          "auto_start_ai_companion_questions": {
            "type": "boolean",
            "default": false,
            "title": "Whether to automatically start AI Companion questions",
            "description": "Whether to automatically start AI Companion questions."
          }
        }
      },
      "keystringMaxLength64valuestringMaxLength256MaxItems10": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "maxLength": 64,
            "title": "Custom key associated with the user."
          },
          "value": {
            "type": "string",
            "maxLength": 256,
            "title": "Value of the custom key associated with the user."
          },
          "typia.tag": {
            "type": "object",
            "properties": {
              "target": {
                "const": "array"
              },
              "kind": {
                "const": "maxItems"
              },
              "value": {
                "const": 10
              },
              "validate": {
                "const": "$input.length <= 10"
              },
              "exclusive": {
                "const": true
              },
              "schema": {
                "type": "object",
                "properties": {
                  "maxItems": {
                    "const": 10
                  }
                },
                "required": [
                  "maxItems"
                ]
              }
            },
            "required": [
              "target",
              "kind",
              "value",
              "validate",
              "exclusive",
              "schema"
            ],
            "title": "This is a dummy property for compilation",
            "description": "This is a dummy property for compilation.\n\nIt does not mean anything in runtime."
          }
        },
        "required": [
          "key",
          "value"
        ]
      },
      "IZoom.TrackingField": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string",
            "title": "Label of `TrackingField`."
          },
          "value": {
            "type": "string",
            "title": "The value of `TrackingField`."
          },
          "visible": {
            "type": "boolean",
            "title": "Whether `TrackingField` is exposed."
          }
        },
        "required": [
          "field",
          "value",
          "visible"
        ],
        "description": "Information about the meeting's tracking fields."
      },
      "IZoom.ICreateMeetingInput": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "string"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "zoom",
            "x-wrtn-secret-scopes": [
              "meeting:write:admin",
              "meeting:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "userId",
          "secretKey"
        ]
      },
      "ISweetTracker.IGetRecommendedCompanyListOutput": {
        "type": "object",
        "properties": {
          "Recommend": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitISweetTracker.CompanyInternational"
            },
            "title": "Courier list"
          }
        },
        "required": [
          "Recommend"
        ],
        "title": "DTO List of couriers matching the invoice number"
      },
      "StrictOmitISweetTracker.CompanyInternational": {
        "type": "object",
        "properties": {
          "Name": {
            "type": "string",
            "title": "Courier name"
          },
          "Code": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Unique code value of the courier company"
          }
        },
        "required": [
          "Name",
          "Code"
        ]
      },
      "ISweetTracker.IGetRecommendedCompanyListInput": {
        "type": "object",
        "properties": {
          "t_invoice": {
            "type": "string",
            "title": "Invoice number"
          }
        },
        "required": [
          "t_invoice"
        ]
      },
      "ISweetTracker.IGetCompanyListOutput": {
        "type": "object",
        "properties": {
          "Company": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISweetTracker.Company"
            },
            "title": "Courier list"
          }
        },
        "required": [
          "Company"
        ],
        "title": "Courier inquiry response DTO"
      },
      "ISweetTracker.Company": {
        "type": "object",
        "properties": {
          "Code": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Unique code value of the courier company"
          },
          "International": {
            "oneOf": [
              {
                "const": "true"
              },
              {
                "const": "false"
              }
            ],
            "title": "International Shipping"
          },
          "Name": {
            "type": "string",
            "title": "Courier name"
          }
        },
        "required": [
          "Code",
          "International",
          "Name"
        ]
      },
      "ISweetTracker.IGetTrackingInfoOutput": {
        "type": "object",
        "properties": {
          "senderName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Sender's name"
          },
          "receiverAddr": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Recipient Address"
          },
          "firstDetail": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ISweetTracker.TrackingDetail"
              }
            ],
            "title": "It means the first path among the paths, and corresponds to the 0th index of the `trackingDetails` array",
            "description": "It means the first path among the paths, and corresponds to the 0th index of the `trackingDetails` array."
          },
          "level": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": 1,
                "title": "배송 준비 중",
                "description": "배송 준비 중"
              },
              {
                "const": 2,
                "title": "집화 완료",
                "description": "집화 완료"
              },
              {
                "const": 3,
                "title": "배송 중",
                "description": "배송 중"
              },
              {
                "const": 4,
                "title": "지점 도착",
                "description": "지점 도착"
              },
              {
                "const": 5,
                "title": "배송 출발",
                "description": "배송 출발"
              },
              {
                "const": 6,
                "title": "배송 완료",
                "description": "배송 완료"
              }
            ],
            "title": "Progress stage"
          },
          "lastDetail": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ISweetTracker.TrackingDetail"
              }
            ],
            "title": "It means the last path among the paths, and corresponds to the last index of the `trackingDetails` array",
            "description": "It means the last path among the paths, and corresponds to the last index of the `trackingDetails` array."
          },
          "estimate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Expected delivery time",
            "description": "Text in the format '15:00~17:00'"
          },
          "itemImage": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Product Image URL"
          },
          "adUrl": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Address used by courier companies for advertising purposes"
          },
          "lastStateDetail": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ISweetTracker.TrackingDetail"
              }
            ],
            "title": "lastStateDetail"
          },
          "zipCode": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Postal address"
          },
          "invoiceNo": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "tracking number"
          },
          "completeYN": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "Y",
                "title": "배송 완료",
                "description": "배송이 완료된 경우에는 Y로 표기된다."
              },
              {
                "const": "N",
                "title": "배송 중",
                "description": "배송이 완료되지 않은 경우에는 N으로 표기된다."
              }
            ],
            "title": "Delivery Completed"
          },
          "orderNumber": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Order Number"
          },
          "complete": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "Delivery Completed"
          },
          "recipient": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Recipient Information"
          },
          "receiverName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Recipient"
          },
          "result": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Search Results"
          },
          "productInfo": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Product Information"
          },
          "itemName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Product Name"
          }
        }
      },
      "ISweetTracker.TrackingDetail": {
        "type": "object",
        "properties": {
          "code": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Delivery Status Code"
          },
          "kind": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Progress status"
          },
          "level": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": 1,
                "title": "배송 준비 중",
                "description": "배송 준비 중"
              },
              {
                "const": 2,
                "title": "집화 완료",
                "description": "집화 완료"
              },
              {
                "const": 3,
                "title": "배송 중",
                "description": "배송 중"
              },
              {
                "const": 4,
                "title": "지점 도착",
                "description": "지점 도착"
              },
              {
                "const": 5,
                "title": "배송 출발",
                "description": "배송 출발"
              },
              {
                "const": 6,
                "title": "배송 완료",
                "description": "배송 완료"
              }
            ],
            "title": "Progress stage"
          },
          "manName": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Delivery driver name"
          },
          "manPic": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Delivery driver phone number"
          },
          "remark": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Note"
          },
          "telno": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Delivery driver phone number"
          },
          "telno2": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Delivery driver phone number"
          },
          "time": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "Progress time"
          },
          "timeString": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Progress time"
          },
          "where": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Progress location"
          }
        }
      },
      "ISweetTracker.IGetTrackingInfoInput": {
        "type": "object",
        "properties": {
          "t_invoice": {
            "type": "string",
            "title": "Invoice number"
          },
          "t_code": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "path": "/connector/sweet-tracker/get-companies",
                  "method": "post",
                  "jmesPath": "Company[].{value:Code, label:Name}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "path": "/connector/sweet-tracker/get-companies/recommended",
                  "method": "post",
                  "jmesPath": "Recommend[].{value:Code, label:Name}"
                }
              }
            ],
            "title": "Courier Code",
            "description": "The courier code must be entered as the `Code` value that appears when searching for a courier company.\nNote that this is an arbitrary code value, not the name of the courier company."
          }
        },
        "required": [
          "t_invoice",
          "t_code"
        ]
      },
      "IHancell.IUpsertSheetOutput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "title": "New Hansel File Link"
          }
        },
        "required": [
          "fileUrl"
        ]
      },
      "IHancell.IUpsertSheetInput": {
        "type": "object",
        "properties": {
          "sheetName": {
            "type": "string",
            "title": "Sheet name",
            "description": "If the sheet does not exist, it will be added, and if it does exist, it will be modified."
          },
          "cells": {
            "$ref": "#/components/schemas/IHancell.Cells",
            "title": "Sheet Information",
            "description": "Information contained in each cell of the sheet."
          },
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Excel file",
            "description": "Excel file to read"
          }
        },
        "required": [
          "sheetName",
          "cells",
          "fileUrl"
        ]
      },
      "IHancell.Cells": {
        "type": "object",
        "properties": {},
        "title": "Information contained in the cell",
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            }
          ]
        }
      },
      "IHancell.IReadHancellOutput": {
        "type": "object",
        "properties": {},
        "title": "Hansel Read Response",
        "additionalProperties": {
          "$ref": "#/components/schemas/IHancell.Cells"
        }
      },
      "IHancell.IReadHancellInput": {
        "type": "object",
        "properties": {
          "fileUrl": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "title": "Excel file",
            "description": "Excel file to read"
          }
        },
        "required": [
          "fileUrl"
        ],
        "title": "Hansel reading conditions"
      },
      "IKakaoTalk.ISendKakaoTalkToFriendsOutput": {
        "type": "object",
        "properties": {
          "successful_receiver_uuids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "maxItems": 5,
            "title": "List of successfully sent friend UUIDs"
          },
          "failure_info": {
            "$ref": "#/components/schemas/IKakaoTalk.failureInfo",
            "title": "Failure Information"
          }
        },
        "title": "Message Sending Result"
      },
      "IKakaoTalk.failureInfo": {
        "type": "object",
        "properties": {
          "code": {
            "type": "number",
            "title": "Error Code"
          },
          "msg": {
            "type": "string",
            "title": "Error Message"
          },
          "receiver_uuids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "maxItems": 5,
            "title": "List of friend UUIDs that failed with the given error code"
          }
        },
        "required": [
          "code",
          "msg",
          "receiver_uuids"
        ],
        "title": "Failure Information"
      },
      "IKakaoTalk.ISendKakaoTalkToFriendsInput": {
        "type": "object",
        "properties": {
          "receiver_uuids": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/kakao-talk/get-friends",
                "jmesPath": "{value:elements[].uuid, label:elements[].profile_nickname}"
              }
            },
            "minItems": 1,
            "maxItems": 5,
            "title": "List of friends' UUIDs"
          },
          "message": {
            "type": "string",
            "maxLength": 200,
            "title": "Message to send"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_message"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "receiver_uuids",
          "message",
          "secretKey"
        ],
        "title": "Message Sending Conditions"
      },
      "IKakaoTalk.IMemoOutput": {
        "type": "object",
        "properties": {
          "result_code": {
            "const": 0,
            "title": "Response Code",
            "description": "Indicates successful message sending"
          }
        },
        "required": [
          "result_code"
        ]
      },
      "IKakaoTalk.ISendKakaoTalkCommerceInput": {
        "type": "object",
        "properties": {
          "template_object": {
            "$ref": "#/components/schemas/IKakaoTalk.ICommerceMemoInput",
            "title": "Commerce Template"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_message",
              "profile_image",
              "profile_nickname"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "template_object",
          "secretKey"
        ],
        "title": "Message Sending Conditions"
      },
      "IKakaoTalk.ICommerceMemoInput": {
        "type": "object",
        "properties": {
          "object_type": {
            "const": "commerce",
            "title": "Commerce Type",
            "x-wrtn-placeholder": "commerce"
          },
          "commerce": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/product_namestringundefinedregular_pricenumberTypeint64discount_price(numberTypeint64)undefinedcurrency_unit(stringDefault원)undefinedcurrency_unit_positionConstant......1more...undefined..."
              },
              {
                "$ref": "#/components/schemas/product_namestringundefinedregular_pricenumberTypeint64discount_price(numberTypeint64)undefinedcurrency_unit(stringDefault원)undefinedcurrency_unit_positionConstant......1more...undefined....o1"
              }
            ],
            "title": "Product Name and Pricing Information"
          },
          "buttons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.Button"
            },
            "maxItems": 2,
            "title": "List of Buttons",
            "description": "Used to customize button titles and links. Supports two buttons and takes precedence over `button_title`."
          },
          "content": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/titlestringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink"
              },
              {
                "$ref": "#/components/schemas/image_urlstringFormaturlimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum...)undefinedlinkButtonLink"
              },
              {
                "$ref": "#/components/schemas/descriptionstringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink"
              }
            ],
            "title": "Message Content"
          },
          "button_title": {
            "type": "string",
            "title": "Button Title"
          }
        },
        "required": [
          "object_type",
          "commerce",
          "content"
        ],
        "title": "Commerce Template"
      },
      "product_namestringundefinedregular_pricenumberTypeint64discount_price(numberTypeint64)undefinedcurrency_unit(stringDefault원)undefinedcurrency_unit_positionConstant......1more...undefined...": {
        "type": "object",
        "properties": {
          "product_name": {
            "type": "string",
            "title": "Product Name and Title"
          },
          "regular_price": {
            "type": "integer",
            "title": "Regular Price"
          },
          "discount_price": {
            "type": "integer",
            "title": "Discounted Price"
          },
          "currency_unit": {
            "type": "string",
            "default": "원",
            "title": "Currency Unit or Symbol"
          },
          "currency_unit_position": {
            "oneOf": [
              {
                "const": 0,
                "title": "Displayed after price"
              },
              {
                "const": 1,
                "title": "Displayed before price"
              }
            ],
            "title": "Currency Unit Position"
          },
          "discount_rate": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100,
            "title": "Discount Rate",
            "description": "A number between 0 and 100"
          }
        },
        "required": [
          "regular_price"
        ]
      },
      "product_namestringundefinedregular_pricenumberTypeint64discount_price(numberTypeint64)undefinedcurrency_unit(stringDefault원)undefinedcurrency_unit_positionConstant......1more...undefined....o1": {
        "type": "object",
        "properties": {
          "product_name": {
            "type": "string",
            "title": "Product Name and Title"
          },
          "regular_price": {
            "type": "integer",
            "title": "Regular Price"
          },
          "discount_price": {
            "type": "integer",
            "title": "Discounted Price"
          },
          "currency_unit": {
            "type": "string",
            "default": "원",
            "title": "Currency Unit or Symbol"
          },
          "currency_unit_position": {
            "oneOf": [
              {
                "const": 0,
                "title": "Displayed after price"
              },
              {
                "const": 1,
                "title": "Displayed before price"
              }
            ],
            "title": "Currency Unit Position"
          },
          "fixedDiscountPrice": {
            "type": "integer",
            "minimum": 0,
            "title": "Fixed Discount Price",
            "description": "Cannot be used together with discount rate"
          }
        },
        "required": [
          "regular_price"
        ]
      },
      "IKakaoTalk.Button": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "x-wrtn-placeholder": "Button Name",
            "title": "Button Name"
          },
          "link": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/IKakaoTalk.IWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IMobileWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IAndroidAppLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IiOSAppLink"
              }
            ],
            "title": "Button Link"
          }
        },
        "required": [
          "title",
          "link"
        ],
        "title": "Button Information"
      },
      "IKakaoTalk.IWebLink": {
        "type": "object",
        "properties": {
          "web_url": {
            "type": "string",
            "format": "url",
            "title": "Web Link"
          }
        },
        "required": [
          "web_url"
        ],
        "title": "Web Link"
      },
      "IKakaoTalk.IMobileWebLink": {
        "type": "object",
        "properties": {
          "mobile_web_url": {
            "type": "string",
            "format": "url",
            "title": "Mobile Web Link"
          }
        },
        "required": [
          "mobile_web_url"
        ],
        "title": "Mobile Web Link"
      },
      "IKakaoTalk.IAndroidAppLink": {
        "type": "object",
        "properties": {
          "android_execution_params": {
            "type": "string",
            "title": "App Link",
            "description": "Use `mobile_web_url` if this value is absent"
          }
        },
        "required": [
          "android_execution_params"
        ],
        "title": "Android App Link"
      },
      "IKakaoTalk.IiOSAppLink": {
        "type": "object",
        "properties": {
          "ios_execution_params": {
            "type": "string",
            "title": "App Link",
            "description": "Use `mobile_web_url` if this value is absent"
          }
        },
        "required": [
          "ios_execution_params"
        ],
        "title": "iOS App Link"
      },
      "titlestringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title."
          },
          "image_width": {
            "type": "integer",
            "minimum": 200,
            "title": "Image Width",
            "description": "In pixels."
          },
          "image_height": {
            "type": "integer",
            "minimum": 200,
            "title": "Image Height",
            "description": "In pixels."
          },
          "link": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/IKakaoTalk.IWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IMobileWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IAndroidAppLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IiOSAppLink"
              }
            ],
            "title": "Link Information for Redirection"
          }
        },
        "required": [
          "title",
          "link"
        ]
      },
      "image_urlstringFormaturlimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum...)undefinedlinkButtonLink": {
        "type": "object",
        "properties": {
          "image_url": {
            "type": "string",
            "format": "url",
            "title": "Image URL",
            "description": "The image size must not exceed `5MB`."
          },
          "image_width": {
            "type": "integer",
            "minimum": 200,
            "title": "Image Width",
            "description": "In pixels."
          },
          "image_height": {
            "type": "integer",
            "minimum": 200,
            "title": "Image Height",
            "description": "In pixels."
          },
          "link": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/IKakaoTalk.IWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IMobileWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IAndroidAppLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IiOSAppLink"
              }
            ],
            "title": "Link Information for Redirection"
          }
        },
        "required": [
          "image_url",
          "link"
        ]
      },
      "descriptionstringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "title": "Detailed Description",
            "description": "Combined with title, displayed up to 4 lines."
          },
          "image_width": {
            "type": "integer",
            "minimum": 200,
            "title": "Image Width",
            "description": "In pixels."
          },
          "image_height": {
            "type": "integer",
            "minimum": 200,
            "title": "Image Height",
            "description": "In pixels."
          },
          "link": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/IKakaoTalk.IWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IMobileWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IAndroidAppLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IiOSAppLink"
              }
            ],
            "title": "Link Information for Redirection"
          }
        },
        "required": [
          "description",
          "link"
        ]
      },
      "IKakaoTalk.ISendKakaoTalkLocationInput": {
        "type": "object",
        "properties": {
          "template_object": {
            "$ref": "#/components/schemas/IKakaoTalk.ILocationMemoInput",
            "title": "Location Template"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_message",
              "profile_image",
              "profile_nickname"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "template_object",
          "secretKey"
        ],
        "title": "Message Sending Conditions"
      },
      "IKakaoTalk.ILocationMemoInput": {
        "type": "object",
        "properties": {
          "object_type": {
            "const": "location",
            "title": "Location Type",
            "x-wrtn-placeholder": "location"
          },
          "address": {
            "type": "string",
            "title": "Address of the Location to Share"
          },
          "address_title": {
            "type": "string",
            "title": "Title Used in KakaoTalk Map View"
          },
          "social": {
            "$ref": "#/components/schemas/IKakaoTalk.Social",
            "title": "Additional Social Information"
          },
          "buttons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.Button"
            },
            "maxItems": 2,
            "title": "List of Buttons",
            "description": "Used to customize button titles and links. Supports two buttons and takes precedence over `button_title`."
          },
          "content": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/titlestringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink"
              },
              {
                "$ref": "#/components/schemas/image_urlstringFormaturlimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum...)undefinedlinkButtonLink"
              },
              {
                "$ref": "#/components/schemas/descriptionstringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink"
              }
            ],
            "title": "Message Content"
          },
          "button_title": {
            "type": "string",
            "title": "Button Title"
          }
        },
        "required": [
          "object_type",
          "address",
          "content"
        ],
        "title": "Location Template"
      },
      "IKakaoTalk.Social": {
        "type": "object",
        "properties": {
          "like_count": {
            "type": "integer",
            "title": "Number of Likes on the Content"
          },
          "comment_count": {
            "type": "integer",
            "title": "Number of Comments on the Content"
          },
          "shared_count": {
            "type": "integer",
            "title": "Number of Shares of the Content"
          },
          "view_count": {
            "type": "integer",
            "title": "Number of Views of the Content"
          },
          "subscriber_count": {
            "type": "integer",
            "title": "Number of Subscribers to the Content"
          }
        },
        "title": "Social Information",
        "description": "Up to 3 out of 5 attributes will be displayed. Priority is Like > Comment > Shared > View > Subscriber."
      },
      "IKakaoTalk.ISendKakaoTalkListInput": {
        "type": "object",
        "properties": {
          "template_object": {
            "$ref": "#/components/schemas/IKakaoTalk.IListMemoInput",
            "title": "List Template"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_message",
              "profile_image",
              "profile_nickname"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "template_object",
          "secretKey"
        ],
        "title": "Message Sending Conditions"
      },
      "IKakaoTalk.IListMemoInput": {
        "type": "object",
        "properties": {
          "object_type": {
            "const": "list",
            "title": "List Type",
            "x-wrtn-placeholder": "list"
          },
          "header_title": {
            "type": "string",
            "maxLength": 200,
            "title": "Main Title Displayed at the Top of the List"
          },
          "header_link": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/IKakaoTalk.IWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IMobileWebLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IAndroidAppLink"
              },
              {
                "$ref": "#/components/schemas/IKakaoTalk.IiOSAppLink"
              }
            ],
            "title": "Link Information Corresponding to the Header Title"
          },
          "contents": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/titlestringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink"
                },
                {
                  "$ref": "#/components/schemas/image_urlstringFormaturlimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum...)undefinedlinkButtonLink"
                },
                {
                  "$ref": "#/components/schemas/descriptionstringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink"
                }
              ]
            },
            "minItems": 2,
            "maxItems": 3,
            "title": "List of Contents Displayed in the List"
          },
          "buttons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.Button"
            },
            "maxItems": 2,
            "title": "List of Buttons",
            "description": "Used to customize button titles and links. Supports two buttons and takes precedence over `button_title`."
          },
          "button_title": {
            "type": "string",
            "title": "Button Title"
          }
        },
        "required": [
          "object_type",
          "header_title",
          "header_link",
          "contents"
        ],
        "title": "List Template"
      },
      "IKakaoTalk.ISendKakaoTalkFeedInput": {
        "type": "object",
        "properties": {
          "template_object": {
            "$ref": "#/components/schemas/IKakaoTalk.IFeedMemoInput",
            "title": "Feed Template"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_message",
              "profile_image",
              "profile_nickname"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "template_object",
          "secretKey"
        ],
        "title": "Message Sending Conditions"
      },
      "IKakaoTalk.IFeedMemoInput": {
        "type": "object",
        "properties": {
          "object_type": {
            "const": "feed",
            "title": "Feed Type"
          },
          "item_content": {
            "$ref": "#/components/schemas/IKakaoTalk.ItemContent",
            "title": "Content to Include in the Item Area"
          },
          "social": {
            "$ref": "#/components/schemas/IKakaoTalk.Social",
            "title": "Social Information About the Content"
          },
          "buttons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.Button"
            },
            "maxItems": 2,
            "title": "List of Buttons",
            "description": "Used to customize button titles and links. Supports two buttons and takes precedence over `button_title`."
          },
          "content": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/titlestringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink"
              },
              {
                "$ref": "#/components/schemas/image_urlstringFormaturlimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum...)undefinedlinkButtonLink"
              },
              {
                "$ref": "#/components/schemas/descriptionstringimage_width(numberTypeuint64Minimum200)undefinedimage_height(numberTypeuint64Minimum200)undefinedlinkButtonLink"
              }
            ],
            "title": "Message Content"
          },
          "button_title": {
            "type": "string",
            "title": "Button Title"
          }
        },
        "required": [
          "object_type",
          "item_content",
          "content"
        ],
        "title": "Feed Template"
      },
      "IKakaoTalk.ItemContent": {
        "type": "object",
        "properties": {
          "profile_text": {
            "type": "string",
            "maxLength": 16,
            "title": "Text to Display in the Header or Profile Area",
            "description": "If `profile_image_url` is absent, it will be displayed as a bold header containing only the title."
          },
          "profile_image_url": {
            "type": "string",
            "format": "url",
            "title": "Profile Image",
            "description": "Displayed as a small circular profile photo."
          },
          "title_image_url": {
            "type": "string",
            "format": "url",
            "title": "Item Image",
            "description": "iOS 108x108, Android 98x98 size. Images not in a 1:1 ratio will be center cropped."
          },
          "title_image_text": {
            "type": "string",
            "maxLength": 24,
            "title": "Item Title",
            "description": "Maximum of 2 lines."
          },
          "title_image_category": {
            "type": "string",
            "maxLength": 14,
            "title": "Category",
            "description": "Maximum of 1 line."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.ItemInfo"
            },
            "maxItems": 5,
            "title": "List of Items",
            "description": "Information for each text item."
          },
          "sum": {
            "type": "string",
            "maxLength": 6,
            "title": "Total Amount"
          },
          "sum_op": {
            "type": "string",
            "maxLength": 11,
            "title": "Price Summary Information"
          }
        },
        "title": "Item Content"
      },
      "IKakaoTalk.ItemInfo": {
        "type": "object",
        "properties": {
          "item": {
            "type": "string",
            "maxLength": 6,
            "title": "Item Name"
          },
          "item_op": {
            "type": "string",
            "maxLength": 14,
            "title": "Item Price"
          }
        },
        "required": [
          "item",
          "item_op"
        ],
        "title": "Item Information"
      },
      "IKakaoTalk.ISendKakaoTalkTextInput": {
        "type": "object",
        "properties": {
          "template_object": {
            "$ref": "#/components/schemas/IKakaoTalk.ITextMemoInput",
            "title": "Text Template"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_message",
              "profile_image",
              "profile_nickname"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "template_object",
          "secretKey"
        ],
        "title": "Message Sending Conditions"
      },
      "IKakaoTalk.ITextMemoInput": {
        "type": "object",
        "properties": {
          "object_type": {
            "const": "text",
            "title": "Text Type"
          },
          "text": {
            "type": "string",
            "maxLength": 200,
            "title": "Body Text"
          },
          "link": {
            "$ref": "#/components/schemas/IWebLinkIMobileWebLink",
            "title": "Link"
          },
          "buttons": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.Button"
            },
            "maxItems": 2,
            "title": "List of Buttons",
            "description": "Used to customize button titles and links. Supports two buttons and takes precedence over `button_title`."
          },
          "button_title": {
            "type": "string",
            "title": "Button Title"
          }
        },
        "required": [
          "object_type",
          "text",
          "link"
        ],
        "title": "Text Template"
      },
      "IWebLinkIMobileWebLink": {
        "type": "object",
        "properties": {
          "web_url": {
            "type": "string",
            "format": "url",
            "title": "Web Link"
          },
          "mobile_web_url": {
            "type": "string",
            "format": "url",
            "title": "Mobile Web Link"
          }
        },
        "required": [
          "web_url",
          "mobile_web_url"
        ]
      },
      "IKakaoTalk.ICreateEventOutput": {
        "type": "object",
        "properties": {
          "event_id": {
            "type": "string",
            "title": "ID of the created event"
          }
        },
        "required": [
          "event_id"
        ],
        "title": "Output of created event"
      },
      "IKakaoTalk.ICreateEventInput": {
        "type": "object",
        "properties": {
          "calendar_id": {
            "type": "string",
            "default": "primary",
            "x-wrtn-placeholder": "primary",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/kakao-talk/get-calendars",
              "jmesPath": "calendars[].{value:id, label: name || ''} || subscribe_calendars[].{value:id, label: name || ''}"
            },
            "title": "Calendar ID to create the event in"
          },
          "event": {
            "$ref": "#/components/schemas/IKakaoTalk.Event",
            "title": "Information of the event to be created"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "event",
          "secretKey"
        ],
        "title": "Conditions for creating an event"
      },
      "IKakaoTalk.Event": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "maxLength": 50,
            "x-wrtn-placeholder": "Event title",
            "title": "Event title"
          },
          "time": {
            "$ref": "#/components/schemas/IKakaoTalk.Time",
            "title": "Event time"
          },
          "rrule": {
            "type": "string",
            "title": "Recurrence rule for the event",
            "description": "In RFC5545 RRULE format"
          },
          "description": {
            "type": "string",
            "maxLength": 5000,
            "x-wrtn-placeholder": "Event description",
            "title": "Event description"
          },
          "location": {
            "$ref": "#/components/schemas/IKakaoTalk.Location",
            "title": "Event location"
          },
          "reminders": {
            "type": "array",
            "items": {
              "type": "number",
              "multipleOf": 5,
              "minimum": -1440,
              "maximum": 43200
            },
            "maxItems": 2,
            "title": "Reminder settings",
            "description": "In minutes, can be set in 5-minute intervals, up to 2 reminders. For all-day events, can start from -1440, for non-all-day events, starts from 0."
          },
          "color": {
            "oneOf": [
              {
                "const": "BLUE",
                "title": "BLUE",
                "description": "2C88DE"
              },
              {
                "const": "ROYAL_BLUE",
                "title": "ROYAL_BLUE",
                "description": "2D69E0"
              },
              {
                "const": "NAVY_BLUE",
                "title": "NAVY_BLUE",
                "description": "223788"
              },
              {
                "const": "RED",
                "title": "RED",
                "description": "D42726"
              },
              {
                "const": "PINK",
                "title": "PINK",
                "description": "ED5683"
              },
              {
                "const": "ORANGE",
                "title": "ORANGE",
                "description": "FF9429"
              },
              {
                "const": "GREEN",
                "title": "GREEN",
                "description": "149959"
              },
              {
                "const": "LIME",
                "title": "LIME",
                "description": "7CB343"
              },
              {
                "const": "OLIVE",
                "title": "OLIVE",
                "description": "A4AD15"
              },
              {
                "const": "MINT",
                "title": "MINT",
                "description": "5CC5BE"
              },
              {
                "const": "MAGENTA",
                "title": "MAGENTA",
                "description": "AB47BC"
              },
              {
                "const": "VIOLET",
                "title": "VIOLET",
                "description": "8A4B9B"
              },
              {
                "const": "LAVENDER",
                "title": "LAVENDER",
                "description": "7986CB"
              },
              {
                "const": "BROWN",
                "title": "BROWN",
                "description": "945C1F"
              },
              {
                "const": "GRAY",
                "title": "GRAY",
                "description": "666666"
              }
            ],
            "title": "Event color"
          }
        },
        "required": [
          "title",
          "time"
        ],
        "title": "Event created in KakaoTalk calendar"
      },
      "IKakaoTalk.Time": {
        "type": "object",
        "properties": {
          "start_at": {
            "type": "string",
            "x-wrtn-placeholder": "2023-12-31T15:00:00Z",
            "title": "Start time of the event",
            "description": "Can be set in 5-minute intervals"
          },
          "end_at": {
            "type": "string",
            "x-wrtn-placeholder": "2024-01-01T15:00:00Z",
            "title": "End time of the event"
          },
          "time_zone": {
            "type": "string",
            "default": "Asia/Seoul",
            "title": "Timezone setting\n\nIn TZID format."
          },
          "all_day": {
            "type": "boolean",
            "default": false,
            "title": "Whether the event is all-day"
          },
          "lunar": {
            "type": "boolean",
            "default": false,
            "title": "Whether to set the date based on the lunar calendar"
          }
        },
        "title": "Time settings for an event"
      },
      "IKakaoTalk.Location": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "title": "Place Name"
          },
          "location_id": {
            "type": "number",
            "title": "Place ID"
          },
          "address": {
            "type": "string",
            "title": "Address"
          },
          "latitude": {
            "type": "number",
            "title": "Latitude"
          },
          "longitude": {
            "type": "number",
            "title": "Longitude"
          }
        },
        "title": "Location"
      },
      "IKakaoTalk.IGetFriendsOutput": {
        "type": "object",
        "properties": {
          "elements": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.Friend"
            },
            "title": "Friends list"
          },
          "total_count": {
            "type": "integer",
            "title": "Total number of friends"
          },
          "after_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Next page URL of the friends list"
          },
          "before_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Previous page URL of the friends list"
          },
          "favorite_count": {
            "type": "integer",
            "title": "Number of favorite friends"
          }
        },
        "required": [
          "elements",
          "total_count"
        ],
        "title": "Result of retrieving friends"
      },
      "IKakaoTalk.Friend": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "title": "Member number",
            "description": "User ID\n\nA member number assigned to a friend in KakaoTalk, equivalent to the ID value.\nNote that the `uuid` property is used when sending messages."
          },
          "uuid": {
            "type": "string",
            "title": "Friend code",
            "description": "Friend code used when sending KakaoTalk messages. Used for actions such as sending KakaoTalk messages later.\nAlthough the property name is `uuid`, it is not in the usual uuid format, so use it with caution."
          },
          "favorite": {
            "type": "boolean",
            "title": "Whether the friend is a favorite"
          },
          "profile_nickname": {
            "type": "string",
            "title": "Nickname"
          },
          "profile_thumbnail_image": {
            "oneOf": [
              {
                "const": "",
                "title": "NO_PROFILE_IMAGE"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Thumbnail"
          }
        },
        "required": [
          "id",
          "uuid",
          "profile_nickname"
        ],
        "title": "KakaoTalk friend"
      },
      "IKakaoTalk.IGetFriendsInput": {
        "type": "object",
        "properties": {
          "offset": {
            "type": "integer",
            "default": 0,
            "title": "Starting point of the friends list"
          },
          "limit": {
            "type": "integer",
            "title": "Number of friends per page"
          },
          "order": {
            "oneOf": [
              {
                "const": "asc",
                "title": "Ascending",
                "default": "asc"
              },
              {
                "const": "desc",
                "title": "Descending",
                "default": "asc"
              }
            ],
            "title": "Sort order of the friends list"
          },
          "friend_order": {
            "oneOf": [
              {
                "const": "favorite",
                "title": "Sort by favorite",
                "default": "favorite"
              },
              {
                "const": "nickname",
                "title": "Sort by nickname",
                "default": "favorite"
              }
            ],
            "title": "Sort criteria of the friends list\n\nIt must be one of: 'favorite', 'nickname'.\nDefault value is 'favorite'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "friends"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Conditions for retrieving friends"
      },
      "IKakaoTalk.IGetEventOutput": {
        "type": "object",
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.EventBrief"
            },
            "title": "List of events"
          },
          "has_next": {
            "type": "boolean",
            "title": "Whether there is a next page"
          },
          "after_url": {
            "type": "string",
            "format": "url",
            "title": "URL of the next page\n\nA URL containing parameters and values to retrieve the next page, used as is when requesting the next page.\n\nProvided when `has_next` is true."
          }
        },
        "required": [
          "events",
          "has_next"
        ],
        "title": "Result of retrieving events"
      },
      "IKakaoTalk.EventBrief": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Event ID"
          },
          "title": {
            "type": "string",
            "title": "Event title"
          },
          "type": {
            "type": "string",
            "title": "Event type"
          },
          "calendar_id": {
            "type": "string",
            "default": "primary",
            "x-wrtn-placeholder": "primary",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/kakao-talk/get-calendars",
              "jmesPath": "calendars[].{value:id, label: name || ''} || subscribe_calendars[].{value:id, label: name || ''}"
            },
            "title": "Calendar ID",
            "description": "Fixed to primary for the default calendar"
          },
          "time": {
            "$ref": "#/components/schemas/IKakaoTalk.Time",
            "title": "Event time"
          },
          "is_host": {
            "type": "boolean",
            "default": false,
            "title": "Whether the user is the host of the event",
            "description": "For public/subscribed or invited events"
          },
          "is_recur_event": {
            "type": "boolean",
            "title": "Whether the event is recurring",
            "description": "Required if type is USER."
          },
          "color": {
            "oneOf": [
              {
                "const": "BLUE",
                "title": "BLUE",
                "description": "2C88DE"
              },
              {
                "const": "ROYAL_BLUE",
                "title": "ROYAL_BLUE",
                "description": "2D69E0"
              },
              {
                "const": "NAVY_BLUE",
                "title": "NAVY_BLUE",
                "description": "223788"
              },
              {
                "const": "RED",
                "title": "RED",
                "description": "D42726"
              },
              {
                "const": "PINK",
                "title": "PINK",
                "description": "ED5683"
              },
              {
                "const": "ORANGE",
                "title": "ORANGE",
                "description": "FF9429"
              },
              {
                "const": "GREEN",
                "title": "GREEN",
                "description": "149959"
              },
              {
                "const": "LIME",
                "title": "LIME",
                "description": "7CB343"
              },
              {
                "const": "OLIVE",
                "title": "OLIVE",
                "description": "A4AD15"
              },
              {
                "const": "MINT",
                "title": "MINT",
                "description": "5CC5BE"
              },
              {
                "const": "MAGENTA",
                "title": "MAGENTA",
                "description": "AB47BC"
              },
              {
                "const": "VIOLET",
                "title": "VIOLET",
                "description": "8A4B9B"
              },
              {
                "const": "LAVENDER",
                "title": "LAVENDER",
                "description": "7986CB"
              },
              {
                "const": "BROWN",
                "title": "BROWN",
                "description": "945C1F"
              },
              {
                "const": "GRAY",
                "title": "GRAY",
                "description": "666666"
              }
            ],
            "title": "Event color",
            "description": "Not included if not specified during event creation or editing."
          }
        },
        "required": [
          "time"
        ],
        "title": "Event"
      },
      "ISecretkakaotalk_calendarcalender_id(stringDefaultprimaryPlaceholderprimaryPrerequisitemethodpostpath/connector/kakao-talk/get-calendarsjmesPathcalendars.valueidlabelnamesubscribe_calendars.valueidlabelname)undefinedpres...": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "calender_id": {
            "type": "string",
            "default": "primary",
            "x-wrtn-placeholder": "primary",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/kakao-talk/get-calendars",
              "jmesPath": "calendars[].{value:id, label: name || ''} || subscribe_calendars[].{value:id, label: name || ''}"
            },
            "title": "Calendar ID to Retrieve Events",
            "description": "Defaults to retrieving all calendars if not specified."
          },
          "preset": {
            "oneOf": [
              {
                "const": "TODAY",
                "title": "The day of the query"
              },
              {
                "const": "THIS_WEEK",
                "title": "The week containing the query date starting on Sunday"
              },
              {
                "const": "THIS_MONTH",
                "title": "The month containing the query date starting on the 1st"
              }
            ],
            "title": "Time Period for Retrieving Events",
            "description": "Required if `from` and `to` are not included, and ignored if `next_page_token` is included."
          },
          "time_zone": {
            "type": "string",
            "title": "Time Zone for Deadline Dates\n\nIn TZID format."
          },
          "limit": {
            "type": "integer",
            "minimum": 100,
            "maximum": 1000,
            "title": "Maximum Number of Events to Receive in Response"
          },
          "from": {
            "type": "string",
            "format": "date-time",
            "title": "Start Time of the Period to Retrieve Events",
            "description": "Required if `from` and `to` are not included and ignored if `next_page_token` is included."
          },
          "to": {
            "type": "string",
            "format": "date-time",
            "title": "End Time of the Period to Retrieve Events",
            "description": "Required if `from` and `to` are not included and ignored if `next_page_token` is included. Must be within 31 days from `to`."
          }
        },
        "required": [
          "secretKey",
          "from",
          "to"
        ]
      },
      "ISecretkakaotalk_calendarcalender_id(stringDefaultprimaryPlaceholderprimaryPrerequisitemethodpostpath/connector/kakao-talk/get-calendarsjmesPathcalendars.valueidlabelnamesubscribe_calendars.valueidlabelname)undefinedpres....o1": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "calender_id": {
            "type": "string",
            "default": "primary",
            "x-wrtn-placeholder": "primary",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/kakao-talk/get-calendars",
              "jmesPath": "calendars[].{value:id, label: name || ''} || subscribe_calendars[].{value:id, label: name || ''}"
            },
            "title": "Calendar ID to Retrieve Events",
            "description": "Defaults to retrieving all calendars if not specified."
          },
          "preset": {
            "oneOf": [
              {
                "const": "TODAY",
                "title": "The day of the query"
              },
              {
                "const": "THIS_WEEK",
                "title": "The week containing the query date starting on Sunday"
              },
              {
                "const": "THIS_MONTH",
                "title": "The month containing the query date starting on the 1st"
              }
            ],
            "title": "Time Period for Retrieving Events",
            "description": "Required if `from` and `to` are not included, and ignored if `next_page_token` is included."
          },
          "time_zone": {
            "type": "string",
            "title": "Time Zone for Deadline Dates\n\nIn TZID format."
          },
          "limit": {
            "type": "integer",
            "minimum": 100,
            "maximum": 1000,
            "title": "Maximum Number of Events to Receive in Response"
          },
          "next_page_token": {
            "type": "string",
            "title": "Token for Pagination",
            "description": "Query condition token including `from`, `to`, and `limit` values, available in the `after_url` received in the response."
          }
        },
        "required": [
          "secretKey",
          "next_page_token"
        ]
      },
      "IKakaoTalk.IGetCalendarOutput": {
        "type": "object",
        "properties": {
          "calendars": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.Calendar"
            },
            "title": "Basic Calendar",
            "description": "Personal calendars.\nAlthough these are personal, they are not limited to just your own events; you can view events from friends' schedules if invited or shared."
          },
          "subscribe_calendars": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoTalk.SubscribeCalendars"
            },
            "title": "List of Subscribed Calendars",
            "description": "Subscription calendars.\nThese are managed in chat rooms where multiple members have created a group. You can view the calendars of the chat rooms you belong to."
          }
        },
        "title": "Talk Calendar",
        "description": "There are two types of calendars in KakaoTalk:\n1. Basic Calendar: This is a personal calendar. While it is personal, it is not limited to viewing only your own events; you can view events shared by friends or events you were invited to.\n2. Subscription Calendar: This is a shared calendar managed by a group of members in a chat room. You can view the calendars of the chat rooms you are part of."
      },
      "IKakaoTalk.Calendar": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "default": "primary",
            "x-wrtn-placeholder": "primary",
            "title": "Calendar ID.\n\nFor calendars that users typically have by default, it is referred to as `primary`."
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "Calendar Name",
            "title": "Calendar Name"
          },
          "color": {
            "oneOf": [
              {
                "const": "BLUE",
                "title": "BLUE",
                "description": "2C88DE"
              },
              {
                "const": "ROYAL_BLUE",
                "title": "ROYAL_BLUE",
                "description": "2D69E0"
              },
              {
                "const": "NAVY_BLUE",
                "title": "NAVY_BLUE",
                "description": "223788"
              },
              {
                "const": "RED",
                "title": "RED",
                "description": "D42726"
              },
              {
                "const": "PINK",
                "title": "PINK",
                "description": "ED5683"
              },
              {
                "const": "ORANGE",
                "title": "ORANGE",
                "description": "FF9429"
              },
              {
                "const": "GREEN",
                "title": "GREEN",
                "description": "149959"
              },
              {
                "const": "LIME",
                "title": "LIME",
                "description": "7CB343"
              },
              {
                "const": "OLIVE",
                "title": "OLIVE",
                "description": "A4AD15"
              },
              {
                "const": "MINT",
                "title": "MINT",
                "description": "5CC5BE"
              },
              {
                "const": "MAGENTA",
                "title": "MAGENTA",
                "description": "AB47BC"
              },
              {
                "const": "VIOLET",
                "title": "VIOLET",
                "description": "8A4B9B"
              },
              {
                "const": "LAVENDER",
                "title": "LAVENDER",
                "description": "7986CB"
              },
              {
                "const": "BROWN",
                "title": "BROWN",
                "description": "945C1F"
              },
              {
                "const": "GRAY",
                "title": "GRAY",
                "description": "666666"
              }
            ],
            "title": "Event Color"
          },
          "reminder": {
            "type": "integer",
            "title": "Default reminder time for non-all-day events"
          },
          "reminder_all_day": {
            "type": "integer",
            "title": "Default reminder time for all-day events"
          }
        },
        "required": [
          "id"
        ],
        "title": "Basic Calendar",
        "description": "List of sub-calendars"
      },
      "IKakaoTalk.SubscribeCalendars": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "title": "Description of the subscribed calendar set by the channel"
          },
          "profile_image_url": {
            "type": "string",
            "format": "url",
            "contentMediaType": "image/*",
            "title": "Profile image URL of the subscribed calendar\n\nIf an empty string appears, it means there is no image."
          },
          "thumbnail_url": {
            "type": "string",
            "format": "url",
            "contentMediaType": "image/*",
            "title": "Thumbnail URL of the subscribed calendar's speech bubble"
          },
          "id": {
            "type": "string",
            "default": "primary",
            "x-wrtn-placeholder": "primary",
            "title": "Calendar ID.\n\nFor calendars that users typically have by default, it is referred to as `primary`."
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "Calendar Name",
            "title": "Calendar Name"
          },
          "color": {
            "oneOf": [
              {
                "const": "BLUE",
                "title": "BLUE",
                "description": "2C88DE"
              },
              {
                "const": "ROYAL_BLUE",
                "title": "ROYAL_BLUE",
                "description": "2D69E0"
              },
              {
                "const": "NAVY_BLUE",
                "title": "NAVY_BLUE",
                "description": "223788"
              },
              {
                "const": "RED",
                "title": "RED",
                "description": "D42726"
              },
              {
                "const": "PINK",
                "title": "PINK",
                "description": "ED5683"
              },
              {
                "const": "ORANGE",
                "title": "ORANGE",
                "description": "FF9429"
              },
              {
                "const": "GREEN",
                "title": "GREEN",
                "description": "149959"
              },
              {
                "const": "LIME",
                "title": "LIME",
                "description": "7CB343"
              },
              {
                "const": "OLIVE",
                "title": "OLIVE",
                "description": "A4AD15"
              },
              {
                "const": "MINT",
                "title": "MINT",
                "description": "5CC5BE"
              },
              {
                "const": "MAGENTA",
                "title": "MAGENTA",
                "description": "AB47BC"
              },
              {
                "const": "VIOLET",
                "title": "VIOLET",
                "description": "8A4B9B"
              },
              {
                "const": "LAVENDER",
                "title": "LAVENDER",
                "description": "7986CB"
              },
              {
                "const": "BROWN",
                "title": "BROWN",
                "description": "945C1F"
              },
              {
                "const": "GRAY",
                "title": "GRAY",
                "description": "666666"
              }
            ],
            "title": "Event Color"
          },
          "reminder": {
            "type": "integer",
            "title": "Default reminder time for non-all-day events"
          },
          "reminder_all_day": {
            "type": "integer",
            "title": "Default reminder time for all-day events"
          }
        },
        "required": [
          "id"
        ],
        "title": "List of Subscribed Calendars"
      },
      "ICommon.ISecretkakaotalk_calendar": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "kakao",
            "x-wrtn-secret-scopes": [
              "talk_calendar"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IKakaoTalk.IGetAccessTokenOutput": {
        "type": "object",
        "properties": {
          "access_token": {
            "type": "string",
            "title": "Access token."
          },
          "token_type": {
            "const": "bearer",
            "title": "Token type."
          },
          "refresh_token": {
            "type": "string",
            "title": "Refresh token."
          },
          "scope": {
            "type": "string",
            "title": "Scope of this access token."
          },
          "expires_in": {
            "type": "number",
            "title": "Expiry time of the access token."
          },
          "refresh_token_expires_in": {
            "type": "number",
            "title": "Expiry time of the refresh token."
          }
        },
        "required": [
          "access_token",
          "token_type",
          "refresh_token",
          "scope",
          "expires_in",
          "refresh_token_expires_in"
        ],
        "title": "DTO for output of access token."
      },
      "IKakaoTalk.IAuthorizationCode": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "title": "KakaoTalk OAuth2 authorization code."
          }
        },
        "required": [
          "code"
        ],
        "title": "DTO for the code received after Kakao login."
      },
      "IKakaoTalk.IRefreshAccessTokenOutput": {
        "type": "object",
        "properties": {
          "access_token": {
            "type": "string",
            "title": "Access token."
          },
          "expires_in": {
            "type": "number",
            "title": "Expiry time of the access token."
          },
          "token_type": {
            "const": "bearer",
            "title": "Token type."
          }
        },
        "required": [
          "access_token",
          "expires_in",
          "token_type"
        ],
        "title": "Refresh Access Token"
      },
      "IKakaoTalk.IRefreshAccessTokenInput": {
        "type": "object",
        "properties": {
          "refresh_token": {
            "type": "string"
          }
        },
        "required": [
          "refresh_token"
        ],
        "title": "Conditions to Refresh Kakao Access Token"
      },
      "IKakaoMap.SearchByKeywordOutput": {
        "type": "object",
        "properties": {
          "documents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoMap.Document"
            },
            "title": "Search Results List"
          },
          "meta": {
            "$ref": "#/components/schemas/IKakaoMap.Meta",
            "title": "meta information"
          }
        },
        "required": [
          "documents",
          "meta"
        ],
        "title": "Search Results"
      },
      "IKakaoMap.Document": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Location ID"
          },
          "place_name": {
            "type": "string",
            "title": "Place name, company name"
          },
          "category_name": {
            "type": "string",
            "title": "Category Name"
          },
          "category_group_code": {
            "oneOf": [
              {
                "const": "MT1",
                "title": "대형마트"
              },
              {
                "const": "CS2",
                "title": "편의점"
              },
              {
                "const": "PS3",
                "title": "어린이집,유치원"
              },
              {
                "const": "SC4",
                "title": "학교"
              },
              {
                "const": "AC5",
                "title": "학원"
              },
              {
                "const": "PK6",
                "title": "주차장"
              },
              {
                "const": "OL7",
                "title": "주유소, 충전소"
              },
              {
                "const": "SW8",
                "title": "지하철역"
              },
              {
                "const": "BK9",
                "title": "은행"
              },
              {
                "const": "CT1",
                "title": "문화시설"
              },
              {
                "const": "AG2",
                "title": "중개업소"
              },
              {
                "const": "PO3",
                "title": "공공기관"
              },
              {
                "const": "AT4",
                "title": "관광명소"
              },
              {
                "const": "AD5",
                "title": "숙박"
              },
              {
                "const": "FD6",
                "title": "음식점"
              },
              {
                "const": "CE7",
                "title": "카페"
              },
              {
                "const": "HP8",
                "title": "병원"
              },
              {
                "const": "PM9",
                "title": "약국"
              },
              {
                "const": "",
                "title": "알 수 없음"
              }
            ],
            "title": "Category group code that groups only important categories"
          },
          "category_group_name": {
            "oneOf": [
              {
                "const": "대형마트",
                "title": "대형마트"
              },
              {
                "const": "편의점",
                "title": "편의점"
              },
              {
                "const": "어린이집,유치원",
                "title": "어린이집,유치원"
              },
              {
                "const": "학교",
                "title": "학교"
              },
              {
                "const": "학원",
                "title": "학원"
              },
              {
                "const": "주차장",
                "title": "주차장"
              },
              {
                "const": "주유소, 충전소",
                "title": "주유소, 충전소"
              },
              {
                "const": "지하철역",
                "title": "지하철역"
              },
              {
                "const": "은행",
                "title": "은행"
              },
              {
                "const": "문화시설",
                "title": "문화시설"
              },
              {
                "const": "중개업소",
                "title": "중개업소"
              },
              {
                "const": "공공기관",
                "title": "공공기관"
              },
              {
                "const": "관광명소",
                "title": "관광명소"
              },
              {
                "const": "숙박",
                "title": "숙박"
              },
              {
                "const": "음식점",
                "title": "음식점"
              },
              {
                "const": "카페",
                "title": "카페"
              },
              {
                "const": "병원",
                "title": "병원"
              },
              {
                "const": "약국",
                "title": "약국"
              },
              {
                "const": "",
                "title": "알 수 없음"
              }
            ],
            "title": "Category group name that groups only important categories"
          },
          "phone": {
            "type": "string",
            "title": "phone number"
          },
          "address_name": {
            "type": "string",
            "title": "Full street address"
          },
          "road_address_name": {
            "type": "string",
            "title": "Full road name address"
          },
          "x": {
            "type": "string",
            "title": "X coordinate value",
            "description": "longitude (longitude) in case of latitude and longitude"
          },
          "y": {
            "type": "string",
            "title": "Y coordinate value",
            "description": "latitude in case of longitude and latitude"
          },
          "place_url": {
            "type": "string",
            "format": "iri",
            "title": "Location details page URL"
          },
          "distance": {
            "type": "string",
            "title": "Distance to the center coordinate",
            "description": "(only exists when x,y parameters are given) Unit meter"
          }
        },
        "required": [
          "id",
          "place_name",
          "category_name",
          "category_group_code",
          "category_group_name",
          "phone",
          "address_name",
          "road_address_name",
          "x",
          "y",
          "place_url",
          "distance"
        ],
        "title": "Search Results"
      },
      "IKakaoMap.Meta": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "integer",
            "title": "Number of documents found for search term"
          },
          "pageable_count": {
            "type": "integer",
            "maximum": 45,
            "title": "Number of documents displayed at once"
          },
          "is_end": {
            "type": "boolean",
            "title": "Whether the current page is the last page",
            "description": "If the value is false, the page value can be increased for the next request to request the next page."
          },
          "same_name": {
            "type": "object",
            "properties": {
              "keyword": {
                "type": "string",
                "title": "Keyword excluding local information from query language",
                "description": "If you search for 'Jungang-ro Restaurant', the value extracted from the part corresponding to 'Restaurant'"
              },
              "region": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "List of regions recognized in the query",
                "description": "If you search for 'Jungang-ro restaurant', the value extracted from the part corresponding to 'Jungang-ro'"
              },
              "selected_region": {
                "type": "string",
                "title": "Local information used in search"
              }
            },
            "required": [
              "keyword",
              "region",
              "selected_region"
            ]
          }
        },
        "required": [
          "total_count",
          "pageable_count",
          "is_end"
        ],
        "title": "meta information"
      },
      "IKakaoMap.SearchByKeywordInput": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "x-wrtn-placeholder": "종로구 맛집",
            "title": "Search Keyword"
          },
          "page": {
            "type": "integer",
            "minimum": 1,
            "maximum": 45,
            "default": 1,
            "title": "Results page number"
          },
          "size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 15,
            "default": 15,
            "title": "Number of documents per page"
          }
        },
        "required": [
          "query"
        ],
        "title": "Search Conditions"
      },
      "IKakaoNavi.SuccessCase": {
        "type": "object",
        "properties": {
          "trans_id": {
            "type": "string",
            "title": "Path Request ID"
          },
          "routes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoNavi.Route"
            },
            "title": "Path information"
          }
        },
        "required": [
          "trans_id",
          "routes"
        ],
        "title": "Success response"
      },
      "IKakaoNavi.Route": {
        "type": "object",
        "properties": {
          "result_code": {
            "oneOf": [
              {
                "const": 0,
                "title": "길찾기 성공"
              },
              {
                "const": 1,
                "title": "길찾기 결과를 찾을 수 없음"
              },
              {
                "const": 101,
                "title": "경유지 지점 주변의 도로를 탐색할 수 없음"
              },
              {
                "const": 102,
                "title": "시작 지점 주변의 도로를 탐색할 수 없음"
              },
              {
                "const": 103,
                "title": "도착 지점 주변의 도로를 탐색할 수 없음"
              },
              {
                "const": 104,
                "title": "출발지와 도착지가 5 m 이내로 설정된 경우 경로를 탐색할 수 없음"
              },
              {
                "const": 105,
                "title": "시작 지점 주변의 도로에 유고 정보(교통 장애)가 있음"
              },
              {
                "const": 106,
                "title": "도착 지점 주변의 도로에 유고 정보(교통 장애)가 있음"
              },
              {
                "const": 107,
                "title": "경유지 주변의 도로에 유고 정보(교통 장애)가 있음."
              },
              {
                "const": 201,
                "title": "다중 출발지: 출발지가 탐색 영역에 포함되지 않음"
              },
              {
                "const": 202,
                "title": "다중 출발지: 출발지 최대 개수 초과 도로 선택 실패"
              },
              {
                "const": 203,
                "title": "다중 출발지: 목적지 도로 선택 실패"
              },
              {
                "const": 204,
                "title": "다중 출발지: 경로 탐색 처리 시간 제한"
              },
              {
                "const": 205,
                "title": "다중 출발지: 출발지 주변의 유고 정보(교통 장애)로 인한 통행 불가"
              },
              {
                "const": 206,
                "title": "다중 출발지: 목적지 주변의 유고 정보(교통 장애)로 인한 통행 불가"
              },
              {
                "const": 207,
                "title": "다중 출발지: 출발지가 설정한 길찾기 반경 범위를 벗어남"
              },
              {
                "const": 301,
                "title": "다중 목적지: 출발지 도로 선택 실패"
              },
              {
                "const": 302,
                "title": "다중 목적지: 목적지 도로 선택 실패"
              },
              {
                "const": 303,
                "title": "다중 목적지: 목적지 최대 개수 초과로 인해 경로 탐색 실패"
              },
              {
                "const": 304,
                "title": "다중 목적지: 목적지가 설정한 길찾기 반경 범위를 벗어남"
              }
            ],
            "title": "Path search result code"
          },
          "result_msg": {
            "type": "string",
            "title": "Path search result message"
          },
          "summary": {
            "$ref": "#/components/schemas/IKakaoNavi.Summary",
            "title": "Path Summary Information"
          },
          "sections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoNavi.Section"
            },
            "title": "Route information by section"
          }
        },
        "required": [
          "result_code",
          "result_msg"
        ]
      },
      "IKakaoNavi.Summary": {
        "type": "object",
        "properties": {
          "origin": {
            "$ref": "#/components/schemas/IKakaoNavi.Place",
            "title": "Departure information"
          },
          "destination": {
            "$ref": "#/components/schemas/IKakaoNavi.Place",
            "title": "destination information"
          },
          "waypoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoNavi.Place"
            },
            "title": "Transit Information"
          },
          "priority": {
            "type": "string",
            "title": "Path Finding Priority Options"
          },
          "fare": {
            "$ref": "#/components/schemas/IKakaoNavi.Fare",
            "title": "Rate Information"
          },
          "duration": {
            "type": "integer",
            "title": "Full search results move time (seconds)"
          },
          "bound": {
            "$ref": "#/components/schemas/IKakaoNavi.Bound",
            "title": "A rectangular bounding box that contains all paths"
          },
          "distance": {
            "type": "integer",
            "title": "Section Distance (meters)"
          }
        },
        "required": [
          "origin",
          "destination",
          "waypoints",
          "priority",
          "fare",
          "duration",
          "bound",
          "distance"
        ]
      },
      "IKakaoNavi.Place": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "place name"
          },
          "x": {
            "type": "number",
            "title": "X coordinate (longitude)"
          },
          "y": {
            "type": "number",
            "title": "Y coordinate (latitude)"
          }
        },
        "required": [
          "name",
          "x",
          "y"
        ]
      },
      "IKakaoNavi.Fare": {
        "type": "object",
        "properties": {
          "taxi": {
            "type": "number",
            "title": "Taxi fare (won)"
          },
          "toll": {
            "type": "number",
            "title": "Toll fee (won)"
          }
        },
        "required": [
          "taxi",
          "toll"
        ],
        "title": "Rate Information"
      },
      "IKakaoNavi.Bound": {
        "type": "object",
        "properties": {
          "min_x": {
            "type": "number",
            "title": "X coordinate of the bottom left of the bounding box"
          },
          "min_y": {
            "type": "number",
            "title": "Y coordinate of the bottom left of the bounding box"
          },
          "max_x": {
            "type": "number",
            "title": "X coordinate of the upper right corner of the bounding box"
          },
          "max_y": {
            "type": "number",
            "title": "Y coordinate of the upper right corner of the bounding box"
          }
        },
        "required": [
          "min_x",
          "min_y",
          "max_x",
          "max_y"
        ],
        "title": "Bounding box of a rectangle containing all paths"
      },
      "IKakaoNavi.Section": {
        "type": "object",
        "properties": {
          "distance": {
            "type": "integer",
            "title": "Section Distance (meters)"
          },
          "duration": {
            "type": "integer",
            "title": "Full search results move time (seconds)"
          },
          "bound": {
            "$ref": "#/components/schemas/IKakaoNavi.Bound",
            "title": "A rectangular bounding box that contains all paths"
          },
          "roads": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoNavi.Road"
            },
            "title": "Road Information"
          },
          "guides": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IKakaoNavi.Guide"
            },
            "title": "Guide Information"
          }
        },
        "required": [
          "distance",
          "duration",
          "bound"
        ],
        "title": "Route information by section",
        "description": "If there is a waypoint, a section is created equal to the number of waypoints plus 1."
      },
      "IKakaoNavi.Road": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "road name"
          },
          "distance": {
            "type": "integer",
            "title": "Road length (meters)"
          },
          "duration": {
            "type": "integer",
            "title": "Estimated travel time (sec)",
            "description": "Current estimated travel time and actual travel time are set to the same value"
          },
          "traffic_speed": {
            "type": "number",
            "title": "Current traffic information speed (km/h)"
          },
          "traffic_state": {
            "oneOf": [
              {
                "const": 0,
                "title": "교통 상태 정보 없음"
              },
              {
                "const": 1,
                "title": "교통 정체"
              },
              {
                "const": 2,
                "title": "교통 지체"
              },
              {
                "const": 3,
                "title": "교통 서행"
              },
              {
                "const": 4,
                "title": "교통 원활"
              },
              {
                "const": 6,
                "title": "교통사고(통행 불가)"
              }
            ],
            "title": "Current traffic information status"
          },
          "vertexes": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "title": "A one-dimensional array consisting of X, Y coordinates"
          }
        },
        "required": [
          "name",
          "distance",
          "duration",
          "traffic_speed",
          "traffic_state",
          "vertexes"
        ],
        "title": "Road Information"
      },
      "IKakaoNavi.Guide": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": 0,
                "title": "직진"
              },
              {
                "const": 1,
                "title": "좌회전"
              },
              {
                "const": 2,
                "title": "우회전"
              },
              {
                "const": 3,
                "title": "유턴"
              },
              {
                "const": 5,
                "title": "왼쪽 방향"
              },
              {
                "const": 6,
                "title": "오른쪽 방향"
              },
              {
                "const": 7,
                "title": "고속 도로 출구"
              },
              {
                "const": 8,
                "title": "왼쪽에 고속 도로 출구"
              },
              {
                "const": 9,
                "title": "오른쪽에 고속 도로 출구"
              },
              {
                "const": 10,
                "title": "고속 도로 입구"
              },
              {
                "const": 11,
                "title": "왼쪽에 고속 도로 입구"
              },
              {
                "const": 12,
                "title": "오른쪽에 고속 도로 입구"
              },
              {
                "const": 14,
                "title": "고가 도로 진입"
              },
              {
                "const": 15,
                "title": "지하 차도 진입"
              },
              {
                "const": 16,
                "title": "고가 도로 옆길"
              },
              {
                "const": 17,
                "title": "지하 차도 옆길"
              },
              {
                "const": 18,
                "title": "오른쪽 1시 방향"
              },
              {
                "const": 19,
                "title": "오른쪽 2시 방향"
              },
              {
                "const": 20,
                "title": "오른쪽 3시 방향"
              },
              {
                "const": 21,
                "title": "오른쪽 4시 방향"
              },
              {
                "const": 22,
                "title": "오른쪽 5시 방향"
              },
              {
                "const": 23,
                "title": "6시 방향"
              },
              {
                "const": 24,
                "title": "왼쪽 7시 방향"
              },
              {
                "const": 25,
                "title": "왼쪽 8시 방향"
              },
              {
                "const": 26,
                "title": "왼쪽 9시 방향"
              },
              {
                "const": 27,
                "title": "왼쪽 10시 방향"
              },
              {
                "const": 28,
                "title": "왼쪽 11시 방향"
              },
              {
                "const": 29,
                "title": "12시 방향"
              },
              {
                "const": 30,
                "title": "로터리에서 오른쪽 1시 방향"
              },
              {
                "const": 31,
                "title": "로터리에서 오른쪽 2시 방향"
              },
              {
                "const": 32,
                "title": "로터리에서 오른쪽 3시 방향"
              },
              {
                "const": 33,
                "title": "로터리에서 오른쪽 4시 방향"
              },
              {
                "const": 34,
                "title": "로터리에서 오른쪽 5시 방향"
              },
              {
                "const": 35,
                "title": "로터리에서 6시 방향"
              },
              {
                "const": 36,
                "title": "로터리에서 왼쪽 7시 방향"
              },
              {
                "const": 37,
                "title": "로터리에서 왼쪽 8시 방향"
              },
              {
                "const": 38,
                "title": "로터리에서 왼쪽 9시 방향"
              },
              {
                "const": 39,
                "title": "로터리에서 왼쪽 10시 방향"
              },
              {
                "const": 40,
                "title": "로터리에서 왼쪽 11시 방향"
              },
              {
                "const": 41,
                "title": "로터리에서 12시 방향"
              },
              {
                "const": 42,
                "title": "도시 고속 도로 출구"
              },
              {
                "const": 43,
                "title": "왼쪽에 도시 고속 도로 출구"
              },
              {
                "const": 44,
                "title": "오른쪽에 도시 고속 도로 출구"
              },
              {
                "const": 45,
                "title": "도시 고속 도로 입구"
              },
              {
                "const": 46,
                "title": "왼쪽에 도시 고속 도로 입구"
              },
              {
                "const": 47,
                "title": "오른쪽에 도시 고속 도로 입구"
              },
              {
                "const": 48,
                "title": "왼쪽 고속 도로 진입"
              },
              {
                "const": 49,
                "title": "오른쪽 고속 도로 진입"
              },
              {
                "const": 61,
                "title": "페리 항로 진입"
              },
              {
                "const": 62,
                "title": "페리 항로 진출"
              },
              {
                "const": 70,
                "title": "회전 교차로에서 오른쪽 1시 방향"
              },
              {
                "const": 71,
                "title": "회전 교차로에서 오른쪽 2시 방향"
              },
              {
                "const": 72,
                "title": "회전 교차로에서 오른쪽 3시 방향"
              },
              {
                "const": 73,
                "title": "회전 교차로에서 오른쪽 4시 방향"
              },
              {
                "const": 74,
                "title": "회전 교차로에서 오른쪽 5시 방향"
              },
              {
                "const": 75,
                "title": "회전 교차로에서 6시 방향"
              },
              {
                "const": 76,
                "title": "회전 교차로에서 왼쪽 7시 방향"
              },
              {
                "const": 77,
                "title": "회전 교차로에서 왼쪽 8시 방향"
              },
              {
                "const": 78,
                "title": "회전 교차로에서 왼쪽 9시 방향"
              },
              {
                "const": 79,
                "title": "회전 교차로에서 왼쪽 10시 방향"
              },
              {
                "const": 80,
                "title": "회전 교차로에서 왼쪽 11시 방향"
              },
              {
                "const": 81,
                "title": "회전 교차로에서 12시 방향"
              },
              {
                "const": 82,
                "title": "왼쪽 직진"
              },
              {
                "const": 83,
                "title": "오른쪽 직진"
              },
              {
                "const": 84,
                "title": "톨게이트 진입"
              },
              {
                "const": 85,
                "title": "원톨링 진입"
              },
              {
                "const": 86,
                "title": "분기 후 합류 구간 진입"
              },
              {
                "const": 100,
                "title": "출발지"
              },
              {
                "const": 101,
                "title": "목적지"
              },
              {
                "const": 300,
                "title": "톨게이트"
              },
              {
                "const": 301,
                "title": "휴게소"
              },
              {
                "const": 1000,
                "title": "경유지"
              }
            ],
            "title": "Guide type"
          },
          "guidance": {
            "type": "string",
            "title": "Guide text"
          },
          "road_index": {
            "type": "integer",
            "title": "Link index for the current guide"
          },
          "name": {
            "type": "string",
            "title": "place name"
          },
          "x": {
            "type": "number",
            "title": "X coordinate (longitude)"
          },
          "y": {
            "type": "number",
            "title": "Y coordinate (latitude)"
          },
          "duration": {
            "type": "integer",
            "title": "Full search results move time (seconds)"
          },
          "distance": {
            "type": "integer",
            "title": "Section Distance (meters)"
          }
        },
        "required": [
          "type",
          "guidance",
          "road_index",
          "name",
          "x",
          "y",
          "duration",
          "distance"
        ],
        "title": "Guide information"
      },
      "IKakaoNavi.IGetFutureDirectionsInput": {
        "type": "object",
        "properties": {
          "departure_time": {
            "type": "string",
            "x-wrtn-placeholder": "202406202000",
            "title": "Departure time",
            "description": "Set time after current time in YYYYMMDDHHMM format"
          },
          "origin": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?,[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "127.111202,37.394912",
            "title": "Origin",
            "description": "Longitude and latitude values in X, Y coordinate format"
          },
          "destination": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?,[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "127.111202,37.394912",
            "title": "Destination",
            "description": "Longitude and latitude values in X, Y coordinate format"
          }
        },
        "required": [
          "departure_time",
          "origin",
          "destination"
        ],
        "title": "Request Conditions"
      },
      "IGoogleSlides.IExportHanshowOutput": {
        "type": "object",
        "properties": {
          "hanshow": {
            "type": "string",
            "format": "uri",
            "title": "File download link"
          }
        },
        "required": [
          "hanshow"
        ]
      },
      "IGoogleSlides.IExportPresentationInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/drive"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Conditions for exporting slides to pptx"
      },
      "IGoogleSlides.IExportPresentationOutput": {
        "type": "object",
        "properties": {
          "powerPoint": {
            "type": "string",
            "format": "uri",
            "title": "File download link"
          }
        },
        "required": [
          "powerPoint"
        ]
      },
      "IGoogleSlides.ISimplePresentationIdOutput": {
        "type": "object",
        "properties": {
          "title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The title of the presentation."
          },
          "pageSize": {
            "$ref": "#/components/schemas/IGoogleSlides.Size",
            "title": "The page size of the presentation."
          },
          "presentationId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Presentation ID."
          }
        }
      },
      "IGoogleSlides.Size": {
        "type": "object",
        "properties": {
          "width": {
            "$ref": "#/components/schemas/IGoogleSlides.Dimension",
            "title": "Width of the object."
          },
          "height": {
            "$ref": "#/components/schemas/IGoogleSlides.Dimension",
            "title": "The height of the object."
          }
        }
      },
      "IGoogleSlides.Dimension": {
        "type": "object",
        "properties": {
          "magnitude": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "scale."
          },
          "unit": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "UNIT_UNSPECIFIED",
                "title": "알 수 없는 단위"
              },
              {
                "const": "EMU",
                "title": "영국식 단위 (EMU)",
                "description": "는 1센티미터의 1/360,000으로 정의되므로 인치당 914,400 EMU 및 포인트당 12,700 EMU가 있습니다."
              },
              {
                "const": "PT",
                "title": "포인트",
                "description": "1/72인치입니다."
              }
            ],
            "title": "Size units."
          }
        }
      },
      "IGoogleSlides.IGetPresentationInput": {
        "type": "object",
        "properties": {
          "presentationId": {
            "type": "string",
            "title": "The presentation ID to search for."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/presentations"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "presentationId",
          "secretKey"
        ],
        "title": "Condition DTO for presentation search."
      },
      "IGoogleSlides.AppendQuarterDivisionSlideInput": {
        "type": "object",
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGoogleSlides.Template.QuarterDivisiontype"
            },
            "title": "templates\n\nAs a slide to add, this template arrangement consists of the same type of template.\nTemplates have unconditional text except for the Entire type, and the image and text are paired.\nWhen the user creates a storyline, the text may be concise, but if it means a fairy tale book, a cartoon, or a speech bubble,\nit is better to substitute a text of sufficient length to grasp the context of the story even if viewed again later."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/presentations"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "templates",
          "secretKey"
        ]
      },
      "StrictOmitIGoogleSlides.Template.QuarterDivisiontype": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "url": {
                  "type": "string",
                  "format": "iri",
                  "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
                },
                "text": {
                  "$ref": "#/components/schemas/IGoogleSlides.InsertText",
                  "title": "Text corresponding to the image."
                }
              },
              "required": [
                "url",
                "text"
              ]
            },
            "minItems": 4,
            "maxItems": 4,
            "title": "Contents of the slide\n\nHere, like a four-cut cartoon, four images and four texts must be put in, so the length of the arrangement must be 4.\nTherefore, you must prepare in advance by receiving or generating four images."
          }
        },
        "required": [
          "contents"
        ]
      },
      "IGoogleSlides.InsertText": {
        "type": "object",
        "properties": {
          "text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "minLength": 1
              }
            ],
            "title": "Text to add"
          },
          "objectId": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "ID"
          }
        }
      },
      "IGoogleSlides.AppendEntireSlideInput": {
        "type": "object",
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGoogleSlides.Template.Entiretype"
            },
            "title": "templates\n\nAs a slide to add, this template arrangement consists of the same type of template.\nTemplates have unconditional text except for the Entire type, and the image and text are paired.\nWhen the user creates a storyline, the text may be concise, but if it means a fairy tale book, a cartoon, or a speech bubble,\nit is better to substitute a text of sufficient length to grasp the context of the story even if viewed again later."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/presentations"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "templates",
          "secretKey"
        ]
      },
      "StrictOmitIGoogleSlides.Template.Entiretype": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
              }
            },
            "required": [
              "url"
            ],
            "title": "Contents of the slide"
          }
        },
        "required": [
          "contents"
        ]
      },
      "IGoogleSlides.AppendLandscapeSlideInput": {
        "type": "object",
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGoogleSlides.Template.Landscapetype"
            },
            "title": "templates\n\nAs a slide to add, this template arrangement consists of the same type of template.\nTemplates have unconditional text except for the Entire type, and the image and text are paired.\nWhen the user creates a storyline, the text may be concise, but if it means a fairy tale book, a cartoon, or a speech bubble,\nit is better to substitute a text of sufficient length to grasp the context of the story even if viewed again later."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/presentations"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "templates",
          "secretKey"
        ]
      },
      "StrictOmitIGoogleSlides.Template.Landscapetype": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
              },
              "text": {
                "$ref": "#/components/schemas/IGoogleSlides.InsertText",
                "title": "Text corresponding to the image."
              }
            },
            "required": [
              "url",
              "text"
            ],
            "title": "Contents of the slide"
          }
        },
        "required": [
          "contents"
        ]
      },
      "IGoogleSlides.AppendSquareSlideInput": {
        "type": "object",
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGoogleSlides.Template.Squaretype"
            },
            "title": "templates\n\nAs a slide to add, this template arrangement consists of the same type of template.\nTemplates have unconditional text except for the Entire type, and the image and text are paired.\nWhen the user creates a storyline, the text may be concise, but if it means a fairy tale book, a cartoon, or a speech bubble,\nit is better to substitute a text of sufficient length to grasp the context of the story even if viewed again later."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/presentations"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "templates",
          "secretKey"
        ]
      },
      "StrictOmitIGoogleSlides.Template.Squaretype": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
              },
              "text": {
                "$ref": "#/components/schemas/IGoogleSlides.InsertText",
                "title": "Text corresponding to the image."
              }
            },
            "required": [
              "url",
              "text"
            ],
            "title": "Contents of the slide"
          }
        },
        "required": [
          "contents"
        ]
      },
      "IGoogleSlides.AppendVerticalSlideInput": {
        "type": "object",
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGoogleSlides.Template.Verticaltype"
            },
            "title": "templates\n\nAs a slide to add, this template arrangement consists of the same type of template.\nTemplates have unconditional text except for the Entire type, and the image and text are paired.\nWhen the user creates a storyline, the text may be concise, but if it means a fairy tale book, a cartoon, or a speech bubble,\nit is better to substitute a text of sufficient length to grasp the context of the story even if viewed again later."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/presentations"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "templates",
          "secretKey"
        ]
      },
      "StrictOmitIGoogleSlides.Template.Verticaltype": {
        "type": "object",
        "properties": {
          "contents": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
              },
              "text": {
                "$ref": "#/components/schemas/IGoogleSlides.InsertText",
                "title": "Text corresponding to the image."
              }
            },
            "required": [
              "url",
              "text"
            ],
            "title": "Contents of the slide"
          }
        },
        "required": [
          "contents"
        ]
      },
      "IGoogleSlides.AppendSlideInput": {
        "type": "object",
        "properties": {
          "templates": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IGoogleSlides.Template.Vertical"
                },
                {
                  "$ref": "#/components/schemas/IGoogleSlides.Template.Square"
                },
                {
                  "$ref": "#/components/schemas/IGoogleSlides.Template.Landscape"
                },
                {
                  "$ref": "#/components/schemas/IGoogleSlides.Template.Entire"
                },
                {
                  "$ref": "#/components/schemas/IGoogleSlides.Template.QuarterDivision"
                }
              ],
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "Vertical": "#/components/schemas/IGoogleSlides.Template.Vertical",
                  "Square": "#/components/schemas/IGoogleSlides.Template.Square",
                  "Landscape": "#/components/schemas/IGoogleSlides.Template.Landscape",
                  "Entire": "#/components/schemas/IGoogleSlides.Template.Entire",
                  "QuarterDivision": "#/components/schemas/IGoogleSlides.Template.QuarterDivision"
                }
              }
            },
            "title": "A list of templates to create at once.",
            "description": "When creating a story or picture book, please use only squares."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/presentations"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "templates",
          "secretKey"
        ],
        "title": "Request DTO for pasting slides."
      },
      "IGoogleSlides.Template.Vertical": {
        "type": "object",
        "properties": {
          "type": {
            "const": "Vertical",
            "title": "The type of the template.\n\ntype must be \"Vertical\""
          },
          "contents": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
              },
              "text": {
                "$ref": "#/components/schemas/IGoogleSlides.InsertText",
                "title": "Text corresponding to the image."
              }
            },
            "required": [
              "url",
              "text"
            ],
            "title": "Contents of the slide"
          }
        },
        "required": [
          "type",
          "contents"
        ],
        "title": "vertical"
      },
      "IGoogleSlides.Template.Square": {
        "type": "object",
        "properties": {
          "type": {
            "const": "Square",
            "title": "The type of the template.\n\ntype must be \"Square\"."
          },
          "contents": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
              },
              "text": {
                "$ref": "#/components/schemas/IGoogleSlides.InsertText",
                "title": "Text corresponding to the image."
              }
            },
            "required": [
              "url",
              "text"
            ],
            "title": "Contents of the slide"
          }
        },
        "required": [
          "type",
          "contents"
        ],
        "title": "Square",
        "description": "When creating a story or picture book, please use only squares."
      },
      "IGoogleSlides.Template.Landscape": {
        "type": "object",
        "properties": {
          "type": {
            "const": "Landscape",
            "title": "The type of the template.\n\ntype must be \"Landscape\"."
          },
          "contents": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
              },
              "text": {
                "$ref": "#/components/schemas/IGoogleSlides.InsertText",
                "title": "Text corresponding to the image."
              }
            },
            "required": [
              "url",
              "text"
            ],
            "title": "Contents of the slide"
          }
        },
        "required": [
          "type",
          "contents"
        ],
        "title": "Horizontal"
      },
      "IGoogleSlides.Template.Entire": {
        "type": "object",
        "properties": {
          "type": {
            "const": "Entire",
            "title": "The type of the template.\n\ntype must be \"Entire\"."
          },
          "contents": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
              }
            },
            "required": [
              "url"
            ],
            "title": "Contents of the slide"
          }
        },
        "required": [
          "type",
          "contents"
        ],
        "title": "View all Horizontal (16:9)"
      },
      "IGoogleSlides.Template.QuarterDivision": {
        "type": "object",
        "properties": {
          "type": {
            "const": "QuarterDivision",
            "title": "The type of the template.\n\ntype must be \"QuarterDivision\"."
          },
          "contents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "url": {
                  "type": "string",
                  "format": "iri",
                  "title": "URL of the image\n\nIf there is a problem with the image, the message below may appear.\nYou must insert only existing images, and if the image is too small, you can spit out errors, so insert an image of the appropriate size or create it yourself to insert the image.\nThe first error below is when the image does not exist, and the second is when the size or format of the image is not valid. The image must be in jpg, jpeg, and png formats.\n\n1. The provided image was not found.\n2. There was a problem retrieving the image. The provided image should be publicly accessible, within size limit, and in supported formats."
                },
                "text": {
                  "$ref": "#/components/schemas/IGoogleSlides.InsertText",
                  "title": "Text corresponding to the image."
                }
              },
              "required": [
                "url",
                "text"
              ]
            },
            "minItems": 4,
            "maxItems": 4,
            "title": "Contents of the slide\n\nHere, like a four-cut cartoon, four images and four texts must be put in, so the length of the arrangement must be 4.\nTherefore, you must prepare in advance by receiving or generating four images."
          }
        },
        "required": [
          "type",
          "contents"
        ],
        "title": "4-part square (cut cartoon type)"
      },
      "IGoogleSlides.ICreatePresentationInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/presentations"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "title": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "The title of the presentation."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Request DTO for generating a presentation in Google Slides."
      },
      "IImweb.Product": {
        "type": "object",
        "properties": {
          "no": {
            "type": "number",
            "title": "Product number"
          },
          "prod_status": {
            "oneOf": [
              {
                "const": "sale",
                "title": "판매중"
              },
              {
                "const": "soldout",
                "title": "품절"
              },
              {
                "const": "nosale",
                "title": "숨김"
              }
            ],
            "title": "Status of product"
          },
          "categories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Category codes"
          },
          "custom_prod_code": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Custom product code"
          },
          "name": {
            "type": "string",
            "title": "Name of product"
          },
          "images": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "File code of product images"
          },
          "image_url": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iri",
              "contentMediaType": "image/*"
            },
            "title": "File urls\n\nCan't call it right away because it's not a completed URL."
          },
          "content": {
            "type": "string",
            "title": "Detailed description"
          },
          "simple_content": {
            "type": "string",
            "title": "Simple description of product's content",
            "description": "Text that contains html tags and is generally difficult to use"
          },
          "simple_content_plain": {
            "type": "string",
            "title": "Simple description of product's content",
            "description": "Pure string except html tag"
          },
          "use_mobile_prod_content": {
            "type": "boolean",
            "title": "Whether or not mobile details are used"
          },
          "mobile_content": {
            "type": "string",
            "title": "Description of mobile details"
          },
          "prod_type": {
            "oneOf": [
              {
                "const": "normal",
                "title": "일반 상품"
              },
              {
                "const": "digital",
                "title": "디지털 상품"
              },
              {
                "const": "subscribe",
                "title": "회원그룹 이용권"
              }
            ],
            "title": "Setting the sales method\n\nIt will be 'normal', 'digital' and 'subscribe' product."
          },
          "prod_type_data": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IImweb.ProdTypeData.DigitalData"
                },
                {
                  "$ref": "#/components/schemas/IImweb.ProdTypeData.SubscribeData"
                }
              ]
            },
            "title": "Sales method data"
          },
          "use_pre_sale": {
            "type": "boolean",
            "title": "Whether the sales period is set or not"
          },
          "pre_sale_start_date": {
            "type": "number",
            "title": "Timestamp for sale"
          },
          "pre_sale_end_date": {
            "type": "number",
            "title": "Timestamp is the end of the sale period"
          },
          "price": {
            "type": "number",
            "title": "Price"
          },
          "price_org": {
            "type": "number",
            "title": "The price before the discount\n\nTo provide an experience as if the product was discounted,\nthe seller can also set the original price of the product differently from the actual price it sells.\nThis is a common sales promotion strategy in commerce."
          },
          "price_tax": {
            "type": "boolean",
            "title": "Whether taxes are included or not"
          },
          "price_none": {
            "type": "boolean",
            "title": "Whether or not there is no price"
          },
          "point": {
            "$ref": "#/components/schemas/IImweb.PointConfigData",
            "title": "Set up a reserve"
          },
          "product_discount_options": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "coupon",
                  "title": "Coupon"
                },
                {
                  "const": "point",
                  "title": "Points"
                },
                {
                  "const": "shopping_group_dc",
                  "title": "Shopping Group Discount"
                }
              ]
            },
            "title": "Set Discount Usage."
          },
          "weight": {
            "type": "string",
            "title": "Product Weight"
          },
          "stock": {
            "$ref": "#/components/schemas/IImweb.ProdStockConfigData",
            "title": "Product Stock Information"
          },
          "origin": {
            "type": "string",
            "title": "Origin"
          },
          "maker": {
            "type": "string",
            "title": "Manufacturer"
          },
          "brand": {
            "type": "string",
            "title": "Brand"
          },
          "badge": {
            "$ref": "#/components/schemas/IImweb.ProdBadgeData",
            "title": "Badge Information"
          },
          "sync": {
            "$ref": "#/components/schemas/IImweb.ProdSyncData",
            "title": "External Integration Information"
          },
          "etc": {
            "$ref": "#/components/schemas/IImweb.ProdEtcData",
            "title": "Miscellaneous Settings"
          },
          "prodinfo": {
            "type": "array",
            "items": {},
            "title": "Product Information Disclosure\n\nType is not specified, so it is denoted as an array of `any`."
          },
          "is_exist_options": {
            "oneOf": [
              {
                "const": "Y",
                "title": "Options Exist"
              },
              {
                "const": "N",
                "title": "Single Product"
              }
            ],
            "title": "Existence of Product Options"
          },
          "is_mix": {
            "oneOf": [
              {
                "const": "Y",
                "title": "Combination Option"
              },
              {
                "const": "N",
                "title": "Single Option"
              }
            ],
            "title": "Combination Option for Product"
          },
          "add_time": {
            "type": "number",
            "title": "Product Add Time Timestamp"
          },
          "edit_time": {
            "type": "number",
            "title": "Product Last Edit Time Timestamp"
          }
        },
        "required": [
          "no",
          "prod_status",
          "categories",
          "custom_prod_code",
          "name",
          "images",
          "image_url",
          "content",
          "simple_content",
          "simple_content_plain",
          "use_mobile_prod_content",
          "prod_type",
          "use_pre_sale",
          "price",
          "price_tax",
          "price_none",
          "point",
          "product_discount_options",
          "weight",
          "stock",
          "origin",
          "maker",
          "brand",
          "badge",
          "sync",
          "etc",
          "prodinfo",
          "is_exist_options",
          "is_mix",
          "add_time",
          "edit_time"
        ]
      },
      "IImweb.ProdTypeData.DigitalData": {
        "type": "object",
        "properties": {
          "use_limit": {
            "type": "boolean",
            "title": "Download Limit Setting"
          },
          "period": {
            "type": "integer",
            "title": "Period Limit"
          },
          "maximum": {
            "type": "integer",
            "title": "Usage Limit"
          }
        },
        "required": [
          "use_limit",
          "period",
          "maximum"
        ]
      },
      "IImweb.ProdTypeData.SubscribeData": {
        "type": "object",
        "properties": {
          "group_code": {
            "type": "string",
            "title": "Target Group Code"
          },
          "period": {
            "type": "integer",
            "title": "Group Retention Period (Days)"
          }
        },
        "required": [
          "group_code",
          "period"
        ]
      },
      "IImweb.PointConfigData": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "common",
                "title": "Default Settings"
              },
              {
                "const": "individual",
                "title": "Individual Point Settings"
              }
            ],
            "title": "Point Configuration Type"
          },
          "value_type": {
            "oneOf": [
              {
                "const": "percent",
                "title": "Percentage"
              },
              {
                "const": "price",
                "title": "Currency Unit"
              }
            ],
            "title": "Point Accumulation Unit"
          },
          "value": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Point Value\n\nCalculated as a percentage if `value_type` is percent"
          }
        },
        "required": [
          "type"
        ],
        "title": "Point Configuration Data Structure"
      },
      "IImweb.ProdStockConfigData": {
        "type": "object",
        "properties": {
          "stock_use": {
            "type": "boolean",
            "title": "Use Stock"
          },
          "stock_unlimit": {
            "type": "boolean",
            "title": "Allow Orders After Stock Depletion"
          },
          "stock_no_option": {
            "oneOf": [
              {
                "const": ""
              },
              {
                "type": "integer"
              }
            ],
            "title": "Product Stock Quantity"
          },
          "sku_no_option": {
            "oneOf": [
              {
                "const": ""
              },
              {
                "type": "integer"
              }
            ],
            "title": "Product Stock Number (SKU)"
          }
        },
        "required": [
          "stock_use",
          "stock_unlimit",
          "stock_no_option",
          "sku_no_option"
        ],
        "title": "Product Stock Information Data Structure"
      },
      "IImweb.ProdBadgeData": {
        "type": "object",
        "properties": {
          "new": {
            "type": "boolean",
            "title": "New Product"
          },
          "best": {
            "type": "boolean",
            "title": "Best Product"
          },
          "md": {
            "type": "boolean",
            "title": "MD Recommended"
          },
          "hot": {
            "type": "boolean",
            "title": "High Demand"
          }
        },
        "required": [
          "new",
          "best",
          "md",
          "hot"
        ],
        "title": "Badge Information Data Structure"
      },
      "IImweb.ProdSyncData": {
        "type": "object",
        "properties": {
          "pay_product_name": {
            "type": "string",
            "title": "Product Name for Naver and Kakao Shopping Exposure"
          },
          "event_words": {
            "type": "string",
            "title": "Naver Shopping Event Phrase"
          },
          "naver_category": {
            "type": "string",
            "title": "Naver Shopping Category ID"
          },
          "product_flag": {
            "oneOf": [
              {
                "const": "소매",
                "title": "Retail"
              },
              {
                "const": "도매",
                "title": "Wholesale"
              },
              {
                "const": "렌탈",
                "title": "Rental"
              },
              {
                "const": "대여",
                "title": "Lease"
              },
              {
                "const": "할부",
                "title": "Installment"
              },
              {
                "const": "예약판매",
                "title": "Pre-order"
              },
              {
                "const": "구매대행",
                "title": "Buying Agent"
              }
            ],
            "title": "Naver Shopping Sales Method"
          },
          "product_condition": {
            "oneOf": [
              {
                "const": "신상품",
                "title": "New"
              },
              {
                "const": "중고",
                "title": "Used"
              },
              {
                "const": "리퍼",
                "title": "Refurbished"
              },
              {
                "const": "전시",
                "title": "Exhibition"
              },
              {
                "const": "반품",
                "title": "Returned"
              },
              {
                "const": "스크래치",
                "title": "Scratch"
              }
            ],
            "title": "Naver Shopping Product Condition"
          },
          "import_flag": {
            "type": "boolean",
            "title": "Overseas Buying Agent"
          },
          "parallel_import": {
            "type": "boolean",
            "title": "Parallel Import"
          },
          "is_culture_benefit": {
            "type": "boolean",
            "title": "Cultural Performance Income Deduction"
          },
          "order_made": {
            "type": "boolean",
            "title": "Made to Order"
          }
        },
        "required": [
          "pay_product_name",
          "event_words",
          "naver_category",
          "product_flag",
          "product_condition",
          "import_flag",
          "parallel_import",
          "is_culture_benefit",
          "order_made"
        ],
        "title": "External Integration Information Data Structure"
      },
      "IImweb.ProdEtcData": {
        "type": "object",
        "properties": {
          "minimum_purchase_quantity": {
            "type": "integer",
            "title": "Minimum Purchase Quantity"
          },
          "maximum_purchase_quantity": {
            "type": "integer",
            "title": "Maximum Quantity per Purchase"
          },
          "member_maximum_purchase_quantity": {
            "type": "integer",
            "title": "Maximum Quantity per Member Purchase"
          },
          "optional_limit_type": {
            "oneOf": [
              {
                "const": "relative",
                "title": "Can Purchase as Much as the Main Product"
              },
              {
                "const": "limit",
                "title": "Maximum Purchase Quantity Limit"
              },
              {
                "const": "unique",
                "title": "Can Purchase Only One"
              }
            ],
            "title": "Maximum Purchase Quantity Limit Type for Free Options"
          },
          "optional_limit": {
            "type": "integer",
            "title": "Maximum Purchase Quantity for Free Options\n\nMaximum Purchase Quantity Limit"
          },
          "use_unipass_number": {
            "oneOf": [
              {
                "const": "default",
                "title": "Follow Default Method",
                "description": "May vary depending on shopping environment settings"
              },
              {
                "const": "Y",
                "title": "Use"
              },
              {
                "const": "N",
                "title": "Do Not Use"
              }
            ]
          },
          "adult": {
            "type": "boolean",
            "title": "Minor Purchase Restriction"
          }
        },
        "required": [
          "minimum_purchase_quantity",
          "maximum_purchase_quantity",
          "member_maximum_purchase_quantity",
          "optional_limit_type",
          "use_unipass_number",
          "adult"
        ],
        "title": "Miscellaneous Settings Data Structure"
      },
      "IImweb.IGetProductInput": {
        "type": "object",
        "properties": {
          "prod_status": {
            "oneOf": [
              {
                "const": "sale",
                "title": "판매중"
              },
              {
                "const": "soldout",
                "title": "품절"
              },
              {
                "const": "nosale",
                "title": "숨김"
              }
            ],
            "title": "the sales status of a product\n\nYou can deliver the value when you want to inquire based on the sales status of the product.\nYou can select 'sale', 'soldout', 'nosale'."
          },
          "category": {
            "type": "string",
            "title": "product category code\n\nYou can also search with the product's category code,\nbut this code is randomly determined by `Imweb`, so it's currently unavailable.\nIf you don't know the exact category code, it's better not to use it."
          },
          "key": {
            "type": "string",
            "title": "API Key\n\nThis can be found in the configuration settings on the `Imweb`."
          },
          "secret": {
            "type": "string",
            "title": "API Secret Key\n\nThis can be found in the configuration settings on the `Imweb`."
          }
        },
        "required": [
          "key",
          "secret"
        ],
        "title": "Product Inquiry Request DTO."
      },
      "IImweb.IGetAccessTokenOutput": {
        "type": "object",
        "properties": {
          "msg": {
            "const": "SUCCESS",
            "title": "Response Message"
          },
          "code": {
            "const": 200,
            "title": "IMWEB Custom Code"
          },
          "http_code": {
            "const": 200,
            "title": "HTTP Status Code"
          },
          "access_token": {
            "type": "string",
            "title": "Access Token"
          }
        },
        "required": [
          "msg",
          "code",
          "http_code",
          "access_token"
        ],
        "title": "Imweb Token Issuance Request Response DTO"
      },
      "IImweb.Credential": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "title": "API Key\n\nThis can be found in the configuration settings on the `Imweb`."
          },
          "secret": {
            "type": "string",
            "title": "API Secret Key\n\nThis can be found in the configuration settings on the `Imweb`."
          }
        },
        "required": [
          "key",
          "secret"
        ],
        "title": "Imweb Access Token Request DTO\n\nAn API Key and Secret Key must be issued first to use the Rest API.\nThese keys are generated on a site-by-site basis."
      },
      "IMSIT.IGetAddressOutput": {
        "type": "object",
        "properties": {
          "NewAddressListResponse": {
            "type": "object",
            "properties": {
              "cmmMsgHeader": {
                "type": "object",
                "properties": {
                  "totalCount": {
                    "type": "integer",
                    "title": "totalCount"
                  },
                  "countPerPage": {
                    "type": "integer",
                    "title": "countPerPage"
                  },
                  "totalPage": {
                    "type": "integer",
                    "title": "totalPage"
                  },
                  "errMsg": {
                    "type": "string",
                    "title": "error message"
                  }
                }
              },
              "newAddressListAreaCd": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "zipNo": {
                      "type": "string",
                      "title": "Postal address"
                    },
                    "lnmAdres": {
                      "type": "string",
                      "title": "street address"
                    },
                    "rnAdres": {
                      "type": "string",
                      "title": "Road name address"
                    }
                  },
                  "required": [
                    "zipNo",
                    "lnmAdres",
                    "rnAdres"
                  ]
                },
                "title": "Address Data\n\nIf there is no data, the key itself does not exist, so in this case, there are no search results."
              }
            },
            "required": [
              "cmmMsgHeader"
            ],
            "title": "NewAddressListResponse\n\nSection containing header information for the response result"
          }
        },
        "required": [
          "NewAddressListResponse"
        ]
      },
      "IMSIT.IGetAddressInput": {
        "type": "object",
        "properties": {
          "srchwrd": {
            "type": "string",
            "minLength": 1,
            "maxLength": 200,
            "title": "search term"
          },
          "countPerPage": {
            "type": "integer",
            "title": "Number of outputs per page"
          },
          "currentPage": {
            "type": "integer",
            "title": "Page number to be printed"
          }
        },
        "required": [
          "srchwrd"
        ]
      },
      "IMOLIT.IgetRTMSDataSvcSHRentOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIMOLIT.BuildingLentInfoapartmentexclusiveArealotNumberfloor"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "nextPage\n\nIndicates whether the next page exists"
          }
        },
        "required": [
          "data",
          "nextPage"
        ]
      },
      "StrictOmitIMOLIT.BuildingLentInfoapartmentexclusiveArealotNumberfloor": {
        "type": "object",
        "properties": {
          "useOfRenewalRight": {
            "type": "string",
            "title": "Use of renewal request right"
          },
          "yearOfConstruction": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Year of construction"
          },
          "typeOfContract": {
            "type": "string",
            "title": "Contract type"
          },
          "contractPeriod": {
            "type": "string",
            "title": "Contract period"
          },
          "year": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "year"
          },
          "legalDistrict": {
            "type": "string",
            "title": "Beopjeong-dong"
          },
          "depositAmount": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Deposit amount\n\nSince it is based on Korean currency, it will be in ten thousand won in most cases."
          },
          "month": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer",
                "minimum": 1,
                "maximum": 12
              }
            ],
            "title": "month"
          },
          "monthlyRentAmount": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Monthly rent\n\nSince it is based on Korean currency, it will be in ten thousand won in most cases."
          },
          "day": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer",
                "minimum": 1,
                "maximum": 31
              }
            ],
            "title": "day"
          },
          "previousContractDeposit": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Previous contract deposit"
          },
          "previousContractMonthlyRent": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Previous contract monthly rent"
          },
          "areaCode": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "area code"
          }
        },
        "required": [
          "useOfRenewalRight",
          "typeOfContract",
          "contractPeriod",
          "year",
          "legalDistrict",
          "depositAmount",
          "month",
          "monthlyRentAmount",
          "day",
          "previousContractDeposit",
          "previousContractMonthlyRent",
          "areaCode"
        ]
      },
      "IMOLIT.IGetRTMSDataSvcAptRentInput": {
        "type": "object",
        "properties": {
          "LAWD_CD": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/open-data/getStandardRegionCodeList",
              "jmesPath": "rows[].{value:sigunguCd, label:sigunguNm}"
            },
            "title": "City/county/district code"
          },
          "DEAL_YMD": {
            "type": "string",
            "x-wrtn-placeholder": "202201",
            "title": "Contract year and month of actual transaction data (6 digits)"
          },
          "page": {
            "type": "integer",
            "title": "page"
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "title": "limit"
          }
        },
        "required": [
          "LAWD_CD",
          "DEAL_YMD",
          "page",
          "limit"
        ]
      },
      "IMOLIT.IGetRTMSDataSvcOffiRentOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIMOLIT.BuildingLentInfoapartmentyearOfConstructiondepositAmountmonthlyRentAmount"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "nextPage\n\nIndicates whether the next page exists"
          }
        },
        "required": [
          "data",
          "nextPage"
        ]
      },
      "StrictOmitIMOLIT.BuildingLentInfoapartmentyearOfConstructiondepositAmountmonthlyRentAmount": {
        "type": "object",
        "properties": {
          "exclusiveArea": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Exclusive area"
          },
          "lotNumber": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Address"
          },
          "floor": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "floor"
          },
          "useOfRenewalRight": {
            "type": "string",
            "title": "Use of renewal request right"
          },
          "typeOfContract": {
            "type": "string",
            "title": "Contract type"
          },
          "contractPeriod": {
            "type": "string",
            "title": "Contract period"
          },
          "year": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "year"
          },
          "legalDistrict": {
            "type": "string",
            "title": "Beopjeong-dong"
          },
          "month": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer",
                "minimum": 1,
                "maximum": 12
              }
            ],
            "title": "month"
          },
          "day": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer",
                "minimum": 1,
                "maximum": 31
              }
            ],
            "title": "day"
          },
          "previousContractDeposit": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Previous contract deposit"
          },
          "previousContractMonthlyRent": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Previous contract monthly rent"
          },
          "areaCode": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "area code"
          }
        },
        "required": [
          "exclusiveArea",
          "lotNumber",
          "floor",
          "useOfRenewalRight",
          "typeOfContract",
          "contractPeriod",
          "year",
          "legalDistrict",
          "month",
          "day",
          "previousContractDeposit",
          "previousContractMonthlyRent",
          "areaCode"
        ]
      },
      "IMOLIT.IGetRTMSDataSvcAptRentOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IMOLIT.BuildingLentInfo"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "nextPage\n\nIndicates whether the next page exists"
          }
        },
        "required": [
          "data",
          "nextPage"
        ]
      },
      "IMOLIT.BuildingLentInfo": {
        "type": "object",
        "properties": {
          "useOfRenewalRight": {
            "type": "string",
            "title": "Use of renewal request right"
          },
          "yearOfConstruction": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Year of construction"
          },
          "typeOfContract": {
            "type": "string",
            "title": "Contract type"
          },
          "contractPeriod": {
            "type": "string",
            "title": "Contract period"
          },
          "year": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "year"
          },
          "legalDistrict": {
            "type": "string",
            "title": "Beopjeong-dong"
          },
          "depositAmount": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Deposit amount\n\nSince it is based on Korean currency, it will be in ten thousand won in most cases."
          },
          "apartment": {
            "type": "string",
            "title": "Apartment"
          },
          "month": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer",
                "minimum": 1,
                "maximum": 12
              }
            ],
            "title": "month"
          },
          "monthlyRentAmount": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Monthly rent\n\nSince it is based on Korean currency, it will be in ten thousand won in most cases."
          },
          "day": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer",
                "minimum": 1,
                "maximum": 31
              }
            ],
            "title": "day"
          },
          "exclusiveArea": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Exclusive area"
          },
          "previousContractDeposit": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Previous contract deposit"
          },
          "previousContractMonthlyRent": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Previous contract monthly rent"
          },
          "lotNumber": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Address"
          },
          "areaCode": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "area code"
          },
          "floor": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "integer"
              }
            ],
            "title": "floor"
          }
        },
        "required": [
          "useOfRenewalRight",
          "typeOfContract",
          "contractPeriod",
          "year",
          "legalDistrict",
          "depositAmount",
          "apartment",
          "month",
          "monthlyRentAmount",
          "day",
          "exclusiveArea",
          "previousContractDeposit",
          "previousContractMonthlyRent",
          "lotNumber",
          "areaCode",
          "floor"
        ]
      },
      "ILH.IGetLHLeaseInfoOutput": {
        "type": "object",
        "properties": {
          "nextPage": {
            "type": "boolean",
            "title": "Next page availability"
          },
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "SUM_HSH_CNT": {
                  "type": "string",
                  "x-wrtn-placeholder": "873",
                  "title": "Total number of households"
                },
                "RFE": {
                  "type": "string",
                  "x-wrtn-placeholder": "373500",
                  "title": "Monthly rent (won)"
                },
                "RNUM": {
                  "type": "string",
                  "x-wrtn-placeholder": "1",
                  "title": "order"
                },
                "HSH_CNT": {
                  "type": "string",
                  "x-wrtn-placeholder": "72",
                  "title": "Number of generations"
                },
                "ARA_NM": {
                  "type": "string",
                  "x-wrtn-placeholder": "서울특별시 강남구",
                  "title": "Region name"
                },
                "LS_GMY": {
                  "type": "string",
                  "x-wrtn-placeholder": "45003000",
                  "title": "Rental Deposit"
                },
                "AIS_TP_CD_NM": {
                  "type": "string",
                  "x-wrtn-placeholder": "국민임대",
                  "title": "Supply type name"
                },
                "SBD_LGO_NM": {
                  "type": "string",
                  "x-wrtn-placeholder": "서울강남 3블록",
                  "title": "Name of the unit"
                },
                "ALL_CNT": {
                  "type": "string",
                  "x-wrtn-placeholder": "157",
                  "title": "Total number"
                },
                "DDO_AR": {
                  "type": "string",
                  "x-wrtn-placeholder": "46.71",
                  "title": "Exclusive area"
                },
                "MVIN_XPC_YM": {
                  "type": "string",
                  "x-wrtn-placeholder": "201311",
                  "title": "First year of residency"
                }
              },
              "required": [
                "SUM_HSH_CNT",
                "RFE",
                "RNUM",
                "HSH_CNT",
                "ARA_NM",
                "LS_GMY",
                "AIS_TP_CD_NM",
                "SBD_LGO_NM",
                "ALL_CNT",
                "DDO_AR",
                "MVIN_XPC_YM"
              ]
            }
          }
        },
        "required": [
          "nextPage",
          "data"
        ],
        "title": "LH rental housing inquiry response"
      },
      "ILH.IGetLHLeaseInfoInput": {
        "type": "object",
        "properties": {
          "CNP_CD": {
            "oneOf": [
              {
                "const": 11,
                "title": "서울특별시"
              },
              {
                "const": 26,
                "title": "부산광역시"
              },
              {
                "const": 27,
                "title": "대구광역시"
              },
              {
                "const": 28,
                "title": "인천광역시"
              },
              {
                "const": 29,
                "title": "광주광역시"
              },
              {
                "const": 30,
                "title": "대전광역시"
              },
              {
                "const": 31,
                "title": "울산광역시"
              },
              {
                "const": 41,
                "title": "경기도"
              },
              {
                "const": 42,
                "title": "강원도"
              },
              {
                "const": 43,
                "title": "충청북도"
              },
              {
                "const": 44,
                "title": "충청남도"
              },
              {
                "const": 45,
                "title": "전라북도"
              },
              {
                "const": 46,
                "title": "전라남도"
              },
              {
                "const": 47,
                "title": "경상북도"
              },
              {
                "const": 48,
                "title": "경상남도"
              },
              {
                "const": 50,
                "title": "제주특별자치도"
              },
              {
                "const": 36110,
                "title": "세종특별자치시"
              }
            ],
            "title": "Area Code\n\nIt can be one of these numbers:\n- 11: Seoul\n- 26: Busan\n- 27: Daegu\n- 28: Incheon\n- 29: Gwangju\n- 30: Daejeon\n- 31: Ulsan\n- 36110: Sejong\n- 41: Gyeonggi\n- 42: Gangwon\n- 43: Chungcheongbuk\n- 44: Chungcheongnam\n- 45: Jeollabuk\n- 46: Jeollanam\n- 47: Gyeongsangbuk\n- 48: Gyeongsangnam\n- 50: Jeju"
          },
          "SPL_TP_CD": {
            "oneOf": [
              {
                "const": "07",
                "title": "국민임대"
              },
              {
                "const": "08",
                "title": "공공임대"
              },
              {
                "const": "09",
                "title": "영구임대"
              },
              {
                "const": "10",
                "title": "행복주택"
              },
              {
                "const": "11",
                "title": "장기전세"
              },
              {
                "const": "13",
                "title": "매입임대"
              },
              {
                "const": "17",
                "title": "전세임대"
              }
            ],
            "title": "Supply Type Code\n\nIt can be one of these numbers:\n- 07: National Rental\n- 08: Public Rental\n- 09: Permanent Rental\n- 10: Happy Housing\n- 11: Long-term Lease\n- 13: Purchase Lease\n- 17: Lease Lease"
          },
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          }
        },
        "required": [
          "CNP_CD"
        ],
        "title": "LH rental housing search conditions"
      },
      "INIA.IGetParkingLotOutput": {
        "type": "object",
        "properties": {
          "parkingLots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/INIA.ParkingLot"
            },
            "title": "Parking lot information"
          },
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "totalCount": {
            "type": "number",
            "title": "Total number of records"
          }
        },
        "required": [
          "parkingLots",
          "totalCount"
        ],
        "title": "Parking lot inquiry response"
      },
      "INIA.ParkingLot": {
        "type": "object",
        "properties": {
          "prkplceNo": {
            "type": "string",
            "title": "Parking lot management number"
          },
          "prkplceNm": {
            "type": "string",
            "title": "Parking lot name"
          },
          "prkplceSe": {
            "type": "string",
            "title": "Parking lot classification"
          },
          "prkplceType": {
            "type": "string",
            "title": "Parking lot type"
          },
          "rdnmadr": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/kakao-map/search",
              "jmesPath": "documents[].{value:road_address_name, label:road_address_name}"
            },
            "title": "road name address (read name address)"
          },
          "lnmadr": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/kakao-map/search",
              "jmesPath": "documents[].{value:address_name, label:address_name}"
            },
            "title": "Lot number address"
          },
          "prkcmprt": {
            "type": "string",
            "title": "Number of parking spaces"
          },
          "feedingSe": {
            "type": "string",
            "title": "Urgent Distinction"
          },
          "enforceSe": {
            "type": "string",
            "title": "Subtitle enforcement classification"
          },
          "operDay": {
            "type": "string",
            "title": "Operating days"
          },
          "weekdayOperOpenHhmm": {
            "type": "string",
            "title": "Weekday operation start time"
          },
          "weekdayOperColseHhmm": {
            "type": "string",
            "title": "Weekday operating closing time"
          },
          "satOperOperOpenHhmm": {
            "type": "string",
            "title": "Saturday operation start time"
          },
          "satOperCloseHhmm": {
            "type": "string",
            "title": "Saturday closing time"
          },
          "holidayOperOpenHhmm": {
            "type": "string",
            "title": "Holiday operation start time"
          },
          "holidayCloseOpenHhmm": {
            "type": "string",
            "title": "Holiday closing time"
          },
          "parkingchrgeInfo": {
            "type": "string",
            "title": "Rate information"
          },
          "basicTime": {
            "type": "string",
            "title": "Basic parking time"
          },
          "basicCharge": {
            "type": "string",
            "title": "Basic parking fee"
          },
          "addUnitTime": {
            "type": "string",
            "title": "Additional unit time"
          },
          "addUnitCharge": {
            "type": "string",
            "title": "Additional unit fee"
          },
          "dayCmmtktAdjTime": {
            "type": "string",
            "title": "1-day parking fee application time"
          },
          "dayCmmtkt": {
            "type": "string",
            "title": "1-day parking fee"
          },
          "monthCmmtkt": {
            "type": "string",
            "title": "Monthly pass fee"
          },
          "metpay": {
            "type": "string",
            "title": "Payment method"
          },
          "spcmnt": {
            "type": "string",
            "title": "Special Notes"
          },
          "institutionNm": {
            "type": "string",
            "title": "Management Agency Name"
          },
          "phoneNumber": {
            "type": "string",
            "title": "phone number"
          },
          "latitude": {
            "type": "string",
            "title": "Latitude"
          },
          "longitude": {
            "type": "string",
            "title": "Hardness"
          },
          "pwdbsPpkZoneYn": {
            "type": "string",
            "title": "Whether there is a parking area for the disabled"
          },
          "referenceDate": {
            "type": "string",
            "title": "Data reference date"
          },
          "instt_code": {
            "type": "string",
            "title": "Provider Code"
          },
          "instt_nm": {
            "type": "string",
            "title": "Provider Name of institution"
          }
        }
      },
      "IPaginationInputMyPickParkingLotrdnmadr": {
        "type": "object",
        "properties": {
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "rdnmadr": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/kakao-map/search",
              "jmesPath": "documents[].{value:road_address_name, label:road_address_name}"
            },
            "title": "road name address (read name address)"
          }
        }
      },
      "IPaginationInputMyPickParkingLotlnmadr": {
        "type": "object",
        "properties": {
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "lnmadr": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/kakao-map/search",
              "jmesPath": "documents[].{value:address_name, label:address_name}"
            },
            "title": "Lot number address"
          }
        }
      },
      "IMOLIT.GetBuildingInfoOutput": {
        "type": "object",
        "properties": {
          "bulidings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IMOLIT.Building"
            },
            "title": "Building Information List"
          },
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "totalCount": {
            "type": "number",
            "title": "Total number of records"
          }
        },
        "required": [
          "bulidings",
          "totalCount"
        ],
        "title": "Building Inquiry Response"
      },
      "IMOLIT.Building": {
        "type": "object",
        "properties": {
          "mainPurpsCdNm": {
            "type": "string",
            "title": "Primary purpose code name"
          },
          "etcPurps": {
            "type": "string",
            "title": "Other uses"
          },
          "roofCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "roof code"
          },
          "roofCdNm": {
            "type": "string",
            "title": "Roof code name"
          },
          "etcRoof": {
            "type": "string",
            "title": "Guitar Roof"
          },
          "hhldCnt": {
            "type": "number",
            "title": "Number of generations (generation)"
          },
          "fmlyCnt": {
            "type": "number",
            "title": "Number of households (households)"
          },
          "heit": {
            "type": "number",
            "title": "Height (m)"
          },
          "grndFlrCnt": {
            "type": "number",
            "title": "Number of floors above ground"
          },
          "ugrndFlrCnt": {
            "type": "number",
            "title": "Basement floor"
          },
          "rideUseElvtCnt": {
            "type": "number",
            "title": "Elevator driver"
          },
          "emgenUseElvtCnt": {
            "type": "number",
            "title": "Emergency Elevator"
          },
          "atchBldCnt": {
            "type": "number",
            "title": "Number of auxiliary buildings"
          },
          "atchBldArea": {
            "type": "number",
            "title": "Area of attached building (㎡)"
          },
          "totDongTotArea": {
            "type": "number",
            "title": "Total floor area (㎡)"
          },
          "indrMechUtcnt": {
            "type": "number",
            "title": "Indoor machine counter (large)"
          },
          "indrMechArea": {
            "type": "number",
            "title": "Indoor mechanical area (㎡)"
          },
          "oudrMechUtcnt": {
            "type": "number",
            "title": "Outdoor mechanical counter (large)"
          },
          "oudrMechArea": {
            "type": "number",
            "title": "Outdoor mechanical area (㎡)"
          },
          "indrAutoUtcnt": {
            "type": "number",
            "title": "Indoor self-sufficient stock (large)"
          },
          "indrAutoArea": {
            "type": "number",
            "title": "Indoor self-sufficient area (㎡)"
          },
          "oudrAutoUtcnt": {
            "type": "number",
            "title": "Outdoor self-propelled vehicle (large)"
          },
          "oudrAutoArea": {
            "type": "number",
            "title": "Outdoor self-contained area (㎡)"
          },
          "pmsDay": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Permission Date"
          },
          "stcnsDay": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Start date"
          },
          "useAprDay": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Date of approval for use"
          },
          "pmsnoYear": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "License number year"
          },
          "pmsnoKikCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "License Number Agency Code"
          },
          "pmsnoKikCdNm": {
            "type": "string",
            "title": "License Number Agency Code Name"
          },
          "pmsnoGbCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Permit number classification code"
          },
          "pmsnoGbCdNm": {
            "type": "string",
            "title": "Permit number classification code name"
          },
          "hoCnt": {
            "type": "number",
            "title": "lake"
          },
          "engrGrade": {
            "type": "string",
            "title": "Energy Efficiency Rating"
          },
          "engrRat": {
            "type": "number",
            "title": "Energy saving rate"
          },
          "engrEpi": {
            "type": "number",
            "title": "EPI score"
          },
          "gnBldGrade": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Eco-friendly building rating"
          },
          "gnBldCert": {
            "type": "number",
            "title": "Eco-friendly building certification score"
          },
          "itgBldGrade": {
            "type": "string",
            "title": "Intelligent Building Rating"
          },
          "itgBldCert": {
            "type": "number",
            "title": "Intelligent Building Certification Score"
          },
          "crtnDay": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Creation date"
          },
          "rnum": {
            "type": "number",
            "title": "order"
          },
          "platPlc": {
            "type": "string",
            "title": "Earth location"
          },
          "sigunguCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "City/county/district code"
          },
          "bjdongCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Beopjeong-dong code"
          },
          "platGbCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Earth Classification Code"
          },
          "bun": {
            "type": "string",
            "title": "number",
            "description": "One of the Korean address names"
          },
          "ji": {
            "type": "string",
            "title": "Ji",
            "description": "One of the Korean address names"
          },
          "mgmBldrgstPk": {
            "type": "string",
            "title": "Management Building Register PK"
          },
          "regstrGbCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Colon Distinction Code"
          },
          "regstrGbCdNm": {
            "type": "string",
            "title": "Colon division code name"
          },
          "regstrKindCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Colon type code"
          },
          "regstrKindCdNm": {
            "type": "string",
            "title": "Colon type code name"
          },
          "newPlatPlc": {
            "type": "string",
            "title": "Road name site location"
          },
          "bldNm": {
            "type": "string",
            "title": "Building name"
          },
          "splotNm": {
            "type": "string",
            "title": "Special place name"
          },
          "block": {
            "type": "string",
            "title": "block"
          },
          "lot": {
            "type": "string",
            "title": "lot"
          },
          "bylotCnt": {
            "type": "number",
            "title": "External index"
          },
          "naRoadCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "New address road code"
          },
          "naBjdongCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "New address law code"
          },
          "naUgrndCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "New address ground and underground code"
          },
          "naMainBun": {
            "type": "number",
            "title": "New address number"
          },
          "naSubBun": {
            "type": "number",
            "title": "New address number"
          },
          "dongNm": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Same name"
          },
          "mainAtchGbCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Main/Subordinate Classification Code"
          },
          "mainAtchGbCdNm": {
            "type": "string",
            "title": "Main/Subordinate Code Name"
          },
          "platArea": {
            "type": "number",
            "title": "Land area (㎡)"
          },
          "archArea": {
            "type": "number",
            "title": "Building area (㎡)"
          },
          "bcRat": {
            "type": "number",
            "title": "Building coverage ratio (%)"
          },
          "totArea": {
            "type": "number",
            "title": "Total floor area (㎡)"
          },
          "vlRatEstmTotArea": {
            "type": "number",
            "title": "Floor area ratio calculation area (㎡)"
          },
          "vlRat": {
            "type": "number",
            "title": "Volume ratio (%)"
          },
          "strctCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Structure Code"
          },
          "strctCdNm": {
            "type": "string",
            "title": "Structure code name"
          },
          "etcStrct": {
            "type": "string",
            "title": "Other Structures"
          },
          "mainPurpsCd": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "Primary Purpose Code"
          },
          "rserthqkDsgnApplyYn": {
            "oneOf": [
              {
                "const": 0,
                "title": "미적용"
              },
              {
                "const": 1,
                "title": "적용"
              },
              {
                "const": " ",
                "title": "알 수 없음"
              }
            ],
            "title": "Whether earthquake-resistant design is applied"
          },
          "rserthqkAblty": {
            "type": "string",
            "title": "seismic capacity"
          }
        },
        "required": [
          "crtnDay",
          "platPlc",
          "sigunguCd",
          "bjdongCd",
          "mgmBldrgstPk"
        ]
      },
      "IMOLIT.GetBuildingInfoInput": {
        "type": "object",
        "properties": {
          "sigunguCd": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/open-data/getStandardRegionCodeList",
              "jmesPath": "rows[].{value:sigunguCd, label:sigunguNm}"
            },
            "title": "City/county/district code"
          },
          "bjdongCd": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/open-data/getStandardRegionCodeList",
              "jmesPath": "rows[].{value:sigunguCd, label:sigunguNm}"
            },
            "title": "Beopjeong-dong Code"
          },
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          }
        },
        "required": [
          "sigunguCd",
          "bjdongCd"
        ],
        "title": "Building search conditions"
      },
      "IOpenData.MinistryOfTheInteriorAndSafety.IGetStandardRegionCodeListOutput": {
        "type": "object",
        "properties": {
          "rows": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "region_cd": {
                  "type": "string",
                  "title": "Region code"
                },
                "sido_cd": {
                  "type": "string",
                  "title": "City code"
                },
                "sgg_cd": {
                  "type": "string",
                  "title": "District code"
                },
                "sigunguCd": {
                  "type": "string",
                  "title": "City and District Code",
                  "description": "Combination of city code and district code"
                },
                "sigunguNm": {
                  "type": "string",
                  "title": "District name"
                },
                "umd_cd": {
                  "type": "string",
                  "title": "Town/Village code"
                },
                "ri_cd": {
                  "type": "string",
                  "title": "Ri code"
                },
                "bjdongCd": {
                  "type": "string",
                  "title": "Legal Dong code",
                  "description": "Combination of Town/Village code and Ri code"
                },
                "locatjumin_cd": {
                  "type": "string",
                  "title": "Resident region code"
                },
                "locatjijuk_cd": {
                  "type": "string",
                  "title": "Land region code"
                },
                "locatadd_nm": {
                  "type": "string",
                  "title": "Region address name"
                },
                "locat_order": {
                  "type": "integer",
                  "title": "Sequence"
                },
                "locat_rm": {
                  "type": "string",
                  "title": "Remark"
                },
                "locathigh_cd": {
                  "type": "string",
                  "title": "Parent region code"
                },
                "locallow_nm": {
                  "type": "string",
                  "title": "Lowest region name"
                },
                "adpt_de": {
                  "type": "string",
                  "title": "Date of creation"
                }
              },
              "required": [
                "region_cd",
                "sigunguNm"
              ]
            }
          },
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "totalCount": {
            "type": "number",
            "title": "Total number of records"
          }
        },
        "required": [
          "rows",
          "totalCount"
        ],
        "title": "Result of Administrative Standard Code Lookup"
      },
      "IOpenData.MinistryOfTheInteriorAndSafety.IGetStandardRegionCodeListInput": {
        "type": "object",
        "properties": {
          "locatadd_nm": {
            "oneOf": [
              {
                "const": "서울특별시",
                "title": "서울특별시",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "부산광역시",
                "title": "부산광역시",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "대구광역시",
                "title": "대구광역시",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "인천광역시",
                "title": "인천광역시",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "광주광역시",
                "title": "광주광역시",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "대전광역시",
                "title": "대전광역시",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "울산광역시",
                "title": "울산광역시",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "세종특별자치시",
                "title": "세종특별자치시",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "경기도",
                "title": "경기도",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "충청북도",
                "title": "충청북도",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "충청남도",
                "title": "충청남도",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "경상북도",
                "title": "경상북도",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "경상남도",
                "title": "경상남도",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "전라남도",
                "title": "전라남도",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "제주특별자치도",
                "title": "제주특별자치도",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "강원특별자치도",
                "title": "강원특별자치도",
                "x-wrtn-placeholder": "서울특별시"
              },
              {
                "const": "전북특별자치도",
                "title": "전북특별자치도",
                "x-wrtn-placeholder": "서울특별시"
              }
            ],
            "title": "Region address name\nIt must be one of: \"Seoul Metropolitan City\",\"Busan Metropolitan City\",\"Daegu Metropolitan City\",\"Incheon Metropolitan City\",\"Gwangju Metropolitan City\",\"Daejeon Metropolitan City\",\"Ulsan Metropolitan City\",\"Sejong Special Self-Governing City\",\"Gyeonggi-do\",\"Chungcheongbuk-do\",\"Chungcheongnam-do\",\"Gyeongsangbuk-do\",\"Gyeongsangnam-do\",\"Jeollanam-do\",\"Jeju Special Self-Governing Province\",\"Gangwon Special Self-Governing Province\",\"Jeollabuk-do Special Self-Governing Province\""
          },
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          }
        },
        "required": [
          "locatadd_nm"
        ],
        "title": "Request for Administrative Standard Code Lookup"
      },
      "IOpenData.FinancialServicesCommission.IGetStockPriceInfoOutput": {
        "type": "object",
        "properties": {
          "response": {
            "type": "object",
            "properties": {
              "body": {
                "type": "object",
                "properties": {
                  "numOfRows": {
                    "type": "integer",
                    "default": 10,
                    "title": "Number of results per page"
                  },
                  "pageNo": {
                    "type": "integer",
                    "default": 1,
                    "title": "Page number"
                  },
                  "totalCount": {
                    "type": "number",
                    "title": "Total number of records"
                  },
                  "items": {
                    "type": "object",
                    "properties": {
                      "item": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "basDt": {
                              "type": "string",
                              "x-wrtn-placeholder": "20220919",
                              "title": "Base date"
                            },
                            "srtnCd": {
                              "type": "string",
                              "title": "Short code",
                              "description": "6-digit code shorter than stock code and uniquely guaranteed"
                            },
                            "isinCd": {
                              "type": "string",
                              "title": "ISIN code",
                              "description": "International Securities Identification Number"
                            },
                            "itmsNm": {
                              "type": "string",
                              "title": "Stock name"
                            },
                            "mrktCtg": {
                              "oneOf": [
                                {
                                  "const": "KOSPI",
                                  "title": "KOSPI"
                                },
                                {
                                  "const": "KOSDAQ",
                                  "title": "KOSDAQ"
                                },
                                {
                                  "const": "KONEX",
                                  "title": "KONEX"
                                }
                              ],
                              "title": "Market category"
                            },
                            "clpr": {
                              "type": "string",
                              "title": "Closing price",
                              "description": "Final price formed at the end of regular trading hours"
                            },
                            "vs": {
                              "type": "string",
                              "title": "Change",
                              "description": "Fluctuation compared to the previous day"
                            },
                            "fltRt": {
                              "type": "string",
                              "title": "Rate of change",
                              "description": "Ratio of fluctuation compared to the previous day"
                            },
                            "mkp": {
                              "type": "string",
                              "title": "Opening price",
                              "description": "Initial price formed after opening"
                            },
                            "hipr": {
                              "type": "string",
                              "title": "Highest price",
                              "description": "Highest price during the day"
                            },
                            "lopr": {
                              "type": "string",
                              "title": "Lowest price",
                              "description": "Lowest price during the day"
                            },
                            "trqu": {
                              "type": "string",
                              "title": "Trading volume",
                              "description": "Cumulative total of trade quantities"
                            },
                            "trPrc": {
                              "type": "string",
                              "title": "Trading amount",
                              "description": "Cumulative total of trade prices * quantities"
                            },
                            "lstgStCnt": {
                              "type": "string",
                              "title": "Listed shares"
                            },
                            "mrktTotAmt": {
                              "type": "string",
                              "title": "Market capitalization",
                              "description": "Closing price * listed shares"
                            }
                          },
                          "required": [
                            "basDt",
                            "srtnCd",
                            "isinCd",
                            "itmsNm",
                            "mrktCtg",
                            "clpr",
                            "vs",
                            "fltRt",
                            "mkp",
                            "hipr",
                            "lopr",
                            "trqu",
                            "trPrc",
                            "lstgStCnt",
                            "mrktTotAmt"
                          ]
                        }
                      }
                    },
                    "required": [
                      "item"
                    ],
                    "title": "Retrieved company information"
                  }
                },
                "required": [
                  "numOfRows",
                  "pageNo",
                  "totalCount",
                  "items"
                ]
              }
            },
            "required": [
              "body"
            ]
          }
        },
        "required": [
          "response"
        ],
        "title": "Result of querying market capitalization and stock information"
      },
      "IPaginationInputlikeItmsNm(stringMaxLength120PlaceholderSamsungElectronics)undefinedbasDt(stringPlaceholder...)undefined": {
        "type": "object",
        "properties": {
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "likeItmsNm": {
            "type": "string",
            "maxLength": 120,
            "x-wrtn-placeholder": "Samsung Electronics",
            "title": "Keyword for stock name search\n\nSearch is only possible if it matches the exact company name that is listed, which is stored on the Korea Stock Exchange.\nSince it is a Korean company, most of it will be in Korean.\nPlease give Korean company name."
          },
          "basDt": {
            "type": "string",
            "x-wrtn-placeholder": "20220919",
            "title": "Base date\nSearches for data matching the search value and base date\nYYYYMMDD format date string."
          }
        }
      },
      "IPaginationInputlikeItmsNm(stringMaxLength120PlaceholderSamsungElectronics)undefinedbeginBasDt(stringPlaceholder...)undefinedendBasDt(stringPlaceholder...)undefined": {
        "type": "object",
        "properties": {
          "numOfRows": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "pageNo": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "likeItmsNm": {
            "type": "string",
            "maxLength": 120,
            "x-wrtn-placeholder": "Samsung Electronics",
            "title": "Keyword for stock name search\n\nSearch is only possible if it matches the exact company name that is listed, which is stored on the Korea Stock Exchange.\nSince it is a Korean company, most of it will be in Korean.\nPlease give Korean company name."
          },
          "beginBasDt": {
            "type": "string",
            "x-wrtn-placeholder": "20220919",
            "title": "Start date (inclusive)\nSearches for data where the base date is greater than or equal to the search value\nYYYYMMDD format date string."
          },
          "endBasDt": {
            "type": "string",
            "x-wrtn-placeholder": "20220919",
            "title": "End date (exclusive)\nSearches for data where the base date is less than the search value\nYYYYMMDD format date string."
          }
        }
      },
      "IKoreaMeteorologicalAdministration.IGetForecastOutput": {
        "type": "object",
        "properties": {
          "baseDate": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Date value composed of year, month, and day, e.g., `20240619`."
          },
          "baseTime": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Time value indicating the exact hour, e.g., `1200`."
          },
          "category": {
            "oneOf": [
              {
                "const": "POP",
                "title": "Precipitation Probability",
                "description": "Unit is %"
              },
              {
                "const": "PTY",
                "title": "Precipitation Type",
                "description": "Code value"
              },
              {
                "const": "PCP",
                "title": "Hourly Precipitation",
                "description": "Category (1mm)"
              },
              {
                "const": "REH",
                "title": "Humidity",
                "description": "Unit is %"
              },
              {
                "const": "SNO",
                "title": "Hourly Snowfall",
                "description": "Category (1cm)"
              },
              {
                "const": "SKY",
                "title": "Sky Condition",
                "description": "Code value"
              },
              {
                "const": "TMP",
                "title": "Hourly Temperature",
                "description": "Celsius temperature"
              },
              {
                "const": "TMN",
                "title": "Daily Minimum Temperature",
                "description": "Celsius temperature"
              },
              {
                "const": "TMX",
                "title": "Daily Maximum Temperature",
                "description": "Celsius temperature"
              },
              {
                "const": "UUU",
                "title": "Wind Speed (East-West Component)",
                "description": "m/s"
              },
              {
                "const": "VVV",
                "title": "Wind Speed (North-South Component)",
                "description": "m/s"
              },
              {
                "const": "WAV",
                "title": "Wave Height (Wave Height)",
                "description": "M"
              },
              {
                "const": "VEC",
                "title": "Wind Direction",
                "description": "Angle (deg)"
              },
              {
                "const": "VEC",
                "title": "Wind Direction",
                "description": "deg"
              },
              {
                "const": "WSD",
                "title": "Wind Speed",
                "description": "m/s"
              },
              {
                "const": "T1H",
                "title": "Temperature",
                "description": "Celsius temperature"
              },
              {
                "const": "T1H",
                "title": "Temperature",
                "description": "Celsius temperature"
              },
              {
                "const": "RN1",
                "title": "Hourly Precipitation",
                "description": "mm"
              }
            ],
            "title": "Category",
            "description": "Classification of what each value represents"
          },
          "nx": {
            "type": "number",
            "title": "Longitude"
          },
          "ny": {
            "type": "number",
            "title": "Latitude"
          },
          "obsrValue": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Value corresponding to the category"
          }
        },
        "required": [
          "baseDate",
          "baseTime",
          "category",
          "nx",
          "ny",
          "obsrValue"
        ]
      },
      "IOpenWeather.IResponse": {
        "type": "object",
        "properties": {
          "city_name": {
            "type": "string",
            "title": "City Name",
            "description": "city name"
          },
          "weather_main": {
            "type": "string",
            "title": "weather information",
            "description": "weather main information"
          },
          "weather_description": {
            "type": "string",
            "title": "weather description",
            "description": "weather description about weather main"
          },
          "temperature": {
            "type": "number",
            "title": "temperature",
            "description": "temperature"
          },
          "feel_like_temperature": {
            "type": "number",
            "title": "feel like temperature",
            "description": "feel like temperature"
          },
          "temperature_min": {
            "type": "number",
            "title": "minimum temperature",
            "description": "minimum temperature"
          },
          "temperature_max": {
            "type": "number",
            "title": "maximum temperature",
            "description": "maximum temperature"
          },
          "wind_speed": {
            "type": "number",
            "title": "wind_speed",
            "description": "wind_speed"
          },
          "humidity": {
            "type": "number",
            "title": "humidity",
            "description": "humidity"
          }
        },
        "required": [
          "city_name",
          "weather_main",
          "weather_description",
          "temperature",
          "feel_like_temperature",
          "temperature_min",
          "temperature_max",
          "wind_speed",
          "humidity"
        ],
        "title": "Get Weather Response"
      },
      "IKoreaMeteorologicalAdministration.IGetVillageForecastInformationInput": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "latitude_and_longitude",
                "title": "latitude and longitude"
              },
              {
                "const": "grid_coordinates",
                "title": "Grid Coordinates of Korean"
              }
            ],
            "title": "Definition of nx, ny\n\nuse 'latitude_and_longitude' or 'grid_coordinates'.\nThis property can never be used except for these two strings."
          },
          "nx": {
            "type": "number",
            "maximum": 360,
            "title": "Longitude or x_position\n\nIf the type property in this object is 'latitude_and_longitude', this value means longitude.\nIf not, use x position value of grid coordinates in Korea."
          },
          "ny": {
            "type": "number",
            "maximum": 180,
            "title": "Latitude or y_position\n\nIf the type property in this object is 'latitude_and_longitude', this value means latitude.\nIf not, use y position value of grid coordinates in Korea."
          }
        },
        "required": [
          "type",
          "nx",
          "ny"
        ],
        "title": "Weather query request conditions"
      },
      "KoreaCopyrightCommission.IGetCopyRightOutput": {
        "type": "object",
        "properties": {
          "currentCount": {
            "type": "integer",
            "title": "Current page count"
          },
          "matchCount": {
            "type": "integer",
            "title": "Number of copyrights matching the search criteria"
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGetCopyRightInputREG_IDCONT_TITLEAUTHOR_NAMEREG_DATEstringFormatdate"
            },
            "title": "Search Results"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "perPage": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          }
        },
        "required": [
          "currentCount",
          "matchCount",
          "data"
        ],
        "title": "Copyright search results"
      },
      "MyPickIGetCopyRightInputREG_IDCONT_TITLEAUTHOR_NAMEREG_DATEstringFormatdate": {
        "type": "object",
        "properties": {
          "REG_ID": {
            "type": "string",
            "title": "Copyright registration number",
            "description": "Only copyrights that match exactly are searched."
          },
          "CONT_TITLE": {
            "type": "string",
            "x-wrtn-placeholder": "제호 (명칭)",
            "title": "Title (Name)\n\nTitle refers to the name of the work."
          },
          "AUTHOR_NAME": {
            "type": "string",
            "x-wrtn-placeholder": "저작자 이름",
            "title": "Copyright holder name\n\nThis refers to the name of the copyright holder. It can be a person's name, or the name of a company or specific organization."
          },
          "REG_DATE": {
            "type": "string",
            "format": "date",
            "title": "Copyright registration date"
          }
        },
        "required": [
          "REG_DATE"
        ]
      },
      "KoreaCopyrightCommission.IGetCopyRightInput": {
        "type": "object",
        "properties": {
          "perPage": {
            "type": "integer",
            "default": 10,
            "title": "Number of results per page"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "Page number"
          },
          "REG_ID": {
            "type": "string",
            "title": "Copyright registration number",
            "description": "Only copyrights that match exactly are searched."
          },
          "CONT_TITLE": {
            "type": "string",
            "x-wrtn-placeholder": "제호 (명칭)",
            "title": "Title (Name)\n\nTitle refers to the name of the work."
          },
          "AUTHOR_NAME": {
            "type": "string",
            "x-wrtn-placeholder": "저작자 이름",
            "title": "Copyright holder name\n\nThis refers to the name of the copyright holder. It can be a person's name, or the name of a company or specific organization."
          }
        },
        "title": "Copyright inquiry conditions"
      },
      "IPrompt.IResponse": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "title": "Result received through input prompt"
          }
        },
        "required": [
          "result"
        ],
        "title": "prompt",
        "description": "Results received via"
      },
      "IPrompt.IRequest": {
        "type": "object",
        "properties": {
          "user_request": {
            "type": "string",
            "x-wrtn-placeholder": "제품 이름과 제품 특징을 참고해서 광고 문구를 기발하고 유머러스하게 만들어주세요.",
            "title": "User Request"
          },
          "system_prompt": {
            "type": "string",
            "x-wrtn-placeholder": "친절한 어투로 말해주세요.",
            "title": "System Prompt"
          }
        },
        "required": [
          "user_request"
        ],
        "title": "prompt input"
      },
      "IStoryGeneratorResponse": {
        "type": "object",
        "properties": {
          "done": {
            "type": "boolean",
            "title": "Whether the story has reached a natural conclusion and is ready to be outputted",
            "description": "Whether the story has reached a natural conclusion and is ready to be outputted."
          },
          "messageToUser": {
            "type": "string",
            "title": "When there is not enough information to create the next story line, prompt the user for more information",
            "description": "When there is not enough information to create the next story line, prompt the user for more information."
          },
          "storyLine": {
            "type": "string",
            "title": "If the next story line can be generated, provide it here",
            "description": "If the next story line can be generated, provide it here.\nOnly generate the story when you have a good idea of what the user wants.\nWhen the user is not sure, you can suggest stories but ask the user first before generating the story line."
          },
          "title": {
            "type": "string",
            "title": "If the entire story has been generated, provide the title here",
            "description": "If the entire story has been generated, provide the title here."
          }
        },
        "required": [
          "done"
        ],
        "description": "When there is not enough information to create the next story line, prompt the user for more information."
      },
      "IStoryGeneratorRequest": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string"
          },
          "chatHistory": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "role": {
                  "type": "string"
                },
                "content": {
                  "type": "string"
                }
              },
              "required": [
                "role",
                "content"
              ]
            }
          },
          "previousStories": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "query",
          "chatHistory",
          "previousStories"
        ]
      },
      "IStoryImage": {
        "type": "object",
        "properties": {
          "imageUrl": {
            "type": "string",
            "title": "Image URL.",
            "description": "Generated image URL."
          }
        },
        "required": [
          "imageUrl"
        ]
      },
      "IGenerateStoryImageInput": {
        "type": "object",
        "properties": {
          "storyLine": {
            "type": "string",
            "title": "The story to create the image for.",
            "description": "The story to create the image for."
          },
          "previousStories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Previous stories.",
            "description": "Previous stories."
          }
        },
        "required": [
          "storyLine",
          "previousStories"
        ],
        "title": "Input for image generation."
      },
      "IStableDiffusionBeta.IResponse": {
        "type": "object",
        "properties": {
          "imgUrl": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Generated image Url",
            "description": "Generated image url"
          }
        },
        "required": [
          "imgUrl"
        ],
        "title": "Image creation result"
      },
      "IStableDiffusionBeta.IRequest": {
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "title": "prompt",
            "description": "Please be specific about the elements, styles, and subjects you want to include in the image you want to generate. This prompt will instruct the model to reflect the desired features and details when generating the image."
          },
          "image_ratio": {
            "oneOf": [
              {
                "const": "square",
                "title": "정사각형",
                "description": "512x512"
              },
              {
                "const": "landscape",
                "title": "풍경",
                "description": "896x512"
              },
              {
                "const": "portrait",
                "title": "인물",
                "description": "512x896"
              }
            ],
            "title": "Image Size",
            "description": "Preset image size to generate.\n\nOnly three possible values are available: \"square\", \"landscape\", and \"portrait\"."
          },
          "style_preset": {
            "oneOf": [
              {
                "const": "3d-model",
                "title": "3D 모델"
              },
              {
                "const": "analog-film",
                "title": "아날로그 필름"
              },
              {
                "const": "anime",
                "title": "에니메이션"
              },
              {
                "const": "cinematic",
                "title": "영화"
              },
              {
                "const": "comic-book",
                "title": "만화"
              },
              {
                "const": "digital-art",
                "title": "디지털 아트"
              },
              {
                "const": "enhance",
                "title": "보정"
              },
              {
                "const": "fantasy-art",
                "title": "판타지 아트"
              },
              {
                "const": "isometric",
                "title": "등각뷰"
              },
              {
                "const": "line-art",
                "title": "라인 아트"
              },
              {
                "const": "low-poly",
                "title": "로우 폴리곤"
              },
              {
                "const": "modeling-compound",
                "title": "클레이 아트"
              },
              {
                "const": "neon-punk",
                "title": "네온 펑크"
              },
              {
                "const": "origami",
                "title": "종이 접기"
              },
              {
                "const": "photographic",
                "title": "사진"
              },
              {
                "const": "pixel-art",
                "title": "픽셀 아트"
              },
              {
                "const": "tile-texture",
                "title": "타일 텍스쳐"
              }
            ],
            "title": "Style Preset",
            "description": "Generates an image in a specific style.\n\nThere are only 16 possible values: \"3d-model\", \"analog-film\", \"anime\", \"cinematic\", \"comic-book\", \"digital-art\", \"enhance\", \"fantasy-art\", \"isometric\", \"line-art\", \"low-poly\", \"modeling-compound\", \"neon-punk\", \"origami\", \"photographic\", \"pixel-art\", \"tile-texture\"."
          }
        },
        "required": [
          "prompt",
          "image_ratio"
        ],
        "title": "Image Generator Settings"
      },
      "IDallE3.IResponse": {
        "type": "object",
        "properties": {
          "imgUrl": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Generated image Url",
            "description": "Generated image url"
          }
        },
        "required": [
          "imgUrl"
        ],
        "title": "Image creation result"
      },
      "IDallE3.IRequest": {
        "type": "object",
        "properties": {
          "prompt": {
            "type": "string",
            "title": "prompt",
            "description": "Prompt to create an image"
          },
          "image_ratio": {
            "oneOf": [
              {
                "const": "square",
                "title": "정사각형",
                "description": "1024x1024"
              },
              {
                "const": "landscape",
                "title": "풍경",
                "description": "1792x1024"
              },
              {
                "const": "portrait",
                "title": "인물",
                "description": "1024x1792"
              }
            ],
            "title": "Image Size",
            "description": "Preset image size to generate.\n\nOnly three possible values are available: \"square\", \"landscape\", and \"portrait\"."
          }
        },
        "required": [
          "prompt",
          "image_ratio"
        ],
        "title": "Information for image creation"
      },
      "IGoogleSearch.IResponse": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Search Results Title"
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Search Results Link"
          },
          "snippet": {
            "type": "string",
            "title": "Search Results Summary"
          },
          "thumbnail": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Search Results thumbnail"
          }
        },
        "required": [
          "title",
          "link"
        ],
        "title": "Search Results"
      },
      "IGoogleSearch.IRequest": {
        "type": "object",
        "properties": {
          "andKeywords": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "뤼튼"
            },
            "title": "Must-include keywords",
            "description": "Set keywords that must be included in search results."
          },
          "orKeywords": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "스튜디오"
            },
            "title": "Good keywords to enter",
            "description": "Set good keywords to enter the search results."
          },
          "notKeywords": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "폭력"
            },
            "title": "Keywords that should not be included",
            "description": "Set keywords that should not be included in search results."
          },
          "max_results": {
            "type": "integer",
            "title": "Number of search results",
            "description": "Set the number of search results."
          }
        },
        "required": [
          "andKeywords",
          "max_results"
        ],
        "title": "Conditions for searching"
      },
      "IGoogleShopping.IResponse": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Product name"
          },
          "link": {
            "oneOf": [
              {
                "const": "#",
                "title": "알 수 없는 링크"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Product Link"
          },
          "price": {
            "type": "string",
            "title": "Product Price",
            "description": "₩57,600 Format"
          },
          "source": {
            "type": "string",
            "title": "Product Source"
          },
          "deliveryCost": {
            "type": "string",
            "title": "Shipping fee"
          },
          "thumbnail": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "image/*",
            "title": "Product Image"
          }
        },
        "required": [
          "title",
          "link",
          "price",
          "thumbnail"
        ],
        "title": "Product search results"
      },
      "IGoogleShopping.IRequestStandAlone": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "title": "Search term",
            "description": "Enter the keyword you want to search for."
          },
          "max_results": {
            "type": "integer",
            "title": "Number of search results",
            "description": "Set the number of search results."
          }
        },
        "required": [
          "keyword",
          "max_results"
        ],
        "title": "Product search conditions"
      },
      "IGoogleAds.IGenerateKeywordIdeaOutput": {
        "type": "object",
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleAds.GeneratedKeyword"
            },
            "title": "Results List"
          },
          "totalSize": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Total number of results"
          },
          "nextPageToken": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Token that can be used when viewing the next page",
            "description": "If there is no next page, viewing is not possible"
          }
        },
        "required": [
          "results",
          "totalSize"
        ]
      },
      "IGoogleAds.GeneratedKeyword": {
        "type": "object",
        "properties": {
          "keywordIdeaMetrics": {
            "$ref": "#/components/schemas/IGoogleAds.KeywordIdeaMetrics",
            "title": "Keyword metrics"
          },
          "text": {
            "type": "string",
            "title": "keyword"
          }
        },
        "required": [
          "keywordIdeaMetrics",
          "text"
        ]
      },
      "IGoogleAds.KeywordIdeaMetrics": {
        "type": "object",
        "properties": {
          "competition": {
            "oneOf": [
              {
                "const": "LOW",
                "title": "낮음",
                "description": "낮은 경쟁률 경쟁 지수 범위는 [0, 33]입니다."
              },
              {
                "const": "MEDIUM",
                "title": "중간",
                "description": "경쟁이 보통입니다. 이에 대한 경쟁 지수의 범위는 [34, 66]입니다."
              },
              {
                "const": "HIGH",
                "title": "높음",
                "description": "경쟁이 치열합니다. 경쟁 지수 범위는 [67, 100]입니다."
              }
            ],
            "title": "Competition level for search terms"
          },
          "monthlySearchVolumes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleAds.MonthlySearchVolumes"
            },
            "title": "Approximate number of searches this search term has been run on in the last 12 months"
          },
          "avgMonthlySearches": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Approximate monthly searches for this search term over the past 12 months"
          },
          "competitionIndex": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Competition Index"
          },
          "lowTopOfPageBidMicros": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Keyword Micro Top Page Bid Subrange (20th Percentile)"
          },
          "highTopOfPageBidMicros": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "keyword detail page top bid (80th percentile)"
          }
        },
        "required": [
          "monthlySearchVolumes",
          "avgMonthlySearches"
        ]
      },
      "IGoogleAds.MonthlySearchVolumes": {
        "type": "object",
        "properties": {
          "month": {
            "oneOf": [
              {
                "const": "JANUARY",
                "title": "January"
              },
              {
                "const": "FEBRUARY",
                "title": "February"
              },
              {
                "const": "MARCH",
                "title": "March"
              },
              {
                "const": "APRIL",
                "title": "April"
              },
              {
                "const": "MAY",
                "title": "May"
              },
              {
                "const": "JUNE",
                "title": "June"
              },
              {
                "const": "JULY",
                "title": "July"
              },
              {
                "const": "AUGUST",
                "title": "August"
              },
              {
                "const": "SEPTEMBER",
                "title": "September"
              },
              {
                "const": "OCTOBER",
                "title": "October"
              },
              {
                "const": "NOVEMBER",
                "title": "November"
              },
              {
                "const": "DECEMBER",
                "title": "December"
              }
            ],
            "title": "The month in which the search volume occurred"
          },
          "year": {
            "type": "string",
            "title": "Year in which search volume occurred"
          },
          "monthlySearches": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$"
              }
            ],
            "title": "Approximate number of searches for the month",
            "description": "A null value indicates that search volume for the month is not available."
          }
        },
        "required": [
          "month",
          "year",
          "monthlySearches"
        ]
      },
      "IGoogleAds.IGenerateKeywordIdeaByKeywordsAndUrlInput": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "title": "Search keywords for keyword generation"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10000,
            "title": "Number of results per page"
          },
          "pageToken": {
            "type": "string",
            "title": "Next Page Token",
            "description": "Use the page token that can be received from the previous request."
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "url": {
            "type": "string",
            "title": "URL to reference when generating advertising keyword ideas."
          }
        },
        "required": [
          "keywords",
          "secretKey",
          "url"
        ]
      },
      "IGoogleAds.IGenerateKeywordIdeaByKeywordsInput": {
        "type": "object",
        "properties": {
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "title": "Search keywords for keyword generation"
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10000,
            "title": "Number of results per page"
          },
          "pageToken": {
            "type": "string",
            "title": "Next Page Token",
            "description": "Use the page token that can be received from the previous request."
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "keywords",
          "secretKey"
        ]
      },
      "IGoogleAds.IGenerateKeywordIdeaByURLInput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "title": "URL to reference when generating advertising keyword ideas."
          },
          "pageSize": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10000,
            "title": "Number of results per page"
          },
          "pageToken": {
            "type": "string",
            "title": "Next Page Token",
            "description": "Use the page token that can be received from the previous request."
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "url",
          "secretKey"
        ]
      },
      "IGoogleAds.ISecret": {
        "type": "object",
        "properties": {
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IGoogleAds.CustomerClient": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "title": "Customer ID",
            "description": "Each customer has a unique value."
          },
          "resourceName": {
            "type": "string",
            "pattern": "^(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/customerClients\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Customer Resource Name"
          },
          "descriptiveName": {
            "type": "string",
            "title": "Specified name"
          },
          "currencyCode": {
            "type": "string",
            "title": "Currency unit, currency code",
            "description": "Means 'USD', 'EUR', 'KRW', etc."
          }
        },
        "required": [
          "id",
          "resourceName",
          "currencyCode"
        ]
      },
      "IGoogleAds.IGetCustomerInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IGoogleAds.IGetCampaignsOutputResult": {
        "type": "object",
        "properties": {
          "campaign": {
            "$ref": "#/components/schemas/IGoogleAds.Campaign",
            "title": "Campaign Information"
          },
          "campaignBudget": {
            "$ref": "#/components/schemas/IGoogleAds.CampaignBudget",
            "title": "Campaign Budget Information"
          }
        },
        "required": [
          "campaign",
          "campaignBudget"
        ],
        "title": "Campaign Information"
      },
      "IGoogleAds.Campaign": {
        "type": "object",
        "properties": {
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/campaigns\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/campaigns/1",
            "title": "Campaign Resource Name"
          },
          "status": {
            "oneOf": [
              {
                "const": "ENABLED",
                "title": "ENABLED"
              },
              {
                "const": "PAUSED",
                "title": "PAUSED"
              },
              {
                "const": "REMOVED",
                "title": "REMOVED"
              },
              {
                "const": "UNKNOWN",
                "title": "UNKNOWN"
              },
              {
                "const": "UNSPECIFIED",
                "title": "UNSPECIFIED"
              }
            ],
            "title": "Campaign Status"
          },
          "advertisingChannelType": {
            "oneOf": [
              {
                "const": "DEMAND_GEN",
                "title": "DEMAND_GEN"
              },
              {
                "const": "DISPLAY",
                "title": "DISPLAY"
              },
              {
                "const": "HOTEL",
                "title": "HOTEL"
              },
              {
                "const": "LOCAL",
                "title": "LOCAL"
              },
              {
                "const": "LOCAL_SERVICES",
                "title": "LOCAL_SERVICES"
              },
              {
                "const": "MULTI_CHANNEL",
                "title": "MULTI_CHANNEL"
              },
              {
                "const": "PERFORMANCE_MAX",
                "title": "PERFORMANCE_MAX"
              },
              {
                "const": "SEARCH",
                "title": "SEARCH"
              },
              {
                "const": "SHOPPING",
                "title": "SHOPPING"
              },
              {
                "const": "SMART",
                "title": "SMART"
              },
              {
                "const": "TRAVEL",
                "title": "TRAVEL"
              },
              {
                "const": "UNKNOWN",
                "title": "UNKNOWN"
              },
              {
                "const": "UNSPECIFIED",
                "title": "UNSPECIFIED"
              },
              {
                "const": "VIDEO",
                "title": "VIDEO"
              }
            ],
            "title": "Campaign Advertising Channel"
          },
          "name": {
            "type": "string",
            "title": "Campaign Name"
          },
          "id": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "title": "Campaign ID"
          },
          "startDate": {
            "type": "string",
            "format": "date",
            "title": "Campaign start date"
          },
          "endDate": {
            "type": "string",
            "format": "date",
            "title": "Campaign End Date"
          }
        },
        "required": [
          "resourceName",
          "status",
          "advertisingChannelType",
          "name",
          "id",
          "startDate",
          "endDate"
        ],
        "title": "Google Ads Campaign"
      },
      "IGoogleAds.CampaignBudget": {
        "type": "object",
        "properties": {
          "resourceName": {
            "type": "string",
            "pattern": "^(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/campaignBudgets\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Campaign Budget Resource Name"
          },
          "amountMicros": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Budget (micro units)"
          }
        },
        "required": [
          "resourceName",
          "amountMicros"
        ]
      },
      "IGoogleAds.IGetAdGroupsOutputResult": {
        "type": "object",
        "properties": {
          "campaign": {
            "$ref": "#/components/schemas/MyPickIGoogleAds.CampaignidresourceNamestatus",
            "title": "campaign"
          },
          "adGroup": {
            "$ref": "#/components/schemas/MyPickIGoogleAds.AdGrouptypeidresourceName",
            "title": "Ad Group"
          },
          "adGroupAds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGoogleAds.AdGroupAdresourceNamepolicySummary"
            },
            "title": "List of ads in ad group"
          },
          "keywords": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeepStrictMergeHelperIGoogleAds.KeywordMyPickIGoogleAds.AdGroupCriterionresourceNamecriterionId"
            },
            "title": "Keyword List"
          }
        },
        "required": [
          "campaign",
          "adGroup",
          "adGroupAds",
          "keywords"
        ]
      },
      "MyPickIGoogleAds.CampaignidresourceNamestatus": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "title": "Campaign ID"
          },
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/campaigns\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/campaigns/1",
            "title": "Campaign Resource Name"
          },
          "status": {
            "oneOf": [
              {
                "const": "ENABLED",
                "title": "ENABLED"
              },
              {
                "const": "PAUSED",
                "title": "PAUSED"
              },
              {
                "const": "REMOVED",
                "title": "REMOVED"
              },
              {
                "const": "UNKNOWN",
                "title": "UNKNOWN"
              },
              {
                "const": "UNSPECIFIED",
                "title": "UNSPECIFIED"
              }
            ],
            "title": "Campaign Status"
          }
        },
        "required": [
          "id",
          "resourceName",
          "status"
        ]
      },
      "MyPickIGoogleAds.AdGrouptypeidresourceName": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "SEARCH_STANDARD",
                "title": "검색 광고"
              },
              {
                "const": "DISPLAY_STANDARD",
                "title": "디스플레이 광고"
              }
            ],
            "title": "Type of ad group"
          },
          "id": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "ID of the advertising group"
          },
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroups\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroups/1",
            "title": "Ad Group Resource Name",
            "description": "`customers/${number}/adGroups/${number}` format"
          }
        },
        "required": [
          "type",
          "id",
          "resourceName"
        ]
      },
      "MyPickIGoogleAds.AdGroupAdresourceNamepolicySummary": {
        "type": "object",
        "properties": {
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroupAds\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupAds/1~1",
            "title": "Resource name of the ad group ad",
            "description": "`customers/${number}/adGroupAds/${number}~${number}` format"
          },
          "policySummary": {
            "type": "object",
            "properties": {
              "approvalStatus": {
                "oneOf": [
                  {
                    "const": "APPROVED",
                    "title": "승인됨"
                  },
                  {
                    "const": "APPROVED_LIMITED",
                    "title": "제한된 승인"
                  },
                  {
                    "const": "AREA_OF_INTEREST_ONLY",
                    "title": "특정 영역에 대한 허용"
                  },
                  {
                    "const": "DISAPPROVED",
                    "title": "비승인"
                  },
                  {
                    "const": "UNKNOWN",
                    "title": "알 수 없음"
                  },
                  {
                    "const": "UNSPECIFIED",
                    "title": "명시되지 않음"
                  }
                ],
                "title": "Ad approval status",
                "description": "This is Google's decision on whether or not the ad can be sent."
              },
              "reviewStatus": {
                "oneOf": [
                  {
                    "const": "ELIGIBLE_MAY_SERVE",
                    "title": "자격을 갖춤"
                  },
                  {
                    "const": "REVIEWED",
                    "title": "검토되었음"
                  },
                  {
                    "const": "REVIEW_IN_PROGRESS",
                    "title": "검토 중임"
                  },
                  {
                    "const": "UNDER_APPEAL",
                    "title": "심사 중임"
                  },
                  {
                    "const": "UNKNOWN",
                    "title": "알 수 없음"
                  },
                  {
                    "const": "UNSPECIFIED",
                    "title": "명시되지 않음"
                  }
                ],
                "title": "Ad Review Status",
                "description": "Only ads that have been reviewed can see whether they have been approved or disapproved."
              }
            },
            "required": [
              "approvalStatus",
              "reviewStatus"
            ],
            "title": "Evaluation of advertising review and policies"
          }
        },
        "required": [
          "resourceName",
          "policySummary"
        ]
      },
      "DeepStrictMergeHelperIGoogleAds.KeywordMyPickIGoogleAds.AdGroupCriterionresourceNamecriterionId": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string"
          },
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/(.*)\\/adGroupCriteria\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupCriteria/1"
          },
          "criterionId": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$"
          },
          "matchType": {
            "oneOf": [
              {
                "const": "UNSPECIFIED",
                "title": "명시되지 않음"
              },
              {
                "const": "UNKNOWN",
                "title": "알 수 없음"
              },
              {
                "const": "EXACT",
                "title": "완전일치"
              },
              {
                "const": "PHRASE",
                "title": "구문일치"
              },
              {
                "const": "BROAD",
                "title": "확장검색"
              }
            ]
          }
        },
        "required": [
          "text",
          "resourceName",
          "criterionId",
          "matchType"
        ]
      },
      "IGoogleAds.IGetAdGroupInput": {
        "type": "object",
        "properties": {
          "campaignId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-campaigns",
              "jmesPath": "[].campaign.{value:name, label:id}"
            },
            "title": "ID of the parent campaign",
            "description": "If you only want to search for the ID of the campaign"
          },
          "adGroupResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroups\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroups/1",
            "title": "Resource name of the ad group",
            "description": "If you want to search only by the ad group resource name"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "MyPickIGoogleAds.AdGroupAdresourceNamestatuspolicySummary": {
        "type": "object",
        "properties": {
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroupAds\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupAds/1~1",
            "title": "Resource name of the ad group ad",
            "description": "`customers/${number}/adGroupAds/${number}~${number}` format"
          },
          "status": {
            "oneOf": [
              {
                "const": "ENABLED",
                "title": "ENABLED"
              },
              {
                "const": "PAUSED",
                "title": "PAUSED"
              },
              {
                "const": "REMOVED",
                "title": "REMOVED"
              },
              {
                "const": "UNKNOWN",
                "title": "UNKNOWN"
              },
              {
                "const": "UNSPECIFIED",
                "title": "UNSPECIFIED"
              }
            ],
            "title": "Status of the ad"
          },
          "policySummary": {
            "type": "object",
            "properties": {
              "approvalStatus": {
                "oneOf": [
                  {
                    "const": "APPROVED",
                    "title": "승인됨"
                  },
                  {
                    "const": "APPROVED_LIMITED",
                    "title": "제한된 승인"
                  },
                  {
                    "const": "AREA_OF_INTEREST_ONLY",
                    "title": "특정 영역에 대한 허용"
                  },
                  {
                    "const": "DISAPPROVED",
                    "title": "비승인"
                  },
                  {
                    "const": "UNKNOWN",
                    "title": "알 수 없음"
                  },
                  {
                    "const": "UNSPECIFIED",
                    "title": "명시되지 않음"
                  }
                ],
                "title": "Ad approval status",
                "description": "This is Google's decision on whether or not the ad can be sent."
              },
              "reviewStatus": {
                "oneOf": [
                  {
                    "const": "ELIGIBLE_MAY_SERVE",
                    "title": "자격을 갖춤"
                  },
                  {
                    "const": "REVIEWED",
                    "title": "검토되었음"
                  },
                  {
                    "const": "REVIEW_IN_PROGRESS",
                    "title": "검토 중임"
                  },
                  {
                    "const": "UNDER_APPEAL",
                    "title": "심사 중임"
                  },
                  {
                    "const": "UNKNOWN",
                    "title": "알 수 없음"
                  },
                  {
                    "const": "UNSPECIFIED",
                    "title": "명시되지 않음"
                  }
                ],
                "title": "Ad Review Status",
                "description": "Only ads that have been reviewed can see whether they have been approved or disapproved."
              }
            },
            "required": [
              "approvalStatus",
              "reviewStatus"
            ],
            "title": "Evaluation of advertising review and policies"
          }
        },
        "required": [
          "resourceName",
          "status",
          "policySummary"
        ]
      },
      "IGoogleAds.IGetAdGroupAdInput": {
        "type": "object",
        "properties": {
          "adGroupAdResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroupAds\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupAds/1~1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-ads",
              "jmesPath": "[].{value:resourceName, label:resourceName}"
            },
            "title": "Resource name of the ad group ad"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IGoogleAds.IGetMetricOutputResult": {
        "type": "object",
        "properties": {
          "metrics": {
            "type": "object",
            "properties": {
              "impressions": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "Number of exposures"
              },
              "clicks": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "Clicks"
              },
              "costMicros": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "Advertising Spend (in micro units)",
                "description": "KRW value expressed in 1/1,000,000"
              },
              "videoViews": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "Video View"
              },
              "averagePageViews": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "Average Page Views"
              },
              "videoQuartileP25Rate": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "25% of the videos were viewed"
              },
              "videoQuartileP50Rate": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "50% of the video was viewed"
              },
              "videoQuartileP75Rate": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "75% of the videos were viewed"
              },
              "videoQuartileP100Rate": {
                "type": "string",
                "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "100% of the video has been viewed"
              }
            },
            "required": [
              "impressions",
              "clicks",
              "costMicros",
              "videoViews"
            ]
          },
          "adGroupAd": {
            "$ref": "#/components/schemas/MyPickIGoogleAds.AdGroupAdresourceName"
          }
        },
        "required": [
          "metrics",
          "adGroupAd"
        ]
      },
      "MyPickIGoogleAds.AdGroupAdresourceName": {
        "type": "object",
        "properties": {
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroupAds\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupAds/1~1",
            "title": "Resource name of the ad group ad",
            "description": "`customers/${number}/adGroupAds/${number}~${number}` format"
          }
        },
        "required": [
          "resourceName"
        ]
      },
      "IGoogleAds.IGetMetricInput": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "format": "date",
            "title": "Statistics query date"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "date",
          "secretKey"
        ]
      },
      "IGoogleAds.IGetKeywordsOutputResult": {
        "type": "object",
        "properties": {
          "adGroupCriterion": {
            "$ref": "#/components/schemas/MyPickAdGroupCriteriontypekeywordresourceNamestatuscriterionIdKeyword"
          }
        },
        "required": [
          "adGroupCriterion"
        ]
      },
      "MyPickAdGroupCriteriontypekeywordresourceNamestatuscriterionIdKeyword": {
        "type": "object",
        "properties": {
          "type": {
            "const": "KEYWORD",
            "title": "type"
          },
          "keyword": {
            "$ref": "#/components/schemas/IGoogleAds.Keyword",
            "title": "keyword"
          },
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/(.*)\\/adGroupCriteria\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupCriteria/1",
            "title": "Ad Group Standard Resource Name\n\nFormat: `customers/${number}/adGroupCriteria/number~${number}`"
          },
          "status": {
            "oneOf": [
              {
                "const": "ENABLED",
                "title": "ENABLED"
              },
              {
                "const": "PAUSED",
                "title": "PAUSED"
              },
              {
                "const": "REMOVED",
                "title": "REMOVED"
              },
              {
                "const": "UNKNOWN",
                "title": "UNKNOWN"
              },
              {
                "const": "UNSPECIFIED",
                "title": "UNSPECIFIED"
              }
            ],
            "title": "Ad Group Standard Status"
          },
          "criterionId": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "Ad Group Standard ID"
          },
          "text": {
            "type": "string",
            "title": "Keyword Text"
          },
          "matchType": {
            "oneOf": [
              {
                "const": "UNSPECIFIED",
                "title": "명시되지 않음"
              },
              {
                "const": "UNKNOWN",
                "title": "알 수 없음"
              },
              {
                "const": "EXACT",
                "title": "완전일치"
              },
              {
                "const": "PHRASE",
                "title": "구문일치"
              },
              {
                "const": "BROAD",
                "title": "확장검색"
              }
            ],
            "title": "Keyword Match Type"
          }
        },
        "required": [
          "type",
          "keyword",
          "resourceName",
          "status",
          "criterionId",
          "text",
          "matchType"
        ]
      },
      "IGoogleAds.Keyword": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "Keyword Text"
          },
          "matchType": {
            "oneOf": [
              {
                "const": "UNSPECIFIED",
                "title": "명시되지 않음"
              },
              {
                "const": "UNKNOWN",
                "title": "알 수 없음"
              },
              {
                "const": "EXACT",
                "title": "완전일치"
              },
              {
                "const": "PHRASE",
                "title": "구문일치"
              },
              {
                "const": "BROAD",
                "title": "확장검색"
              }
            ],
            "title": "Keyword Match Type"
          }
        },
        "required": [
          "text",
          "matchType"
        ]
      },
      "IGoogleAds.IGetKeywordsInput": {
        "type": "object",
        "properties": {
          "adGroupResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroups\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroups/1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-ad-groups",
              "jmesPath": "[].adGroup.{value:resourceName, label:resourceName}"
            },
            "title": "Ad Group Resource Name"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "adGroupResourceName",
          "secretKey"
        ],
        "title": "Keyword search conditions"
      },
      "IGoogleAds.ISetOnOffInput": {
        "type": "object",
        "properties": {
          "adGroupAdResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroupAds\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupAds/1~1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-ads",
              "jmesPath": "[].{value:resourceName, label:resourceName}"
            },
            "title": "Resource name of the ad group ad"
          },
          "status": {
            "oneOf": [
              {
                "const": "ENABLED",
                "title": "ENABLED"
              },
              {
                "const": "PAUSED",
                "title": "PAUSED"
              }
            ],
            "title": "Ad Status"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "adGroupAdResourceName",
          "status",
          "secretKey"
        ]
      },
      "IGoogleAds.IDeleteAdGroupCriteriaInput": {
        "type": "object",
        "properties": {
          "resourceNames": {
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "(customers\\/(.*)\\/adGroupCriteria\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
              "x-wrtn-placeholder": "customers/1/adGroupCriteria/1",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "connector/google-ads/get-keywords",
                "jmesPath": "[].adGroupCriterion.{value:resourceName, label:text}"
              }
            },
            "title": "ID of the keyword to be deleted"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "resourceNames",
          "secretKey"
        ],
        "title": "Keyword deletion condition"
      },
      "IGoogleAds.ICreateAdGroupCriteriaInput": {
        "type": "object",
        "properties": {
          "adGroupResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroups\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroups/1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-ad-groups",
              "jmesPath": "[].adGroup.{value:resourceName, label:resourceName}"
            },
            "title": "Resource name of the ad group to which you want to add the keyword."
          },
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Keyword to generate"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "adGroupResourceName",
          "keywords",
          "secretKey"
        ]
      },
      "IGoogleAds.IGetAdGroupAdDetailOutput": {
        "type": "object",
        "properties": {
          "resourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroupAds\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupAds/1~1",
            "title": "Resource name of the ad group ad"
          },
          "status": {
            "oneOf": [
              {
                "const": "ENABLED",
                "title": "ENABLED"
              },
              {
                "const": "PAUSED",
                "title": "PAUSED"
              },
              {
                "const": "REMOVED",
                "title": "REMOVED"
              },
              {
                "const": "UNKNOWN",
                "title": "UNKNOWN"
              },
              {
                "const": "UNSPECIFIED",
                "title": "UNSPECIFIED"
              }
            ],
            "title": "Current status of advertising"
          },
          "ad": {
            "type": "object",
            "properties": {
              "resourceName": {
                "type": "string",
                "pattern": "^(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/ads\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
                "title": "Resource name of the advertisement"
              },
              "detail": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/IGoogleAds.ResponsiveSearchAd"
                  },
                  {
                    "$ref": "#/components/schemas/IGoogleAds.ResponsiveDisplayAd"
                  }
                ],
                "title": "Advertising material information"
              }
            },
            "required": [
              "resourceName",
              "detail"
            ],
            "title": "Viewed Ad History"
          }
        },
        "required": [
          "resourceName",
          "status",
          "ad"
        ]
      },
      "IGoogleAds.ResponsiveSearchAd": {
        "type": "object",
        "properties": {
          "descriptions": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "title": "Registered description"
                }
              },
              "required": [
                "text"
              ]
            },
            "title": "Description List"
          },
          "headlines": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "title": "Registered title"
                }
              },
              "required": [
                "text"
              ]
            },
            "title": "List of titles"
          }
        },
        "required": [
          "descriptions",
          "headlines"
        ]
      },
      "IGoogleAds.ResponsiveDisplayAd": {
        "type": "object",
        "properties": {
          "longHeadline": {
            "title": "long title"
          },
          "businessName": {
            "title": "Brand Name"
          },
          "marketingImages": {},
          "squareMarketingImages": {},
          "squareLogoImages": {},
          "descriptions": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "title": "Registered description"
                }
              },
              "required": [
                "text"
              ]
            },
            "title": "Description List"
          },
          "headlines": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "title": "Registered title"
                }
              },
              "required": [
                "text"
              ]
            },
            "title": "List of titles"
          }
        },
        "required": [
          "longHeadline",
          "businessName",
          "marketingImages",
          "squareMarketingImages",
          "squareLogoImages",
          "descriptions",
          "headlines"
        ]
      },
      "IGoogleAds.IGetAdGroupAdDetailInput": {
        "type": "object",
        "properties": {
          "adGroupAdResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/adGroupAds\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?~[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/adGroupAds/1~1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-ads",
              "jmesPath": "[].{value:resourceName, label:resourceName}"
            },
            "title": "Resource name of the ad group ad"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "adGroupAdResourceName",
          "secretKey"
        ]
      },
      "ISecretICreateAdGroupSearchAdInput": {
        "type": "object",
        "properties": {
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "finalUrl": {
            "type": "string",
            "format": "iri",
            "title": "Homepage that is the target of the advertisement"
          },
          "headlines": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 30
            },
            "minItems": 1,
            "maxItems": 15,
            "title": "title list"
          },
          "descriptions": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 90
            },
            "minItems": 1,
            "maxItems": 4,
            "title": "Description List"
          },
          "type": {
            "const": "SEARCH_STANDARD",
            "title": "Ad Group Type"
          },
          "campaignResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/campaigns\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/campaigns/1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-campaigns",
              "jmesPath": "[].campaign.{value:name, label:id}"
            },
            "title": "Campaign Resource Name"
          },
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Keyword to generate"
          }
        },
        "required": [
          "customerId",
          "secretKey",
          "finalUrl",
          "headlines",
          "descriptions",
          "type",
          "campaignResourceName",
          "keywords"
        ]
      },
      "ISecretICreateAdGroupDisplayAdInput": {
        "type": "object",
        "properties": {
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "finalUrl": {
            "type": "string",
            "format": "iri",
            "title": "Homepage that is the target of the advertisement"
          },
          "headlines": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 30
            },
            "minItems": 1,
            "maxItems": 5,
            "title": "List of short titles"
          },
          "longHeadline": {
            "type": "string",
            "minLength": 1,
            "maxLength": 90,
            "title": "long title"
          },
          "descriptions": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 90
            },
            "minItems": 1,
            "maxItems": 5,
            "title": "Description List"
          },
          "businessName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 25,
            "title": "Business and Brand Name"
          },
          "landscapeImages": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*"
            },
            "minItems": 1,
            "maxItems": 15,
            "title": "Landscape image",
            "description": "Landscape image with 1.91:1 resolution, recommended 5 frames"
          },
          "logoImages": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*"
            },
            "minItems": 1,
            "maxItems": 5,
            "title": "Logo image",
            "description": "Square image, minimum size 128x128px, recommended 1200x1200px"
          },
          "squareImages": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*"
            },
            "minItems": 1,
            "maxItems": 15,
            "title": "Square image",
            "description": "A landscape image with a 1.91:1 aspect ratio, with a minimum size of 300x300px, and a recommended size of 600x600px."
          },
          "type": {
            "const": "DISPLAY_STANDARD",
            "title": "Ad Group Type"
          },
          "campaignResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/campaigns\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/campaigns/1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-campaigns",
              "jmesPath": "[].campaign.{value:name, label:id}"
            },
            "title": "Campaign Resource Name"
          },
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Keyword to generate"
          }
        },
        "required": [
          "customerId",
          "secretKey",
          "finalUrl",
          "headlines",
          "longHeadline",
          "descriptions",
          "businessName",
          "landscapeImages",
          "logoImages",
          "squareImages",
          "type",
          "campaignResourceName",
          "keywords"
        ]
      },
      "IGoogleAds.IUpdateCampaignInput": {
        "type": "object",
        "properties": {
          "campaignResourceName": {
            "type": "string",
            "pattern": "(customers\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\/campaigns\\/[+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "customers/1/campaigns/1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-campaigns",
              "jmesPath": "[].campaign.{value:name, label:id}"
            },
            "title": "Resource ID of the campaign to be modified"
          },
          "campaignName": {
            "type": "string",
            "title": "Campaign Name\n\nIf the name is left blank, a random name will be generated. The name must not be the same as a previously created campaign."
          },
          "campaignBudget": {
            "type": "number",
            "maximum": 100000,
            "title": "Advertising Budget",
            "description": "Korean currency unit, Won\n\nOriginally, there is no limit on the amount, but in preparation for an emergency, the function is currently limited to 100,000 won per campaign."
          },
          "endDate": {
            "type": "string",
            "format": "date",
            "title": "Campaign End Time"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          }
        },
        "required": [
          "campaignResourceName",
          "secretKey"
        ],
        "title": "Campaign Modification Conditions"
      },
      "IGoogleAds.ICreateCampaignInput": {
        "type": "object",
        "properties": {
          "advertisingChannelType": {
            "oneOf": [
              {
                "const": "SEARCH",
                "title": "검색 광고",
                "description": "Google 검색에서 구매 의도가 높은 고객에게 적시에 노출"
              },
              {
                "const": "DISPLAY",
                "title": "디스플레이 광고",
                "description": "눈에 잘 띄는 광고 소재로 3백만 사이트와 앱에서 고객에게 도달",
                "default": "SEARCH"
              }
            ],
            "title": "Campaign Type"
          },
          "campaignName": {
            "type": "string",
            "title": "Campaign Name\n\nIf the name is left blank, a random name will be generated. The name must not be the same as a previously created campaign."
          },
          "startDate": {
            "type": "string",
            "format": "date",
            "title": "Campaign start time"
          },
          "endDate": {
            "type": "string",
            "format": "date",
            "title": "Campaign End Time"
          },
          "campaignBudget": {
            "type": "number",
            "maximum": 100000,
            "title": "Advertising Budget",
            "description": "Korean currency unit, Won\n\nOriginally, there is no limit on the amount, but in preparation for an emergency, the function is currently limited to 100,000 won per campaign."
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "advertisingChannelType",
          "campaignBudget",
          "secretKey"
        ]
      },
      "DeepStrictMergeHelperIGoogleAds.IGetCampaignsOutputResultIGoogleAds.AdWrapper": {
        "type": "object",
        "properties": {
          "ad": {
            "$ref": "#/components/schemas/IGoogleAds.IGetAdGroupsOutputResult"
          },
          "campaignBudget": {
            "$ref": "#/components/schemas/IGoogleAds.CampaignBudget"
          },
          "campaign": {
            "$ref": "#/components/schemas/IGoogleAds.Campaign"
          }
        },
        "required": [
          "ad",
          "campaignBudget",
          "campaign"
        ]
      },
      "IGoogleAds.ICreateAdGroupSearchAdAtOnceInput": {
        "type": "object",
        "properties": {
          "ad": {
            "$ref": "#/components/schemas/StrictOmitIGoogleAds.ICreateAdGroupSearchAdInputtypecustomerIdcampaignResourceName",
            "title": "Ad Creation Conditions"
          },
          "campaign": {
            "$ref": "#/components/schemas/StrictOmitIGoogleAds.ICreateCampaignInputsecretKeycustomerId",
            "title": "Campaign Creation Conditions"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "ad",
          "campaign",
          "secretKey"
        ],
        "title": "Request conditions for creating Google search campaigns and ads all at once"
      },
      "StrictOmitIGoogleAds.ICreateAdGroupSearchAdInputtypecustomerIdcampaignResourceName": {
        "type": "object",
        "properties": {
          "descriptions": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 90
            },
            "minItems": 1,
            "maxItems": 4,
            "title": "Description List"
          },
          "headlines": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 30
            },
            "minItems": 1,
            "maxItems": 15,
            "title": "title list"
          },
          "finalUrl": {
            "type": "string",
            "format": "iri",
            "title": "Homepage that is the target of the advertisement"
          },
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Keyword to generate"
          }
        },
        "required": [
          "descriptions",
          "headlines",
          "finalUrl",
          "keywords"
        ]
      },
      "StrictOmitIGoogleAds.ICreateCampaignInputsecretKeycustomerId": {
        "type": "object",
        "properties": {
          "campaignName": {
            "type": "string",
            "title": "Campaign Name\n\nIf the name is left blank, a random name will be generated. The name must not be the same as a previously created campaign."
          },
          "campaignBudget": {
            "type": "number",
            "maximum": 100000,
            "title": "Advertising Budget",
            "description": "Korean currency unit, Won\n\nOriginally, there is no limit on the amount, but in preparation for an emergency, the function is currently limited to 100,000 won per campaign."
          },
          "endDate": {
            "type": "string",
            "format": "date",
            "title": "Campaign End Time"
          },
          "advertisingChannelType": {
            "oneOf": [
              {
                "const": "SEARCH",
                "title": "검색 광고",
                "description": "Google 검색에서 구매 의도가 높은 고객에게 적시에 노출"
              },
              {
                "const": "DISPLAY",
                "title": "디스플레이 광고",
                "description": "눈에 잘 띄는 광고 소재로 3백만 사이트와 앱에서 고객에게 도달",
                "default": "SEARCH"
              }
            ],
            "title": "Campaign Type"
          },
          "startDate": {
            "type": "string",
            "format": "date",
            "title": "Campaign start time"
          }
        },
        "required": [
          "campaignBudget",
          "advertisingChannelType"
        ]
      },
      "IGoogleAds.ICreateAdGroupDisplayAdAtOnceInput": {
        "type": "object",
        "properties": {
          "ad": {
            "$ref": "#/components/schemas/StrictOmitIGoogleAds.ICreateAdGroupDisplayAdInputtypecustomerIdcampaignResourceName",
            "title": "Ad Creation Conditions"
          },
          "campaign": {
            "$ref": "#/components/schemas/StrictOmitIGoogleAds.ICreateCampaignInputsecretKeycustomerId",
            "title": "Campaign Creation Conditions"
          },
          "customerId": {
            "type": "string",
            "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
            "x-wrtn-placeholder": "1",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/google-ads/get-customers",
              "jmesPath": "[].{value:id, label:id}"
            },
            "title": "Customer Resource ID",
            "description": "This is the customer's resource ID.\n\nIt means the remaining number format after removing 'customers/' from the `customers/${number}` format.\n\n`Wrtn`'s `google ads`-related connectors must receive the `customerId` property to determine which advertising account the customer has, that is, which advertising account among the customers, to use.\n\nSince most users have only one advertising account, if `customerId` is not provided as an argument, the advertising account that is retrieved as number 0 is used unconditionally.\n\nIf a user with two or more advertising accounts does not provide `customerId`, it is always considered a failure."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "google",
            "x-wrtn-secret-scopes": [
              "https://www.googleapis.com/auth/adwords"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "ad",
          "campaign",
          "secretKey"
        ],
        "title": "Request conditions for creating ads from Google display campaigns at once"
      },
      "StrictOmitIGoogleAds.ICreateAdGroupDisplayAdInputtypecustomerIdcampaignResourceName": {
        "type": "object",
        "properties": {
          "descriptions": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 90
            },
            "minItems": 1,
            "maxItems": 5,
            "title": "Description List"
          },
          "headlines": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 30
            },
            "minItems": 1,
            "maxItems": 5,
            "title": "List of short titles"
          },
          "finalUrl": {
            "type": "string",
            "format": "iri",
            "title": "Homepage that is the target of the advertisement"
          },
          "keywords": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Keyword to generate"
          },
          "longHeadline": {
            "type": "string",
            "minLength": 1,
            "maxLength": 90,
            "title": "long title"
          },
          "businessName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 25,
            "title": "Business and Brand Name"
          },
          "landscapeImages": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*"
            },
            "minItems": 1,
            "maxItems": 15,
            "title": "Landscape image",
            "description": "Landscape image with 1.91:1 resolution, recommended 5 frames"
          },
          "logoImages": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*"
            },
            "minItems": 1,
            "maxItems": 5,
            "title": "Logo image",
            "description": "Square image, minimum size 128x128px, recommended 1200x1200px"
          },
          "squareImages": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*"
            },
            "minItems": 1,
            "maxItems": 15,
            "title": "Square image",
            "description": "A landscape image with a 1.91:1 aspect ratio, with a minimum size of 300x300px, and a recommended size of 600x600px."
          }
        },
        "required": [
          "descriptions",
          "headlines",
          "finalUrl",
          "keywords",
          "longHeadline",
          "businessName",
          "landscapeImages",
          "logoImages",
          "squareImages"
        ]
      },
      "IConnector.ISearchOutput": {
        "type": "object",
        "properties": {
          "references": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IConnector.IReferenceContent"
            },
            "title": "Output Information",
            "description": "Contains output information for search results."
          }
        },
        "required": [
          "references"
        ],
        "title": "Search Results"
      },
      "IConnector.ISearchInput": {
        "type": "object",
        "properties": {
          "num_results": {
            "type": "integer",
            "x-wrtn-placeholder": "10",
            "title": "Number of search results",
            "description": "Sets how many search results to retrieve."
          },
          "from_date": {
            "type": "string",
            "format": "date",
            "title": "Start date for search results",
            "description": "Set the start date for search results."
          },
          "to_date": {
            "type": "string",
            "format": "date",
            "title": "End date for the search results",
            "description": "Set the end date for the search results."
          },
          "and_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "biology"
            },
            "title": "Must be included keywords",
            "description": "Keywords that must be included in search results."
          },
          "or_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "ecosystem"
            },
            "title": "Keywords that you would like to see included",
            "description": "Keywords that you would like to see included in your search results."
          },
          "not_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "pollution"
            },
            "title": "Keywords that should not be included",
            "description": "Keywords that should not be included in search results."
          }
        },
        "required": [
          "and_keywords"
        ],
        "title": "Search criteria",
        "description": "Enter your search criteria."
      },
      "IDaum.IBlogDaumOutput": {
        "type": "object",
        "properties": {
          "meta": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "title": "Number of searched contents",
                "description": "Total number of documents searched."
              },
              "pageableCount": {
                "type": "number",
                "title": "The number of content that can be exposed among the searched documents",
                "description": "The number of content that can be exposed among the searched documents."
              },
              "isEnd": {
                "type": "boolean",
                "title": "Whether the current page is the last page",
                "description": "If the value is false, you can request the next page by incrementing page."
              }
            },
            "required": [
              "totalCount",
              "pageableCount",
              "isEnd"
            ]
          },
          "documents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "title": "The title of the document",
                  "description": "The title of the document searched."
                },
                "contents": {
                  "type": "string",
                  "title": "Part of the text of the document",
                  "description": "This is part of the text of the document that was searched."
                },
                "url": {
                  "type": "string",
                  "title": "Document URL",
                  "description": "The URL of the document being searched."
                },
                "blogName": {
                  "type": "string",
                  "title": "The name of the blog",
                  "description": "The name of the blog searched."
                },
                "thumbnail": {
                  "type": "string",
                  "contentMediaType": "image/*",
                  "title": "Thumbnail image URL",
                  "description": "Representative preview image URL extracted from the search system."
                },
                "dateTime": {
                  "type": "string",
                  "title": "Document Creation Time",
                  "description": "The time the document was created."
                }
              },
              "required": [
                "title",
                "contents",
                "url",
                "blogName",
                "thumbnail",
                "dateTime"
              ]
            }
          }
        },
        "required": [
          "meta",
          "documents"
        ],
        "title": "Next blog search results"
      },
      "IDaum.ISearchDaumInput": {
        "type": "object",
        "properties": {
          "andKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "뤼튼",
            "title": "Must-include keywords",
            "description": "Set keywords that must be included in the following search results."
          },
          "orKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "스튜디오",
            "title": "Good keywords to enter",
            "description": "Set good keywords to enter the following search results."
          },
          "notKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "폭력",
            "title": "Keywords that should not be included",
            "description": "Set keywords that should not be included in the following search results."
          },
          "sort": {
            "oneOf": [
              {
                "const": "accuracy",
                "default": "accuracy",
                "x-wrtn-placeholder": "accuracy"
              },
              {
                "const": "recency",
                "default": "accuracy",
                "x-wrtn-placeholder": "accuracy"
              }
            ],
            "title": "Sorting method for result documents",
            "description": "- accuracy: accuracy order (default)\n- recency: most recent order"
          },
          "page": {
            "type": "number",
            "minimum": 1,
            "maximum": 50,
            "default": 1,
            "title": "Results page number",
            "description": "The number of the results page."
          },
          "size": {
            "type": "number",
            "minimum": 1,
            "maximum": 50,
            "default": 10,
            "title": "The number of documents to be displayed on one page",
            "description": "The number of documents to be displayed on one page."
          }
        },
        "required": [
          "andKeywords"
        ],
        "title": "Information needed for the next search"
      },
      "IDaum.ICafeDaumOutput": {
        "type": "object",
        "properties": {
          "meta": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "title": "Number of searched cafe contents",
                "description": "Total number of searched cafes."
              },
              "pageableCount": {
                "type": "number",
                "title": "The number of contents that can be exposed among the searched cafe contents",
                "description": "The number of contents that can be exposed among the searched cafe contents."
              },
              "isEnd": {
                "type": "boolean",
                "title": "Whether the current page is the last page",
                "description": "If the value is false, you can request the next page by incrementing page."
              }
            },
            "required": [
              "totalCount",
              "pageableCount",
              "isEnd"
            ]
          },
          "documents": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "title": "The title of the document",
                  "description": "The title of the document searched."
                },
                "contents": {
                  "type": "string",
                  "title": "Part of the text of the document",
                  "description": "This is part of the text of the document that was searched."
                },
                "url": {
                  "type": "string",
                  "title": "Document URL",
                  "description": "The URL of the document being searched."
                },
                "cafeName": {
                  "type": "string",
                  "title": "Cafe Name",
                  "description": "The following cafe name is searched."
                },
                "thumbnail": {
                  "type": "string",
                  "contentMediaType": "image/*",
                  "title": "Thumbnail image URL",
                  "description": "Representative preview image URL extracted from the search system."
                },
                "dateTime": {
                  "type": "string",
                  "title": "Document Creation Time",
                  "description": "The time the document was created."
                }
              },
              "required": [
                "title",
                "contents",
                "url",
                "cafeName",
                "thumbnail",
                "dateTime"
              ]
            }
          }
        },
        "required": [
          "meta",
          "documents"
        ],
        "title": "Next Cafe Search Results"
      },
      "INaver.ICafeNaverOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "properties": {
              "lastBuildDate": {
                "type": "string",
                "title": "The time the search results were generated.",
                "description": "The time the search results were generated."
              },
              "total": {
                "type": "number",
                "title": "Total number of search results.",
                "description": "Total number of search results."
              },
              "start": {
                "type": "number",
                "title": "The starting position of the search.",
                "description": "The starting position of the search results."
              },
              "display": {
                "type": "number",
                "title": "The number of search results to display at one time.",
                "description": "The number of search results to display at one time."
              },
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/INaver.ICafeNaverItemOutput"
                },
                "title": "Individual search results.",
                "description": "Individual search results."
              }
            },
            "required": [
              "lastBuildDate",
              "total",
              "start",
              "display",
              "items"
            ],
            "title": "Naver Cafe search result data.",
            "description": "Naver Cafe search result data."
          }
        },
        "required": [
          "data"
        ],
        "title": "Naver Cafe Search Results"
      },
      "INaver.ICafeNaverItemOutput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Post title.",
            "description": "Title of Naver Cafe post."
          },
          "link": {
            "type": "string",
            "title": "Post link.",
            "description": "Link to Naver Cafe post."
          },
          "description": {
            "type": "string",
            "title": "Summary of post.",
            "description": "Summary of Naver Cafe post."
          },
          "cafename": {
            "type": "string",
            "title": "The name of the cafe where the post is located.",
            "description": "The name of the cafe where the Naver Cafe post is located."
          },
          "cafeurl": {
            "type": "string",
            "title": "Link to the cafe where the post is located.",
            "description": "Link to the cafe where the Naver Cafe post is located."
          }
        },
        "required": [
          "title",
          "link",
          "description",
          "cafename",
          "cafeurl"
        ],
        "title": "Naver Cafe Search Data"
      },
      "INaver.INaverKeywordInput": {
        "type": "object",
        "properties": {
          "andKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "뤼튼",
            "title": "Must-include keywords",
            "description": "Keywords that must be included in search results."
          },
          "orKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "스튜디오",
            "title": "Keywords that would be good to include",
            "description": "Keywords that you would like to see included in the search results."
          },
          "notKeywords": {
            "type": "string",
            "x-wrtn-placeholder": "폭력",
            "title": "Keywords that should not be included",
            "description": "Keywords that should not be included in search results."
          },
          "display": {
            "type": "number",
            "minimum": 1,
            "maximum": 100,
            "default": 10,
            "x-wrtn-placeholder": "10",
            "title": "Number to search",
            "description": "Set how many search results to retrieve.\nMinimum 1, maximum 100, default 10."
          },
          "sort": {
            "oneOf": [
              {
                "const": "sim",
                "title": "sim",
                "description": "정확도 순 내림착순 정렬",
                "x-wrtn-placeholder": "sim"
              },
              {
                "const": "date",
                "title": "date",
                "description": "날짜순 내림차수 정렬",
                "x-wrtn-placeholder": "sim"
              }
            ],
            "title": "Sort by",
            "description": "Indicates how to sort.\n\n- sim: Sort by accuracy descending (default).\n- date: Sort by date descending."
          }
        },
        "required": [
          "andKeywords"
        ],
        "title": "Search Conditions"
      },
      "INaver.IBlogNaverOutput": {
        "type": "object",
        "properties": {
          "lastBuildDate": {
            "type": "string",
            "title": "The time the search results were generated.",
            "description": "The time the search results were generated."
          },
          "total": {
            "type": "number",
            "title": "Total number of search results.",
            "description": "Total number of search results."
          },
          "start": {
            "type": "number",
            "title": "The starting position of the search.",
            "description": "The starting position of the search results."
          },
          "display": {
            "type": "number",
            "title": "The number of search results to display at one time.",
            "description": "The number of search results to display at one time."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/INaver.IBlogNaverItemOutput"
            },
            "title": "Individual search results.",
            "description": "Individual search results."
          }
        },
        "required": [
          "lastBuildDate",
          "total",
          "start",
          "display",
          "items"
        ],
        "title": "Naver blog search results"
      },
      "INaver.IBlogNaverItemOutput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Post title.",
            "description": "Title of Naver blog post."
          },
          "link": {
            "type": "string",
            "title": "Post link.",
            "description": "Link to Naver blog post."
          },
          "description": {
            "type": "string",
            "title": "Summary of post.",
            "description": "Summary of Naver blog post."
          },
          "bloggername": {
            "type": "string",
            "title": "The name of the blog that contains the blog post.",
            "description": "The name of the blog that contains the Naver blog post."
          },
          "bloggerlink": {
            "type": "string",
            "title": "Address of the blog that contains the blog post.",
            "description": "Address of the blog that contains the Naver blog post."
          },
          "postdate": {
            "type": "string",
            "title": "The date the blog post was created.",
            "description": "The date the Naver blog post was created."
          }
        },
        "required": [
          "title",
          "link",
          "description",
          "bloggername",
          "bloggerlink",
          "postdate"
        ],
        "title": "Naver blog search data"
      },
      "INaver.INewsNaverOutput": {
        "type": "object",
        "properties": {
          "lastBuildDate": {
            "type": "string",
            "title": "The time the search results were generated.",
            "description": "The time the search results were generated."
          },
          "total": {
            "type": "number",
            "title": "Total number of search results.",
            "description": "Total number of search results."
          },
          "start": {
            "type": "number",
            "title": "The starting position of the search.",
            "description": "The starting position of the search results."
          },
          "display": {
            "type": "number",
            "title": "The number of search results to display at one time.",
            "description": "The number of search results to display at one time."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/INaver.INewsNaverItemOutput"
            },
            "title": "Individual search results.",
            "description": "Individual search results."
          }
        },
        "required": [
          "lastBuildDate",
          "total",
          "start",
          "display",
          "items"
        ]
      },
      "INaver.INewsNaverItemOutput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "description": "News Title."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Naver News URL",
            "description": "Naver News URL."
          },
          "originallink": {
            "type": "string",
            "format": "iri",
            "title": "Original URL",
            "description": "Original URL of news article."
          },
          "description": {
            "type": "string",
            "title": "Summary of the news article</b>",
            "description": "The part that matches the search term <b>is wrapped in tags."
          },
          "pubDate": {
            "type": "string",
            "title": "News article publication time",
            "description": "The time the news article was provided to Naver."
          }
        },
        "required": [
          "title",
          "link",
          "originallink",
          "description",
          "pubDate"
        ],
        "title": "Naver News Search Data"
      },
      "IYoutubeSearch.ISearchInput": {
        "type": "object",
        "properties": {
          "and_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "뤼튼"
            },
            "minItems": 1,
            "title": "Must be included keywords",
            "description": "Keywords that must be included in search results."
          },
          "or_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "스튜디오"
            },
            "title": "Keywords that you would like to see included",
            "description": "Keywords that you would like to see included in your search results."
          },
          "not_keywords": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "x-wrtn-placeholder": "폭력"
            },
            "title": "Keywords that should not be included",
            "description": "Keywords that should not be included in search results."
          }
        },
        "required": [
          "and_keywords"
        ],
        "title": "YouTube search conditions"
      },
      "IGoogleScholar.ISearchOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Unique id of search result data",
            "description": "Unique id of search result data."
          },
          "title": {
            "type": "string",
            "title": "Title of the paper searched",
            "description": "This is the title of the paper searched."
          },
          "link": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Link to the searched paper",
            "description": "Here is the link to the searched paper."
          },
          "snippet": {
            "type": "string",
            "title": "Snippet of the search results",
            "description": "Here is a snippet of the search results."
          },
          "publication_info": {
            "type": "string",
            "title": "Publication Summary Information",
            "description": "Here is the publication summary information for the searched paper."
          },
          "resource": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IGoogleScholar.IResource"
                }
              }
            ],
            "title": "Reference information",
            "description": "Here is the reference information for the searched paper."
          },
          "citation_count": {
            "type": "integer",
            "title": "Number of times cited",
            "description": "The number of times the searched paper was cited."
          },
          "related_pages_link": {
            "type": "string",
            "format": "iri",
            "title": "Links to related academic materials",
            "description": "Here are links to academic materials related to the searched paper."
          },
          "version_info": {
            "$ref": "#/components/schemas/IGoogleScholar.IVersion",
            "title": "Version information",
            "description": "Here is the version information for the searched paper."
          }
        },
        "required": [
          "id",
          "title",
          "link",
          "snippet",
          "publication_info",
          "resource",
          "citation_count",
          "related_pages_link",
          "version_info"
        ],
        "title": "Search Results"
      },
      "IGoogleScholar.IResource": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title of the reference material",
            "description": "Title of the reference material."
          },
          "file_format": {
            "type": "string",
            "title": "Reference file format",
            "description": "This is the format of the reference file."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Link to the reference material",
            "description": "Here is a link to the reference material."
          }
        },
        "required": [
          "title",
          "link"
        ],
        "title": "References"
      },
      "IGoogleScholar.IVersion": {
        "type": "object",
        "properties": {
          "version": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "Version information",
            "description": "Here is the version information."
          },
          "link": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Version-related links",
            "description": "Here are the version-related links."
          }
        },
        "required": [
          "version",
          "link"
        ],
        "title": "version"
      },
      "IGoogleScholar.ISearchInput": {
        "type": "object",
        "properties": {
          "andKeyword": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "biology"
            },
            "title": "Keywords that must be included",
            "description": "Keywords that must be included in search results."
          },
          "orKeyword": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "ecosystem"
            },
            "title": "Keywords that you would like to see included",
            "description": "Keywords that you would like to see included in your search results."
          },
          "notKeyword": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-placeholder": "pollution"
            },
            "title": "Keywords to exclude",
            "description": "Keywords that should not be included in search results."
          },
          "max_results": {
            "type": "integer",
            "x-wrtn-placeholder": "10",
            "title": "Number of search results",
            "description": "Sets how many search results to retrieve."
          }
        },
        "required": [
          "andKeyword",
          "max_results"
        ],
        "title": "Search Conditions"
      },
      "ICsv.IReadOutput": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {},
              "additionalProperties": {
                "type": "string"
              }
            },
            "title": "csv data list.",
            "description": "Read csv file data."
          }
        },
        "required": [
          "data"
        ],
        "title": "Csv file reading result"
      },
      "ICsv.IReadInput": {
        "type": "object",
        "properties": {
          "s3Url": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "text/csv",
            "title": "file",
            "description": "This is the Csv file to read."
          },
          "delimiter": {
            "type": "string",
            "x-wrtn-placeholder": ",",
            "title": "delimiter",
            "description": "This is the CSV file delimiter to read."
          }
        },
        "required": [
          "s3Url",
          "delimiter"
        ],
        "title": "Csv file information"
      },
      "ICsv.IWriteOutput": {
        "type": "object",
        "properties": {
          "s3Url": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "text/csv",
            "title": "csv file",
            "description": "This is the s3 url of the csv file that was created."
          }
        },
        "required": [
          "s3Url"
        ],
        "title": "Csv file creation result"
      },
      "ICsv.IWriteInput": {
        "type": "object",
        "properties": {
          "fileName": {
            "type": "string",
            "x-wrtn-placeholder": "example.csv",
            "title": "File name",
            "description": "The name of the Csv file to be created."
          },
          "delimiter": {
            "type": "string",
            "x-wrtn-placeholder": ",",
            "title": "delimiter",
            "description": "The Csv file delimiter to be generated."
          },
          "values": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {},
              "additionalProperties": {
                "type": "string"
              }
            },
            "title": "File data values",
            "description": "These are the data values to be placed in the Csv file to be created."
          }
        },
        "required": [
          "fileName",
          "delimiter",
          "values"
        ],
        "title": "Information required to create a CSV file"
      },
      "ICsv.ICsvToExcelOutput": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "text/csv",
            "title": "s3 url",
            "description": "Here is the s3 url of the converted excel file."
          }
        },
        "required": [
          "url"
        ],
        "title": "Csv file to Excel file conversion result"
      },
      "ICsv.ICsvToExcelInput": {
        "type": "object",
        "properties": {
          "s3Url": {
            "type": "string",
            "format": "iri",
            "contentMediaType": "text/csv",
            "title": "file",
            "description": "This is the file to convert from csv to excel."
          },
          "delimiter": {
            "type": "string",
            "x-wrtn-placeholder": ",",
            "title": "delimiter",
            "description": "This is the file delimiter to convert from csv to excel."
          }
        },
        "required": [
          "s3Url",
          "delimiter"
        ],
        "title": "Information needed to convert a Csv file to an Excel file"
      },
      "INotion.IDeleteBlockInput": {
        "type": "object",
        "properties": {
          "block_id": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "block_id\n\nIndicates the ID of the page or block within the page to be deleted.\nIf you delete the page, it will go to the trash, so recovery is possible."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "block_id",
          "secretKey"
        ]
      },
      "INotion.IAppendPageByMarkdownInput": {
        "type": "object",
        "properties": {
          "markdown": {
            "type": "string",
            "title": "markdown"
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "markdown",
          "pageId",
          "secretKey"
        ]
      },
      "INotion.ICreateChildContentTypeFileInput": {
        "type": "object",
        "properties": {
          "file": {
            "type": "object",
            "properties": {
              "external": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "iri",
                    "title": "url\n\nYou can enter the path of the file you want to upload."
                  }
                },
                "required": [
                  "url"
                ],
                "title": "external"
              },
              "name": {
                "type": "string",
                "title": "filename"
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri"
                            }
                          },
                          "required": [
                            "url"
                          ]
                        }
                      },
                      "required": [
                        "content"
                      ]
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption for this file"
              }
            },
            "required": [
              "external"
            ],
            "title": "file"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "file",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeEmbedInput": {
        "type": "object",
        "properties": {
          "embed": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url\n\nYou can enter the path of the file you want to embed."
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri"
                            }
                          },
                          "required": [
                            "url"
                          ]
                        }
                      },
                      "required": [
                        "content"
                      ]
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this embed"
              }
            },
            "required": [
              "url"
            ],
            "title": "embed"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "embed",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeBookmarkInput": {
        "type": "object",
        "properties": {
          "bookmark": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url\n\nYou can enter the path of the file you want to bookmark."
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri"
                            }
                          },
                          "required": [
                            "url"
                          ]
                        }
                      },
                      "required": [
                        "content"
                      ]
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this bookmark"
              }
            },
            "required": [
              "url"
            ],
            "title": "bookmark"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "bookmark",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeImageInput": {
        "type": "object",
        "properties": {
          "image": {
            "type": "object",
            "properties": {
              "external": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "uri",
                    "pattern": ".*\\.(bmp|gif|heic|jpe?g|png|svg|tiff?)(\\?.*)?",
                    "title": "url\n\nimage file's extension is one of: 'bmp', 'gif', 'heic', 'jpg', 'jpeg', 'png', 'svg', 'tif', 'tiff'."
                  }
                },
                "required": [
                  "url"
                ],
                "title": "external"
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri"
                            }
                          },
                          "required": [
                            "url"
                          ]
                        }
                      },
                      "required": [
                        "content"
                      ]
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this image"
              }
            },
            "required": [
              "external"
            ],
            "title": "image"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "image",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeVideoInput": {
        "type": "object",
        "properties": {
          "video": {
            "type": "object",
            "properties": {
              "external": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "iri",
                    "title": "url\n\nvideo file must be one of: 'amv' ,'asf' ,'avi' ,'f4v' ,'flv' ,'gifv' ,'mkv' ,'mov' ,'mpg' ,'mpeg' ,'mpv' ,'mp4' ,'m4v' ,'qt' ,'wmv'\nOR\nYouTube video links that include embed or watch.\nE.g. https://www.youtube.com/watch?v=[id], https://www.youtube.com/embed/[id]"
                  }
                },
                "required": [
                  "url"
                ]
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri"
                            }
                          },
                          "required": [
                            "url"
                          ]
                        }
                      },
                      "required": [
                        "content"
                      ]
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this embed"
              }
            },
            "required": [
              "external"
            ]
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "video",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypePdfInput": {
        "type": "object",
        "properties": {
          "pdf": {
            "type": "object",
            "properties": {
              "external": {
                "type": "object",
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "iri",
                    "pattern": ".*\\.(pdf)(\\?.*)?",
                    "title": "url"
                  }
                },
                "required": [
                  "url"
                ],
                "title": "external"
              },
              "caption": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri"
                            }
                          },
                          "required": [
                            "url"
                          ]
                        }
                      },
                      "required": [
                        "content"
                      ]
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "minItems": 1,
                "maxItems": 1,
                "title": "caption of this pdf"
              }
            },
            "required": [
              "external"
            ],
            "title": "pdf"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "pdf",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeCodeInput": {
        "type": "object",
        "properties": {
          "code": {
            "type": "object",
            "properties": {
              "language": {
                "oneOf": [
                  {
                    "const": "c"
                  },
                  {
                    "const": "json"
                  },
                  {
                    "const": "r"
                  },
                  {
                    "const": "html"
                  },
                  {
                    "const": "markdown"
                  },
                  {
                    "const": "abap"
                  },
                  {
                    "const": "agda"
                  },
                  {
                    "const": "arduino"
                  },
                  {
                    "const": "assembly"
                  },
                  {
                    "const": "bash"
                  },
                  {
                    "const": "basic"
                  },
                  {
                    "const": "bnf"
                  },
                  {
                    "const": "c#"
                  },
                  {
                    "const": "c++"
                  },
                  {
                    "const": "clojure"
                  },
                  {
                    "const": "coffeescript"
                  },
                  {
                    "const": "coq"
                  },
                  {
                    "const": "css"
                  },
                  {
                    "const": "dart"
                  },
                  {
                    "const": "dhall"
                  },
                  {
                    "const": "diff"
                  },
                  {
                    "const": "docker"
                  },
                  {
                    "const": "ebnf"
                  },
                  {
                    "const": "elixir"
                  },
                  {
                    "const": "elm"
                  },
                  {
                    "const": "erlang"
                  },
                  {
                    "const": "f#"
                  },
                  {
                    "const": "flow"
                  },
                  {
                    "const": "fortran"
                  },
                  {
                    "const": "gherkin"
                  },
                  {
                    "const": "glsl"
                  },
                  {
                    "const": "go"
                  },
                  {
                    "const": "graphql"
                  },
                  {
                    "const": "groovy"
                  },
                  {
                    "const": "haskell"
                  },
                  {
                    "const": "idris"
                  },
                  {
                    "const": "java"
                  },
                  {
                    "const": "javascript"
                  },
                  {
                    "const": "julia"
                  },
                  {
                    "const": "kotlin"
                  },
                  {
                    "const": "latex"
                  },
                  {
                    "const": "less"
                  },
                  {
                    "const": "lisp"
                  },
                  {
                    "const": "livescript"
                  },
                  {
                    "const": "llvm ir"
                  },
                  {
                    "const": "lua"
                  },
                  {
                    "const": "makefile"
                  },
                  {
                    "const": "markup"
                  },
                  {
                    "const": "matlab"
                  },
                  {
                    "const": "mathematica"
                  },
                  {
                    "const": "mermaid"
                  },
                  {
                    "const": "nix"
                  },
                  {
                    "const": "notion formula"
                  },
                  {
                    "const": "objective-c"
                  },
                  {
                    "const": "ocaml"
                  },
                  {
                    "const": "pascal"
                  },
                  {
                    "const": "perl"
                  },
                  {
                    "const": "php"
                  },
                  {
                    "const": "plain text"
                  },
                  {
                    "const": "powershell"
                  },
                  {
                    "const": "prolog"
                  },
                  {
                    "const": "protobuf"
                  },
                  {
                    "const": "purescript"
                  },
                  {
                    "const": "python"
                  },
                  {
                    "const": "racket"
                  },
                  {
                    "const": "reason"
                  },
                  {
                    "const": "ruby"
                  },
                  {
                    "const": "rust"
                  },
                  {
                    "const": "sass"
                  },
                  {
                    "const": "scala"
                  },
                  {
                    "const": "scheme"
                  },
                  {
                    "const": "scss"
                  },
                  {
                    "const": "shell"
                  },
                  {
                    "const": "solidity"
                  },
                  {
                    "const": "sql"
                  },
                  {
                    "const": "swift"
                  },
                  {
                    "const": "toml"
                  },
                  {
                    "const": "typescript"
                  },
                  {
                    "const": "vb.net"
                  },
                  {
                    "const": "verilog"
                  },
                  {
                    "const": "vhdl"
                  },
                  {
                    "const": "visual basic"
                  },
                  {
                    "const": "webassembly"
                  },
                  {
                    "const": "xml"
                  },
                  {
                    "const": "yaml"
                  },
                  {
                    "const": "java/c/c++/c#"
                  }
                ],
                "title": "programming language name"
              },
              "rich_text": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "text": {
                      "type": "object",
                      "properties": {
                        "content": {
                          "type": "string"
                        },
                        "link": {
                          "type": "object",
                          "properties": {
                            "url": {
                              "type": "string",
                              "format": "iri"
                            }
                          },
                          "required": [
                            "url"
                          ]
                        }
                      },
                      "required": [
                        "content"
                      ]
                    }
                  },
                  "required": [
                    "text"
                  ]
                },
                "maxItems": 1,
                "title": "rich text for this codebox"
              }
            },
            "required": [
              "language",
              "rich_text"
            ]
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "code",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeEquationInput": {
        "type": "object",
        "properties": {
          "equation": {
            "type": "object",
            "properties": {
              "expression": {
                "const": "y = 2x",
                "title": "expression\n\nan equation in mathematics"
              }
            },
            "required": [
              "expression"
            ],
            "title": "equation"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "equation",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeDividerInput": {
        "type": "object",
        "properties": {
          "divider": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "divider"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "divider",
          "secretKey",
          "pageId"
        ]
      },
      "Recordstringnever": {
        "type": "object",
        "properties": {},
        "description": "Construct a type with a set of properties K of type T"
      },
      "INotion.ICreateChildContentTypeBreadcrumbInput": {
        "type": "object",
        "properties": {
          "breadcrumb": {
            "$ref": "#/components/schemas/Recordstringnever",
            "title": "breadcrumb\n\nYou only need to match the key name correctly, so you just need to pass on an empty object."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "breadcrumb",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeTableOfContentsInput": {
        "type": "object",
        "properties": {
          "table_of_contents": {
            "type": "object",
            "properties": {
              "color": {
                "oneOf": [
                  {
                    "const": "default"
                  },
                  {
                    "const": "gray"
                  },
                  {
                    "const": "brown"
                  },
                  {
                    "const": "orange"
                  },
                  {
                    "const": "yellow"
                  },
                  {
                    "const": "green"
                  },
                  {
                    "const": "blue"
                  },
                  {
                    "const": "purple"
                  },
                  {
                    "const": "pink"
                  },
                  {
                    "const": "red"
                  },
                  {
                    "const": "gray_background"
                  },
                  {
                    "const": "brown_background"
                  },
                  {
                    "const": "orange_background"
                  },
                  {
                    "const": "yellow_background"
                  },
                  {
                    "const": "green_background"
                  },
                  {
                    "const": "blue_background"
                  },
                  {
                    "const": "purple_background"
                  },
                  {
                    "const": "pink_background"
                  },
                  {
                    "const": "red_background"
                  }
                ],
                "title": "color\n\nIt must be one of :\n\"default\", \"gray\", \"brown\", \"orange\", \"yellow\", \"green\", \"blue\", \"purple\", \"pink\", \"red\", \"gray_background\", \"brown_background\", \"orange_background\", \"yellow_background\", \"green_background\", \"blue_background\", \"purple_background\", \"pink_background\", \"red_background\""
              }
            },
            "required": [
              "color"
            ],
            "title": "table_of_contents"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "table_of_contents",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeLinkToPageInput": {
        "type": "object",
        "properties": {
          "link_to_page": {
            "type": "object",
            "properties": {
              "page_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/notion/get/page",
                      "jmesPath": "[].{value:pageId, label:title}"
                    },
                    "x-wrtn-placeholder": "부모 페이지를 선택하세요."
                  },
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/notion/page",
                      "jmesPath": "[].{value:id, label:id}"
                    },
                    "x-wrtn-placeholder": "부모 페이지를 선택하세요."
                  }
                ],
                "title": "page_id\n\nYou can look up the page by passing the page ID as a parameter at the end of the notion link.\nFor example, in the format 'https://www.notion.so/ :pageId'."
              }
            },
            "required": [
              "page_id"
            ],
            "title": "link_to_page"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          }
        },
        "required": [
          "link_to_page",
          "secretKey",
          "pageId"
        ]
      },
      "INotion.ICreateChildContentTypeToggleInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "pageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "pageId\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.\nCalling this connector requires the correct page ID,\nso it should only be called if you have previously created a page to obtain that ID, viewed the page,\nor obtained a link or page ID from the user in advance."
          },
          "toggle": {
            "$ref": "#/components/schemas/rich_textMultipleTextLinecolorApiColorundefinedRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...)",
            "title": "toggle"
          }
        },
        "required": [
          "secretKey",
          "pageId",
          "toggle"
        ]
      },
      "rich_textMultipleTextLinecolorApiColorundefinedRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...)": {
        "type": "object",
        "properties": {
          "rich_text": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "object",
                  "properties": {
                    "content": {
                      "type": "string"
                    },
                    "link": {
                      "type": "object",
                      "properties": {
                        "url": {
                          "type": "string",
                          "format": "iri"
                        }
                      },
                      "required": [
                        "url"
                      ]
                    }
                  },
                  "required": [
                    "content"
                  ]
                }
              },
              "required": [
                "text"
              ]
            },
            "maxItems": 1,
            "title": "rich_text"
          },
          "color": {
            "oneOf": [
              {
                "const": "default"
              },
              {
                "const": "gray"
              },
              {
                "const": "brown"
              },
              {
                "const": "orange"
              },
              {
                "const": "yellow"
              },
              {
                "const": "green"
              },
              {
                "const": "blue"
              },
              {
                "const": "purple"
              },
              {
                "const": "pink"
              },
              {
                "const": "red"
              },
              {
                "const": "gray_background"
              },
              {
                "const": "brown_background"
              },
              {
                "const": "orange_background"
              },
              {
                "const": "yellow_background"
              },
              {
                "const": "green_background"
              },
              {
                "const": "blue_background"
              },
              {
                "const": "purple_background"
              },
              {
                "const": "pink_background"
              },
              {
                "const": "red_background"
              }
            ],
            "title": "color"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/togglerich_textMultipleTextLinecolorApiColorundefinedRecordtoggleRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...)"
            }
          }
        },
        "required": [
          "rich_text",
          "children"
        ]
      },
      "togglerich_textMultipleTextLinecolorApiColorundefinedRecordtoggleRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...)": {
        "type": "object",
        "properties": {
          "toggle": {
            "$ref": "#/components/schemas/rich_textMultipleTextLinecolorApiColorundefinedRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...).o1",
            "title": "toggle"
          }
        },
        "required": [
          "toggle"
        ]
      },
      "rich_textMultipleTextLinecolorApiColorundefinedRecordchildren(togglerich_textMultipleTextLinecolorApiColorundefinedRecord...).o1": {
        "type": "object",
        "properties": {
          "rich_text": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "object",
                  "properties": {
                    "content": {
                      "type": "string"
                    },
                    "link": {
                      "type": "object",
                      "properties": {
                        "url": {
                          "type": "string",
                          "format": "iri"
                        }
                      },
                      "required": [
                        "url"
                      ]
                    }
                  },
                  "required": [
                    "content"
                  ]
                }
              },
              "required": [
                "text"
              ]
            },
            "maxItems": 1,
            "title": "rich_text"
          },
          "color": {
            "oneOf": [
              {
                "const": "default"
              },
              {
                "const": "gray"
              },
              {
                "const": "brown"
              },
              {
                "const": "orange"
              },
              {
                "const": "yellow"
              },
              {
                "const": "green"
              },
              {
                "const": "blue"
              },
              {
                "const": "purple"
              },
              {
                "const": "pink"
              },
              {
                "const": "red"
              },
              {
                "const": "gray_background"
              },
              {
                "const": "brown_background"
              },
              {
                "const": "orange_background"
              },
              {
                "const": "yellow_background"
              },
              {
                "const": "green_background"
              },
              {
                "const": "blue_background"
              },
              {
                "const": "purple_background"
              },
              {
                "const": "pink_background"
              },
              {
                "const": "red_background"
              }
            ],
            "title": "color"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/togglerich_textMultipleTextLinecolorApiColorundefinedRecordtoggleRecordchildrentogglerich_textMultipleTextLinecolorApiColorundefined"
            }
          }
        },
        "required": [
          "rich_text",
          "children"
        ]
      },
      "togglerich_textMultipleTextLinecolorApiColorundefinedRecordtoggleRecordchildrentogglerich_textMultipleTextLinecolorApiColorundefined": {
        "type": "object",
        "properties": {
          "toggle": {
            "$ref": "#/components/schemas/rich_textMultipleTextLinecolorApiColorundefinedRecordchildrentogglerich_textMultipleTextLinecolorApiColorundefined",
            "title": "toggle"
          }
        },
        "required": [
          "toggle"
        ]
      },
      "rich_textMultipleTextLinecolorApiColorundefinedRecordchildrentogglerich_textMultipleTextLinecolorApiColorundefined": {
        "type": "object",
        "properties": {
          "rich_text": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "object",
                  "properties": {
                    "content": {
                      "type": "string"
                    },
                    "link": {
                      "type": "object",
                      "properties": {
                        "url": {
                          "type": "string",
                          "format": "iri"
                        }
                      },
                      "required": [
                        "url"
                      ]
                    }
                  },
                  "required": [
                    "content"
                  ]
                }
              },
              "required": [
                "text"
              ]
            },
            "maxItems": 1,
            "title": "rich_text"
          },
          "color": {
            "oneOf": [
              {
                "const": "default"
              },
              {
                "const": "gray"
              },
              {
                "const": "brown"
              },
              {
                "const": "orange"
              },
              {
                "const": "yellow"
              },
              {
                "const": "green"
              },
              {
                "const": "blue"
              },
              {
                "const": "purple"
              },
              {
                "const": "pink"
              },
              {
                "const": "red"
              },
              {
                "const": "gray_background"
              },
              {
                "const": "brown_background"
              },
              {
                "const": "orange_background"
              },
              {
                "const": "yellow_background"
              },
              {
                "const": "green_background"
              },
              {
                "const": "blue_background"
              },
              {
                "const": "purple_background"
              },
              {
                "const": "pink_background"
              },
              {
                "const": "red_background"
              }
            ],
            "title": "color"
          },
          "children": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "toggle": {
                  "type": "object",
                  "properties": {
                    "rich_text": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "text": {
                            "type": "object",
                            "properties": {
                              "content": {
                                "type": "string"
                              },
                              "link": {
                                "type": "object",
                                "properties": {
                                  "url": {
                                    "type": "string",
                                    "format": "iri"
                                  }
                                },
                                "required": [
                                  "url"
                                ]
                              }
                            },
                            "required": [
                              "content"
                            ]
                          }
                        },
                        "required": [
                          "text"
                        ]
                      },
                      "maxItems": 1,
                      "title": "rich_text"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        },
                        {
                          "const": "red"
                        },
                        {
                          "const": "gray_background"
                        },
                        {
                          "const": "brown_background"
                        },
                        {
                          "const": "orange_background"
                        },
                        {
                          "const": "yellow_background"
                        },
                        {
                          "const": "green_background"
                        },
                        {
                          "const": "blue_background"
                        },
                        {
                          "const": "purple_background"
                        },
                        {
                          "const": "pink_background"
                        },
                        {
                          "const": "red_background"
                        }
                      ],
                      "title": "color"
                    }
                  },
                  "required": [
                    "rich_text"
                  ],
                  "title": "toggle"
                }
              },
              "required": [
                "toggle"
              ]
            }
          }
        },
        "required": [
          "rich_text",
          "children"
        ]
      },
      "INotion.ICreatePageOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "page id",
            "description": "Unique id of the generated page"
          },
          "title": {
            "type": "string",
            "title": "tilte\n\nTitle of the document you just created"
          }
        },
        "required": [
          "id",
          "title"
        ],
        "title": "Page creation result"
      },
      "INotion.ICreatePageInput": {
        "type": "object",
        "properties": {
          "parentPageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ]
          },
          "title": {
            "type": "string",
            "x-wrtn-placeholder": "테스트 페이지.",
            "title": "Page title",
            "description": "New page title to be created"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "parentPageId",
          "title",
          "secretKey"
        ],
        "title": "Conditions required to create a page"
      },
      "INotion.IMarkdownBlock": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "hasChild": {
            "type": "boolean"
          },
          "children": {
            "type": "array",
            "items": {}
          }
        },
        "required": [
          "id"
        ]
      },
      "INotion.IReadPageContentInput": {
        "type": "object",
        "properties": {
          "block_id": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ],
            "title": "block_id\n\nIndicates the ID of the page.\nyou can put the block ID back into this factor and use it to look up the child blocks."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "block_id",
          "secretKey"
        ]
      },
      "INotion.IReadPageOutput": {
        "type": "object",
        "properties": {
          "pageId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/notion/get/page",
              "jmesPath": "[].{value:pageId, label:title}"
            },
            "title": "id\n\nIndicates the page on which you want to add a block.\nAt the bottom of this page, a block is added to match the requested object here.",
            "description": "페이지 고유 id"
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "Page Title"
          }
        },
        "required": [
          "pageId",
          "title"
        ],
        "title": "Page list query results"
      },
      "INotion.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "INotion.IUserOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "User unique id"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Username"
          }
        },
        "required": [
          "id",
          "name"
        ],
        "title": "User list query results"
      },
      "INotion.IDatabaseInfo": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id",
            "description": "database unique id"
          },
          "title": {
            "type": "string",
            "title": "TitleP",
            "description": "Database Title"
          },
          "properties": {
            "$ref": "#/components/schemas/RecordstringINotion.DatabaseProperty",
            "title": "property",
            "description": "Database property information"
          }
        },
        "required": [
          "id",
          "title",
          "properties"
        ],
        "title": "Database Information"
      },
      "RecordstringINotion.DatabaseProperty": {
        "type": "object",
        "properties": {},
        "description": "Construct a type with a set of properties K of type T",
        "additionalProperties": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/INotion.NumberDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.FormulaDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.SelectDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.MultiSelectDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.StatusDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.RelationDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.RollupDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.TitleDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.RichTextDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.UrlDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.PeopleDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.FilesDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.EmailDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.PhoneNumberDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.DateDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.CheckboxDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.CreatedByDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.CreatedTimeDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.LastEditedByDatabaseProperty"
            },
            {
              "$ref": "#/components/schemas/INotion.LastEditedTimeDatabaseProperty"
            }
          ],
          "discriminator": {
            "propertyName": "type",
            "mapping": {
              "number": "#/components/schemas/INotion.NumberDatabaseProperty",
              "formula": "#/components/schemas/INotion.FormulaDatabaseProperty",
              "select": "#/components/schemas/INotion.SelectDatabaseProperty",
              "multi_select": "#/components/schemas/INotion.MultiSelectDatabaseProperty",
              "status": "#/components/schemas/INotion.StatusDatabaseProperty",
              "relation": "#/components/schemas/INotion.RelationDatabaseProperty",
              "rollup": "#/components/schemas/INotion.RollupDatabaseProperty",
              "title": "#/components/schemas/INotion.TitleDatabaseProperty",
              "rich_text": "#/components/schemas/INotion.RichTextDatabaseProperty",
              "url": "#/components/schemas/INotion.UrlDatabaseProperty",
              "people": "#/components/schemas/INotion.PeopleDatabaseProperty",
              "files": "#/components/schemas/INotion.FilesDatabaseProperty",
              "email": "#/components/schemas/INotion.EmailDatabaseProperty",
              "phone_number": "#/components/schemas/INotion.PhoneNumberDatabaseProperty",
              "date": "#/components/schemas/INotion.DateDatabaseProperty",
              "checkbox": "#/components/schemas/INotion.CheckboxDatabaseProperty",
              "created_by": "#/components/schemas/INotion.CreatedByDatabaseProperty",
              "created_time": "#/components/schemas/INotion.CreatedTimeDatabaseProperty",
              "last_edited_by": "#/components/schemas/INotion.LastEditedByDatabaseProperty",
              "last_edited_time": "#/components/schemas/INotion.LastEditedTimeDatabaseProperty"
            }
          }
        }
      },
      "INotion.NumberDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "number"
          },
          "number": {
            "type": "object",
            "properties": {
              "format": {
                "oneOf": [
                  {
                    "const": "number"
                  },
                  {
                    "const": "percent"
                  },
                  {
                    "const": "number_with_commas"
                  },
                  {
                    "const": "dollar"
                  },
                  {
                    "const": "canadian_dollar"
                  },
                  {
                    "const": "singapore_dollar"
                  },
                  {
                    "const": "euro"
                  },
                  {
                    "const": "pound"
                  },
                  {
                    "const": "yen"
                  },
                  {
                    "const": "ruble"
                  },
                  {
                    "const": "rupee"
                  },
                  {
                    "const": "won"
                  },
                  {
                    "const": "yuan"
                  },
                  {
                    "const": "real"
                  },
                  {
                    "const": "lira"
                  },
                  {
                    "const": "rupiah"
                  },
                  {
                    "const": "franc"
                  },
                  {
                    "const": "hong_kong_dollar"
                  },
                  {
                    "const": "new_zealand_dollar"
                  },
                  {
                    "const": "krona"
                  },
                  {
                    "const": "norwegian_krone"
                  },
                  {
                    "const": "mexican_peso"
                  },
                  {
                    "const": "rand"
                  },
                  {
                    "const": "new_taiwan_dollar"
                  },
                  {
                    "const": "danish_krone"
                  },
                  {
                    "const": "zloty"
                  },
                  {
                    "const": "baht"
                  },
                  {
                    "const": "forint"
                  },
                  {
                    "const": "koruna"
                  },
                  {
                    "const": "shekel"
                  },
                  {
                    "const": "chilean_peso"
                  },
                  {
                    "const": "philippine_peso"
                  },
                  {
                    "const": "dirham"
                  },
                  {
                    "const": "colombian_peso"
                  },
                  {
                    "const": "riyal"
                  },
                  {
                    "const": "ringgit"
                  },
                  {
                    "const": "leu"
                  },
                  {
                    "const": "argentine_peso"
                  },
                  {
                    "const": "uruguayan_peso"
                  },
                  {
                    "const": "peruvian_sol"
                  }
                ]
              }
            },
            "required": [
              "format"
            ]
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "number"
        ],
        "title": "Database numeric properties"
      },
      "INotion.FormulaDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "formula"
          },
          "formula": {
            "type": "object",
            "properties": {
              "expression": {
                "type": "string"
              }
            },
            "required": [
              "expression"
            ]
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "formula"
        ],
        "title": "Database official properties"
      },
      "INotion.SelectDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "select"
          },
          "select": {
            "type": "object",
            "properties": {
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        },
                        {
                          "const": "red"
                        }
                      ]
                    }
                  },
                  "required": [
                    "id",
                    "name",
                    "color"
                  ]
                }
              }
            },
            "required": [
              "options"
            ]
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "select"
        ],
        "title": "Database Selection Attributes"
      },
      "INotion.MultiSelectDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "multi_select"
          },
          "multi_select": {
            "type": "object",
            "properties": {
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        },
                        {
                          "const": "red"
                        }
                      ]
                    }
                  },
                  "required": [
                    "id",
                    "name",
                    "color"
                  ]
                }
              }
            },
            "required": [
              "options"
            ]
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "multi_select"
        ],
        "title": "Database Multi-Select Attribute"
      },
      "INotion.StatusDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "status"
          },
          "status": {
            "type": "object",
            "properties": {
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        },
                        {
                          "const": "red"
                        }
                      ]
                    }
                  },
                  "required": [
                    "id",
                    "name",
                    "color"
                  ]
                }
              },
              "groups": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    },
                    "color": {
                      "oneOf": [
                        {
                          "const": "default"
                        },
                        {
                          "const": "gray"
                        },
                        {
                          "const": "brown"
                        },
                        {
                          "const": "orange"
                        },
                        {
                          "const": "yellow"
                        },
                        {
                          "const": "green"
                        },
                        {
                          "const": "blue"
                        },
                        {
                          "const": "purple"
                        },
                        {
                          "const": "pink"
                        },
                        {
                          "const": "red"
                        }
                      ]
                    },
                    "option_ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "id",
                    "name",
                    "color",
                    "option_ids"
                  ]
                }
              }
            },
            "required": [
              "options",
              "groups"
            ]
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "status"
        ],
        "title": "Database status properties"
      },
      "INotion.RelationDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "relation"
          },
          "relation": {
            "type": "object",
            "properties": {
              "database_id": {
                "type": "string"
              },
              "synced_property_id": {
                "type": "string"
              },
              "synced_property_name": {
                "type": "string"
              }
            },
            "required": [
              "database_id",
              "synced_property_id",
              "synced_property_name"
            ]
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "relation"
        ],
        "title": "Database Relationship Properties"
      },
      "INotion.RollupDatabaseProperty": {
        "type": "object",
        "properties": {
          "type": {
            "const": "rollup"
          },
          "rollup": {
            "type": "object",
            "properties": {
              "rollup_property_name": {
                "type": "string"
              },
              "relation_property_name": {
                "type": "string"
              },
              "rollup_property_id": {
                "type": "string"
              },
              "relation_property_id": {
                "type": "string"
              },
              "function": {
                "oneOf": [
                  {
                    "const": "range"
                  },
                  {
                    "const": "average"
                  },
                  {
                    "const": "unique"
                  },
                  {
                    "const": "count"
                  },
                  {
                    "const": "count_values"
                  },
                  {
                    "const": "empty"
                  },
                  {
                    "const": "not_empty"
                  },
                  {
                    "const": "show_unique"
                  },
                  {
                    "const": "percent_empty"
                  },
                  {
                    "const": "percent_not_empty"
                  },
                  {
                    "const": "sum"
                  },
                  {
                    "const": "median"
                  },
                  {
                    "const": "min"
                  },
                  {
                    "const": "max"
                  },
                  {
                    "const": "earliest_date"
                  },
                  {
                    "const": "latest_date"
                  },
                  {
                    "const": "date_range"
                  },
                  {
                    "const": "checked"
                  },
                  {
                    "const": "unchecked"
                  },
                  {
                    "const": "percent_checked"
                  },
                  {
                    "const": "percent_unchecked"
                  },
                  {
                    "const": "count_per_group"
                  },
                  {
                    "const": "percent_per_group"
                  },
                  {
                    "const": "show_original"
                  }
                ]
              }
            },
            "required": [
              "rollup_property_name",
              "relation_property_name",
              "rollup_property_id",
              "relation_property_id",
              "function"
            ]
          },
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "rollup",
          "id",
          "name"
        ],
        "title": "Database Aggregate Properties"
      },
      "INotion.TitleDatabaseProperty": {
        "type": "object",
        "properties": {
          "type": {
            "const": "title"
          },
          "title": {
            "$ref": "#/components/schemas/Recordstringnever"
          },
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "title",
          "id",
          "name"
        ],
        "title": "Database title property"
      },
      "INotion.RichTextDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "rich_text"
          },
          "rich_text": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "rich_text"
        ],
        "title": "database text property"
      },
      "INotion.UrlDatabaseProperty": {
        "type": "object",
        "properties": {
          "type": {
            "const": "url"
          },
          "url": {
            "$ref": "#/components/schemas/Recordstringnever"
          },
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "url",
          "id",
          "name"
        ],
        "title": "Database Url property"
      },
      "INotion.PeopleDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "people"
          },
          "people": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "people"
        ],
        "title": "database people properties"
      },
      "INotion.FilesDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "files"
          },
          "files": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "files"
        ],
        "title": "Database File Properties"
      },
      "INotion.EmailDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "email"
          },
          "email": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "email"
        ],
        "title": "Database Email Attributes"
      },
      "INotion.PhoneNumberDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "phone_number"
          },
          "phone_number": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "phone_number"
        ],
        "title": "Database Phone Number Attribute"
      },
      "INotion.DateDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "date"
          },
          "date": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "date"
        ],
        "title": "Database Date Attribute"
      },
      "INotion.CheckboxDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "checkbox"
          },
          "checkbox": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "checkbox"
        ],
        "title": "Database Checkbox Properties"
      },
      "INotion.CreatedByDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "created_by"
          }
        },
        "required": [
          "id",
          "name",
          "type"
        ],
        "title": "Database Creator Attributes"
      },
      "INotion.CreatedTimeDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "created_time"
          },
          "created_time": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "created_time"
        ],
        "title": "Database Creation Time Attribute"
      },
      "INotion.LastEditedByDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "last_edited_by"
          },
          "last_edited_by": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "last_edited_by"
        ],
        "title": "Database Last Modified Attribute"
      },
      "INotion.LastEditedTimeDatabaseProperty": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "type": {
            "const": "last_edited_time"
          },
          "last_edited_time": {
            "$ref": "#/components/schemas/Recordstringnever"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "last_edited_time"
        ],
        "title": "Database Modification Time Attribute"
      },
      "INotion.IDatabaseItemOutput": {
        "type": "object",
        "properties": {
          "parent": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "title": "type",
                "description": "Parent database item object type"
              },
              "database_id": {
                "type": "string",
                "title": "database id",
                "description": "database item parent id"
              }
            },
            "required": [
              "type",
              "database_id"
            ],
            "title": "Parent Database Item",
            "description": "Parent Database Item Information"
          },
          "properties": {
            "title": "Property",
            "description": "Database Item Properties"
          },
          "object": {
            "oneOf": [
              {
                "const": "user"
              },
              {
                "const": "page"
              },
              {
                "const": "list"
              },
              {
                "const": "database"
              },
              {
                "const": "block"
              },
              {
                "const": "property_item"
              },
              {
                "const": "comment"
              }
            ],
            "title": "Object Type",
            "description": "Type of page object"
          },
          "created_time": {
            "type": "string",
            "title": "Date created",
            "description": "Date the page was created"
          },
          "last_edited_time": {
            "type": "string",
            "title": "Last modified",
            "description": "Date the page was last modified"
          },
          "created_by": {
            "type": "object",
            "properties": {
              "object": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "page"
                  },
                  {
                    "const": "list"
                  },
                  {
                    "const": "database"
                  },
                  {
                    "const": "block"
                  },
                  {
                    "const": "property_item"
                  },
                  {
                    "const": "comment"
                  }
                ],
                "title": "Object Type",
                "description": "The type of the object that created the page"
              },
              "id": {
                "type": "string",
                "title": "id",
                "description": "Unique id of the person who created the page"
              }
            },
            "required": [
              "object",
              "id"
            ],
            "title": "Created by",
            "description": "Information about who created the page"
          },
          "last_edited_by": {
            "type": "object",
            "properties": {
              "object": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "page"
                  },
                  {
                    "const": "list"
                  },
                  {
                    "const": "database"
                  },
                  {
                    "const": "block"
                  },
                  {
                    "const": "property_item"
                  },
                  {
                    "const": "comment"
                  }
                ],
                "title": "Object Type",
                "description": "The type of object that last modified the page"
              },
              "id": {
                "type": "string",
                "title": "id",
                "description": "Unique id of the last person to edit the page"
              }
            },
            "required": [
              "object",
              "id"
            ],
            "title": "Last modified by",
            "description": "Information about who last modified the page"
          },
          "cover": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IPageCover"
              }
            ],
            "title": "Background Image",
            "description": "Page Background Image Information"
          },
          "icon": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IPageIcon"
              }
            ],
            "title": "Icon",
            "description": "Page Icon Information"
          },
          "archived": {
            "type": "boolean",
            "title": "Whether to archive the page",
            "description": "Whether to archive the page"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Page url"
          },
          "public_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "public url",
            "description": "Page public url"
          },
          "id": {
            "type": "string",
            "title": "page id",
            "description": "Unique id of the generated page"
          },
          "title": {
            "type": "string",
            "title": "tilte\n\nTitle of the document you just created"
          }
        },
        "required": [
          "parent",
          "properties",
          "object",
          "created_time",
          "last_edited_time",
          "created_by",
          "last_edited_by",
          "cover",
          "icon",
          "archived",
          "url",
          "public_url",
          "id",
          "title"
        ],
        "title": "Database item creation result"
      },
      "INotion.IPageCover": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "description": "Image Type"
          },
          "external": {
            "$ref": "#/components/schemas/INotion.IExternalImage",
            "title": "Image",
            "description": "Image information"
          }
        },
        "required": [
          "type",
          "external"
        ],
        "title": "Page background image information"
      },
      "INotion.IExternalImage": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "image url"
          }
        },
        "required": [
          "url"
        ],
        "title": "External image information"
      },
      "INotion.IPageIcon": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "file"
              },
              {
                "const": "emoji"
              },
              {
                "const": "external"
              }
            ],
            "title": "Type",
            "description": "Icon Type"
          },
          "emoji": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "Emoji icon",
            "description": "Icon information when the icon type is emoji"
          },
          "external": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IExternalImage"
              }
            ],
            "title": "Icon",
            "description": "Icon information when the icon type is icon"
          },
          "file": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url",
                "description": "file url"
              },
              "expiry_time": {
                "type": "string",
                "title": "expiration time",
                "description": "Image file expiration time"
              }
            },
            "required": [
              "url",
              "expiry_time"
            ],
            "title": "Icon file",
            "description": "Icon information when the icon type is file"
          }
        },
        "required": [
          "type"
        ],
        "title": "Page Icon Information"
      },
      "INotion.ICreateDatabaseItemInput": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "title": "property value",
            "description": "Value to add to database property"
          },
          "content": {
            "type": "string",
            "title": "page",
            "description": "What to put on the database item page you want to create\n\nWhat to put on the"
          },
          "contentType": {
            "oneOf": [
              {
                "const": "markdown"
              },
              {
                "const": "plainText"
              }
            ],
            "title": "Page content type",
            "description": "Database item page content type to create"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Information required to add an item to the database",
        "additionalProperties": {}
      },
      "INotion.IUpdateDatabaseItemInput": {
        "type": "object",
        "properties": {
          "pageId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/notion/get/page",
              "jmesPath": "[].{value:pageId, label:title}"
            },
            "title": "Page",
            "description": "Page to update"
          },
          "content": {
            "type": "string",
            "title": "Content",
            "description": "Database page content to update"
          },
          "value": {
            "type": "string",
            "title": "property value",
            "description": "Database property value to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "pageId",
          "secretKey"
        ],
        "title": "Information required to modify an item that exists in the database",
        "additionalProperties": {}
      },
      "INotion.IFindPageByTitleOutput": {
        "type": "object",
        "properties": {
          "parent": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "title": "Type",
                "description": "Parent Page Object Type"
              },
              "workspace": {
                "type": "boolean",
                "title": "Whether the workspace is",
                "description": "Whether the parent page is a workspace"
              }
            },
            "required": [
              "type",
              "workspace"
            ],
            "title": "Parent Page",
            "description": "Parent Page Information"
          },
          "properties": {
            "$ref": "#/components/schemas/INotion.IFindPageProperty",
            "title": "property",
            "description": "Page Properties Information"
          },
          "object": {
            "oneOf": [
              {
                "const": "user"
              },
              {
                "const": "page"
              },
              {
                "const": "list"
              },
              {
                "const": "database"
              },
              {
                "const": "block"
              },
              {
                "const": "property_item"
              },
              {
                "const": "comment"
              }
            ],
            "title": "Object Type",
            "description": "Type of page object"
          },
          "created_time": {
            "type": "string",
            "title": "Date created",
            "description": "Date the page was created"
          },
          "last_edited_time": {
            "type": "string",
            "title": "Last modified",
            "description": "Date the page was last modified"
          },
          "created_by": {
            "type": "object",
            "properties": {
              "object": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "page"
                  },
                  {
                    "const": "list"
                  },
                  {
                    "const": "database"
                  },
                  {
                    "const": "block"
                  },
                  {
                    "const": "property_item"
                  },
                  {
                    "const": "comment"
                  }
                ],
                "title": "Object Type",
                "description": "The type of the object that created the page"
              },
              "id": {
                "type": "string",
                "title": "id",
                "description": "Unique id of the person who created the page"
              }
            },
            "required": [
              "object",
              "id"
            ],
            "title": "Created by",
            "description": "Information about who created the page"
          },
          "last_edited_by": {
            "type": "object",
            "properties": {
              "object": {
                "oneOf": [
                  {
                    "const": "user"
                  },
                  {
                    "const": "page"
                  },
                  {
                    "const": "list"
                  },
                  {
                    "const": "database"
                  },
                  {
                    "const": "block"
                  },
                  {
                    "const": "property_item"
                  },
                  {
                    "const": "comment"
                  }
                ],
                "title": "Object Type",
                "description": "The type of object that last modified the page"
              },
              "id": {
                "type": "string",
                "title": "id",
                "description": "Unique id of the last person to edit the page"
              }
            },
            "required": [
              "object",
              "id"
            ],
            "title": "Last modified by",
            "description": "Information about who last modified the page"
          },
          "cover": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IPageCover"
              }
            ],
            "title": "Background Image",
            "description": "Page Background Image Information"
          },
          "icon": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/INotion.IPageIcon"
              }
            ],
            "title": "Icon",
            "description": "Page Icon Information"
          },
          "archived": {
            "type": "boolean",
            "title": "Whether to archive the page",
            "description": "Whether to archive the page"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "Page url"
          },
          "public_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "public url",
            "description": "Page public url"
          },
          "id": {
            "type": "string",
            "title": "page id",
            "description": "Unique id of the generated page"
          },
          "title": {
            "type": "string",
            "title": "tilte\n\nTitle of the document you just created"
          }
        },
        "required": [
          "parent",
          "properties",
          "object",
          "created_time",
          "last_edited_time",
          "created_by",
          "last_edited_by",
          "cover",
          "icon",
          "archived",
          "url",
          "public_url",
          "id",
          "title"
        ]
      },
      "INotion.IFindPageProperty": {
        "type": "object",
        "properties": {
          "title": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "id",
                "description": "Page property id"
              },
              "type": {
                "type": "string",
                "title": "Property Type",
                "description": "Page Property Type"
              },
              "title": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/INotion.IFindPageTitleProperty"
                },
                "title": "Title Attribute",
                "description": "Page Title Attribute Information"
              }
            },
            "required": [
              "id",
              "type",
              "title"
            ],
            "title": "Title attribute",
            "description": "Information about the title attribute"
          }
        },
        "required": [
          "title"
        ],
        "title": "Page property information"
      },
      "INotion.IFindPageTitleProperty": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "title": "type",
            "description": "Title property type"
          },
          "text": {
            "$ref": "#/components/schemas/INotion.IPageTitleText",
            "title": "Text Information",
            "description": "Page Title Text Information"
          },
          "annotations": {
            "$ref": "#/components/schemas/INotion.IPageTitleAnnotation",
            "title": "Additional Information",
            "description": "Page Title Additional Information"
          },
          "plain_text": {
            "type": "string",
            "title": "Original",
            "description": "Page Title Original Text"
          },
          "href": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Link",
            "description": "Page Link"
          }
        },
        "required": [
          "type",
          "text",
          "annotations",
          "plain_text",
          "href"
        ],
        "title": "Page title attribute"
      },
      "INotion.IPageTitleText": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "title": "Content",
            "description": "Title Text Content"
          },
          "link": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "Link",
            "description": "Page Title Link"
          }
        },
        "required": [
          "content",
          "link"
        ],
        "title": "Page title text information"
      },
      "INotion.IPageTitleAnnotation": {
        "type": "object",
        "properties": {
          "bold": {
            "type": "boolean",
            "title": "Bold",
            "description": "Title Text Bold"
          },
          "italic": {
            "type": "boolean",
            "title": "italicized",
            "description": "Title text italicized"
          },
          "strikethrough": {
            "type": "boolean",
            "title": "strikethrough",
            "description": "Title text strikethrough"
          },
          "underline": {
            "type": "boolean",
            "title": "underline",
            "description": "Title text underline"
          },
          "code": {
            "type": "boolean",
            "title": "Whether the title text is wrapped in code",
            "description": "Whether the title text is wrapped in code"
          },
          "color": {
            "type": "string",
            "title": "Color",
            "description": "Title Text Color"
          }
        },
        "required": [
          "bold",
          "italic",
          "strikethrough",
          "underline",
          "code",
          "color"
        ],
        "title": "Page title Additional information"
      },
      "INotion.IFindPageOrDatabaseItemInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "description": "Page Title"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "title",
          "secretKey"
        ],
        "title": "Information needed to search the page"
      },
      "INotion.IFindDatabaseItemInput": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "description": "The title of the item in the database item"
          },
          "number": {
            "type": "integer",
            "title": "Number",
            "description": "Number in database item"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url",
            "description": "url in database item"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email address",
            "description": "Email address in database item"
          },
          "rich_text": {
            "type": "string",
            "title": "text",
            "description": "Text in database item"
          },
          "phone_number": {
            "type": "string",
            "title": "Phone number",
            "description": "Phone number in database item"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "Information needed to find an item in the database",
        "additionalProperties": {}
      },
      "INotion.ICreatePageByMarkdownInput": {
        "type": "object",
        "properties": {
          "markdown": {
            "type": "string",
            "title": "markdown"
          },
          "parentPageId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/get/page",
                  "jmesPath": "[].{value:pageId, label:title}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/notion/page",
                  "jmesPath": "[].{value:id, label:id}"
                },
                "x-wrtn-placeholder": "부모 페이지를 선택하세요."
              }
            ]
          },
          "title": {
            "type": "string",
            "x-wrtn-placeholder": "테스트 페이지.",
            "title": "Page title",
            "description": "New page title to be created"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "notion",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "markdown",
          "parentPageId",
          "title",
          "secretKey"
        ]
      },
      "IGoogleHotel.IResponse": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Accommodation Name",
            "description": "Accommodation Name"
          },
          "description": {
            "type": "string",
            "title": "Property Description",
            "description": "Property Description"
          },
          "link": {
            "type": "string",
            "title": "Accommodation Link",
            "description": "Accommodation Link"
          },
          "check_in_time": {
            "type": "string",
            "title": "Check-in time",
            "description": "Accommodation check-in time"
          },
          "check_out_time": {
            "type": "string",
            "title": "Check-out Time",
            "description": "Accommodation Check-out Time"
          },
          "price": {
            "type": "string",
            "title": "Accommodation prices",
            "description": "Accommodation prices"
          },
          "nearby_place": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleHotel.INearbyPlace"
            },
            "title": "Facilities around the property",
            "description": "Facilities around the property"
          },
          "hotel_class": {
            "type": "string",
            "title": "Accommodation rating",
            "description": "Accommodation rating"
          },
          "thumbnails": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iri",
              "contentMediaType": "image/*"
            },
            "title": "thumbnail",
            "description": "Accommodation thumbnail image"
          },
          "rating": {
            "type": "string",
            "title": "rating",
            "description": "Accommodation rating"
          },
          "review_count": {
            "type": "string",
            "title": "Number of reviews",
            "description": "Number of reviews"
          },
          "amenities": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ],
            "title": "Amenities",
            "description": "Amenities provided by the property"
          },
          "excluded_amenities": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Amenities not provided",
            "description": "Amenities not provided by the property"
          }
        },
        "required": [
          "name",
          "price",
          "thumbnails",
          "amenities"
        ],
        "title": "Accommodation search results"
      },
      "IGoogleHotel.INearbyPlace": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Surrounding facility name",
            "description": "Surrounding facility name"
          },
          "transportations": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "title": "Types of Transportation",
                  "description": "Types of Transportation"
                },
                "duration": {
                  "type": "string",
                  "title": "Time required",
                  "description": "Time required to reach surrounding facilities"
                }
              },
              "required": [
                "type",
                "duration"
              ]
            },
            "title": "Transportation",
            "description": "Transportation to nearby facilities"
          }
        },
        "required": [
          "name"
        ],
        "title": "Surrounding facilities"
      },
      "IGoogleHotel.IRequest": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "title": "Search term",
            "description": "Enter the keyword you want to search for."
          },
          "check_in_date": {
            "type": "string",
            "format": "date",
            "title": "Check-in date",
            "description": "Set your check-in date.\n\nPlease enter a date after today's date."
          },
          "check_out_date": {
            "type": "string",
            "format": "date",
            "title": "Checkout Date",
            "description": "Set a checkout date.\n\nPlease enter a date after today's date."
          },
          "adults": {
            "type": "integer",
            "default": 2,
            "title": "Number of adults",
            "description": "Set the number of adults staying. The default is 2."
          },
          "children": {
            "type": "integer",
            "default": 0,
            "title": "Number of children",
            "description": "Set the number of children staying. The default is 0."
          },
          "sort_by": {
            "oneOf": [
              {
                "const": "3",
                "title": "낮은 가격 순"
              },
              {
                "const": "8",
                "title": "평점 높은 순"
              },
              {
                "const": "13",
                "title": "리뷰 많은 순"
              }
            ],
            "title": "Sort criteria",
            "description": "Please select the desired sort criteria.\n\nOnly 3, 8, and 13 are possible values."
          },
          "min_price": {
            "type": "integer",
            "title": "Minimum price",
            "description": "Please set the minimum price for the price range."
          },
          "max_price": {
            "type": "integer",
            "title": "Maximum price",
            "description": "Please set the maximum price for the price range."
          },
          "rating": {
            "oneOf": [
              {
                "const": "7",
                "title": "평점 3.5 이상"
              },
              {
                "const": "8",
                "title": "평점 4.0 이상"
              },
              {
                "const": "9",
                "title": "평점 4.5 이상"
              }
            ],
            "title": "Rating",
            "description": "Search only properties with a selected rating or higher.\n\nOnly possible values are 7, 8, and 9."
          },
          "type": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "12",
                  "title": "비치 호텔"
                },
                {
                  "const": "13",
                  "title": "부티크 호텔"
                },
                {
                  "const": "14",
                  "title": "호스텔"
                },
                {
                  "const": "15",
                  "title": "여관"
                },
                {
                  "const": "16",
                  "title": "모텔"
                },
                {
                  "const": "17",
                  "title": "리조트"
                },
                {
                  "const": "18",
                  "title": "스파 호텔"
                },
                {
                  "const": "19",
                  "title": "아침 식사를 제공하는 숙소(B&B)"
                },
                {
                  "const": "20",
                  "title": "기타"
                },
                {
                  "const": "21",
                  "title": "아파트 호텔"
                },
                {
                  "const": "22",
                  "title": "민박"
                },
                {
                  "const": "23",
                  "title": "일본식 비즈니스 호텔"
                },
                {
                  "const": "24",
                  "title": "료칸"
                }
              ]
            },
            "title": "Accommodation type",
            "description": "Please select the accommodation type.\n\nOnly 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 are possible values."
          },
          "hotel_class": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "1",
                  "title": "1성급"
                },
                {
                  "const": "2",
                  "title": "2성급"
                },
                {
                  "const": "3",
                  "title": "3성급"
                },
                {
                  "const": "4",
                  "title": "4성급"
                },
                {
                  "const": "5",
                  "title": "5성급"
                }
              ]
            },
            "title": "Accommodation class",
            "description": "Please select your accommodation class.'\n\nOnly 1, 2, 3, 4, 5 are possible values."
          },
          "free_cancellation": {
            "type": "boolean",
            "default": false,
            "title": "Is free cancellation possible?",
            "description": "Search only properties with free cancellation."
          },
          "max_results": {
            "type": "integer",
            "title": "Number of search results",
            "description": "Set the number of search results."
          }
        },
        "required": [
          "keyword",
          "check_in_date",
          "check_out_date",
          "max_results"
        ],
        "title": "Accommodation search criteria"
      },
      "IAirportInformation.IResponse": {
        "type": "object",
        "properties": {
          "country_name": {
            "type": "string",
            "title": "Country",
            "description": "Country Name"
          },
          "city_name": {
            "type": "string",
            "title": "City",
            "description": "City Name"
          },
          "airport_name": {
            "type": "string",
            "title": "Airport",
            "description": "Airport Name"
          },
          "airport_code": {
            "type": "string",
            "title": "Airport Code",
            "description": "Airport Code"
          }
        },
        "required": [
          "country_name",
          "city_name",
          "airport_name",
          "airport_code"
        ],
        "title": "Airport information search results"
      },
      "IAirportInformation.IRequest": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "title": "Search term",
            "description": "Enter the name of the country or city you want to search for."
          }
        },
        "required": [
          "keyword"
        ],
        "title": "Airport information search conditions"
      },
      "IGoogleFlight.IFinalResponse": {
        "type": "object",
        "properties": {
          "flight": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleFlight.ISearchOutput"
            },
            "title": "Final selected flight information",
            "description": "Here is the final selected flight information."
          },
          "booking_options": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleFlight.IBookingOption"
            },
            "title": "Reservation Information",
            "description": "Here is the information you need to book your chosen flight."
          }
        },
        "required": [
          "flight",
          "booking_options"
        ],
        "title": "Final flight selection results",
        "description": "Here are the final flight selection results."
      },
      "IGoogleFlight.ISearchOutput": {
        "type": "object",
        "properties": {
          "flight": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGoogleFlight.IFlight"
            },
            "title": "Flight Information",
            "description": "Here is the flight information."
          },
          "total_duration": {
            "type": "string",
            "title": "Total flight time",
            "description": "Total flight time."
          },
          "price": {
            "type": "string",
            "title": "Flight prices",
            "description": "Flight prices."
          },
          "layover": {
            "$ref": "#/components/schemas/IGoogleFlight.ILayover",
            "title": "Transfer Information",
            "description": "Here is the flight transfer information."
          },
          "departure_token": {
            "type": "string",
            "title": "Return flight search token",
            "description": "Token for return flight search"
          },
          "booking_token": {
            "type": "string",
            "title": "Final confirmation token for flight",
            "description": "Token for final confirmation of flight"
          }
        },
        "required": [
          "flight",
          "total_duration",
          "price"
        ],
        "title": "Flight search results",
        "description": "Here are the flight search results."
      },
      "IGoogleFlight.IFlight": {
        "type": "object",
        "properties": {
          "departure_airport": {
            "$ref": "#/components/schemas/IGoogleFlight.IAirport",
            "title": "Departure Information",
            "description": "Here is the flight departure information."
          },
          "arrival_airport": {
            "$ref": "#/components/schemas/IGoogleFlight.IAirport",
            "title": "Arrival Information",
            "description": "Here is the flight arrival information."
          },
          "duration": {
            "type": "string",
            "title": "Flight time",
            "description": "This is the time it takes to fly."
          },
          "airplane": {
            "type": "string",
            "title": "Airplane type",
            "description": "Here is the aircraft type information."
          },
          "airline": {
            "type": "string",
            "title": "Airline",
            "description": "Here is the airline information."
          },
          "airline_logo": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "image/*",
            "title": "Airline Logo",
            "description": "This is an image of an airline logo."
          },
          "travel_class": {
            "type": "string",
            "title": "Seat Class",
            "description": "Here is the seat class information."
          },
          "flight_number": {
            "type": "string",
            "title": "Flight number",
            "description": "Flight number is."
          }
        },
        "required": [
          "departure_airport",
          "arrival_airport",
          "duration",
          "airplane",
          "airline",
          "airline_logo",
          "travel_class",
          "flight_number"
        ]
      },
      "IGoogleFlight.IAirport": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Airport name",
            "description": "Airport name."
          },
          "code": {
            "type": "string",
            "title": "Airport Code",
            "description": "This is a three-digit airport code."
          },
          "time": {
            "type": "string",
            "title": "Flight Departure Date / Time",
            "description": "The date and time of the flight departure."
          }
        },
        "required": [
          "name",
          "code",
          "time"
        ],
        "title": "Flight Information"
      },
      "IGoogleFlight.ILayover": {
        "type": "object",
        "properties": {
          "duration": {
            "type": "string",
            "title": "Transfer time",
            "description": "It's transfer time."
          },
          "name": {
            "type": "string",
            "title": "Airport name",
            "description": "Airport name."
          },
          "code": {
            "type": "string",
            "title": "Airport Code",
            "description": "This is a three-digit airport code."
          }
        },
        "required": [
          "duration",
          "name",
          "code"
        ],
        "title": "Transfer information"
      },
      "IGoogleFlight.IBookingOption": {
        "type": "object",
        "properties": {
          "book_with": {
            "type": "string",
            "title": "Reservation site",
            "description": "This is a site where you can book flights of your choice."
          },
          "price": {
            "type": "string",
            "title": "Price",
            "description": "The price of the selected flight."
          },
          "book_link": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/Formaturi"
              }
            ],
            "title": "Reservation Link",
            "description": "Here is a link to book your selected flight."
          }
        },
        "required": [
          "book_with",
          "price",
          "book_link"
        ],
        "title": "Reservation options",
        "description": "Reservation options."
      },
      "Formaturi": {
        "type": "object",
        "properties": {
          "typia.tag": {
            "type": "object",
            "properties": {
              "target": {
                "const": "string"
              },
              "kind": {
                "const": "format"
              },
              "value": {
                "const": "uri"
              },
              "validate": {
                "const": "/\\/|:/.test($input) && /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i.test($input)"
              },
              "exclusive": {
                "type": "array",
                "prefixItems": [
                  {
                    "const": "format"
                  },
                  {
                    "const": "pattern"
                  }
                ],
                "additionalItems": false
              },
              "schema": {
                "type": "object",
                "properties": {
                  "format": {
                    "const": "uri"
                  }
                },
                "required": [
                  "format"
                ]
              }
            },
            "required": [
              "target",
              "kind",
              "value",
              "validate",
              "exclusive",
              "schema"
            ],
            "title": "This is a dummy property for compilation",
            "description": "This is a dummy property for compilation.\n\nIt does not mean anything in runtime."
          }
        }
      },
      "IGoogleFlight.IRequest": {
        "type": "object",
        "properties": {
          "departure_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/airport-information/search",
              "jmesPath": "[].{value:airport_code, label: [country_name, city_name, airport_name, airport_code].join('-', @)}"
            },
            "title": "Departure",
            "description": "Please enter the code of the departure airport.\n\nThe departure code must be the same even if it is a round trip (type \"1\").\n\nWhen calling connector/google-flight/arrival for a round trip (type \"1\"), the departure_id must be the same as when calling connector/google-flight/departure."
          },
          "arrival_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/airport-information/search",
              "jmesPath": "[].{value:airport_code, label: [country_name, city_name, airport_name, airport_code].join('-', @)}"
            },
            "title": "Destination",
            "description": "Please enter the destination airport code.\n\nEven if it is a round trip (type \"1\"), the destination code must be the same.\n\nWhen calling connector/google-flight/arrival for a round trip (type \"1\"), the arrival_id must be the same as when calling connector/google-flight/departure."
          },
          "type": {
            "oneOf": [
              {
                "const": "1",
                "title": "왕복"
              },
              {
                "const": "2",
                "title": "편도"
              }
            ],
            "title": "Round trip or one way",
            "description": "Please select whether it is round trip or one way.\n\nPossible values are 1 and 2.\n\nPlease select \"1\" for round trip and \"2\" for one way."
          },
          "outbound_date": {
            "type": "string",
            "format": "date",
            "title": "Departure date",
            "description": "Please enter your departure date.\n\nPlease enter a date after today's date."
          },
          "return_date": {
            "type": "string",
            "format": "date",
            "title": "Date of arrival",
            "description": "Please enter the date of arrival.\n\nIf type is \"1\", it must be entered.\n\nIf type is \"2\", it must not be entered.\n\nPlease enter a date after today's date."
          },
          "adults": {
            "type": "integer",
            "title": "Number of adults",
            "description": "Please enter the number of adults."
          },
          "children": {
            "type": "integer",
            "title": "Number of children",
            "description": "Please enter the number of children."
          },
          "stop": {
            "oneOf": [
              {
                "const": "0",
                "title": "상관 없음"
              },
              {
                "const": "1",
                "title": "직항"
              },
              {
                "const": "2",
                "title": "1번 경유"
              },
              {
                "const": "3",
                "title": "2번 이상 경유"
              }
            ],
            "title": "Whether it is a direct flight",
            "description": "Please select whether it is a direct flight.\n\nPossible values are 0, 1, 2, 3."
          },
          "max_price": {
            "type": "integer",
            "title": "Maximum Price",
            "description": "Please enter the maximum price for your flight.\n\nYou must search for flights that do not exceed the maximum price you entered."
          }
        },
        "required": [
          "departure_id",
          "arrival_id",
          "type",
          "outbound_date",
          "adults",
          "stop"
        ],
        "title": "Information needed to search for airline tickets"
      },
      "ISlack.Payload": {
        "type": "object",
        "properties": {
          "payload": {
            "type": "string"
          }
        },
        "required": [
          "payload"
        ]
      },
      "ISlack.IHoldVoteOutput": {
        "type": "object",
        "properties": {
          "blocks": {
            "type": "array",
            "items": {},
            "title": "title blocks"
          },
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp\n\nfor example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          }
        },
        "required": [
          "ts"
        ]
      },
      "ISlack.IHoldVoteInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id"
          },
          "title": {
            "type": "string",
            "title": "Title of vote to be held\n\nIt should be written as a simple one-line markdown and can include Slack emojis."
          },
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "title": "option title"
                },
                "link": {
                  "type": "string",
                  "title": "option's link"
                }
              },
              "required": [
                "text"
              ]
            },
            "title": "options available for voting\n\nIt refers to the options available for voting."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "channel",
          "title",
          "items",
          "secretKey"
        ]
      },
      "ISlack.IMarkInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id\n\nIt refers to the channel on which you want to mark the conversation history.\nIf you don't know the channel's ID, You need to view the channel first."
          },
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-channel-histories",
              "jmesPath": "messages[].{value: ts, label: text}"
            },
            "title": "ts",
            "description": "It means the 'ts' value of the chat you want to mark"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "channel",
          "ts",
          "secretKey"
        ]
      },
      "MyPickISlack.ScheduledMessagepost_at": {
        "type": "object",
        "properties": {
          "post_at": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp\n\nfor example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          }
        },
        "required": [
          "post_at"
        ]
      },
      "ISlack.ISCheduleMessageInput": {
        "type": "object",
        "properties": {
          "post_at": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "Transfer Schedule Time",
            "description": "You can schedule the time you want to send the message in advance.\nThe scheduled time must be in the same form as the ts property in the Message."
          },
          "thread_ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "thread ts\n\nIf the message you want to schedule is within a specific thread, you must pass the ts value of the parent message."
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id\n\nIt refers to the channel on which you want to view the conversation history.\nIf you don't know the channel's ID, You need to view the channel first."
          },
          "text": {
            "type": "string",
            "title": "message to send\n\nWhen a user enters a markdown format string, the internal function modifies it to the format of the slack.\nUsers can put text in accordance with the usual markdown grammar.\nFor user readability, it is recommended that the string be sent with appropriate new-line characters."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "post_at",
          "channel",
          "text",
          "secretKey"
        ]
      },
      "ISlack.IDeleteSCheduleMessageInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id\n\nIt refers to the channel on which you want to delete the scheduled message.\nIf you don't know the channel's ID, You need to view the channel first."
          },
          "scheduled_message_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-scheduled-messages",
              "jmesPath": "scheduled_messages[].{value:id, label:text}"
            },
            "title": "scheduled message id to delete"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "channel",
          "scheduled_message_id",
          "secretKey"
        ]
      },
      "MyPickISlack.Messagets": {
        "type": "object",
        "properties": {
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp\n\nfor example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          }
        },
        "required": [
          "ts"
        ]
      },
      "ISlack.IPostMessageToMyselfInput": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "title": "message to send"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "text",
          "secretKey"
        ]
      },
      "ISlack.IPostMessageReplyInput": {
        "type": "object",
        "properties": {
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-channel-histories",
              "jmesPath": "messages[].{value: ts, label: text}"
            },
            "title": "ts",
            "description": "It means the 'ts' value of the chat you want to reply"
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id\n\nIt refers to the channel on which you want to view the conversation history.\nIf you don't know the channel's ID, You need to view the channel first."
          },
          "text": {
            "type": "string",
            "title": "message to send\n\nWhen a user enters a markdown format string, the internal function modifies it to the format of the slack.\nUsers can put text in accordance with the usual markdown grammar.\nFor user readability, it is recommended that the string be sent with appropriate new-line characters."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "ts",
          "channel",
          "text",
          "secretKey"
        ]
      },
      "ISlack.IPostMessageInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id\n\nIt refers to the channel on which you want to view the conversation history.\nIf you don't know the channel's ID, You need to view the channel first."
          },
          "text": {
            "type": "string",
            "title": "message to send\n\nWhen a user enters a markdown format string, the internal function modifies it to the format of the slack.\nUsers can put text in accordance with the usual markdown grammar.\nFor user readability, it is recommended that the string be sent with appropriate new-line characters."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "channel",
          "text",
          "secretKey"
        ]
      },
      "ISlack.IGetScheduledMessageListOutput": {
        "type": "object",
        "properties": {
          "scheduled_messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScheduledMessageidstringpost_at_datestring"
            },
            "title": "scheduled messages"
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`."
          }
        },
        "required": [
          "scheduled_messages",
          "next_cursor"
        ]
      },
      "ScheduledMessageidstringpost_at_datestring": {
        "type": "object",
        "properties": {
          "post_at": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp\n\nfor example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          },
          "date_created": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "when the user scheduled the message"
          },
          "text": {
            "type": "string",
            "title": "message contents\n\nWhen users occasionally call others, they can be called in the form of '@USERNAME', which is called a tag."
          },
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.Attachmenttitleid"
            },
            "title": "Attachments\n\nAttachement contains all types of files and can sometimes be an external link.\nIt is not the type that can be confirmed because the internal properties can vary depending on the type of block it is making up."
          },
          "channel": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id"
          },
          "id": {
            "type": "string",
            "title": "id of scheduled message"
          },
          "post_at_date": {
            "type": "string",
            "title": "date-time format of post_at"
          }
        },
        "required": [
          "post_at",
          "date_created",
          "text",
          "channel",
          "id",
          "post_at_date"
        ]
      },
      "MyPickISlack.Attachmenttitleid": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "title\n\nLarge title text near the top of the attachment."
          },
          "id": {
            "type": "number",
            "title": "id"
          }
        }
      },
      "ISlack.IGetScheduledMessageListInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit\n\nIndicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details, it is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          },
          "cursor": {
            "type": "string",
            "title": "cursor\n\nIf you pass the cursor value received from the previous inquiry, you can inquire from the data after the cursor.\nIf you don't put a value, it will be recognized as the first page.\nThis should never be null. If you don't have a value, don't forward properties."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ISlack.IGetUserDetailOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "fields": {
            "$ref": "#/components/schemas/Recordstringstring",
            "title": "custom fields"
          },
          "display_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "display name",
            "description": "The user has a separate display name.\nA display name is a name that the user has chosen to show.\nTherefore, it would be best to use this name as a courtesy."
          },
          "real_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "real_name",
            "description": "The user's first and last name.\nUpdating this field will update first_name and last_name.\nIf only one name is provided, the value of last_name will be cleared."
          },
          "status_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "status"
          }
        },
        "required": [
          "id",
          "fields",
          "display_name",
          "real_name"
        ],
        "title": "profile\n\nUser information will usually include user's directories, start date, email, phone number, and status information.\nThe start date usually records when this member joined Slack or when he joined the team, but all the information here is written by the individual user and not by the HR person."
      },
      "Recordstringstring": {
        "type": "object",
        "properties": {},
        "description": "Construct a type with a set of properties K of type T",
        "additionalProperties": {
          "type": "string"
        }
      },
      "ISlack.IGetUserDetailInput": {
        "type": "object",
        "properties": {
          "userIds": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/slack/get-users",
                "jmesPath": "users[].{value: id, label: display_name}"
              }
            },
            "minItems": 1,
            "title": "userIds\n\nYou can enter the ID value of the user who wants to look up the details."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "userIds",
          "secretKey"
        ]
      },
      "ISlack.IGetUserListOutput": {
        "type": "object",
        "properties": {
          "users": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitISlack.IGetUserOutputfields"
            },
            "title": "user list"
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`."
          }
        },
        "required": [
          "users",
          "next_cursor"
        ]
      },
      "StrictOmitISlack.IGetUserOutputfields": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name",
            "description": "This is the name of the user,\nbut in some countries,\nit may not be possible to call the user's name carelessly,\nand the company should refrain from using it because the position exists."
          },
          "id": {
            "type": "string"
          },
          "profile_image": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri",
                "contentMediaType": "image/*"
              }
            ],
            "title": "profile image",
            "description": "There are several profile images for each image quality,\nbut here we provide them based on the first image uploaded by the user."
          },
          "display_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "display name",
            "description": "The user has a separate display name.\nA display name is a name that the user has chosen to show.\nTherefore, it would be best to use this name as a courtesy."
          },
          "real_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "real_name",
            "description": "The user's first and last name.\nUpdating this field will update first_name and last_name.\nIf only one name is provided, the value of last_name will be cleared."
          },
          "deleted": {
            "type": "boolean",
            "title": "deleted",
            "description": "This value is used to distinguish between deleted users."
          },
          "status_text": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "status"
          }
        },
        "required": [
          "name",
          "id",
          "profile_image",
          "display_name",
          "real_name",
          "deleted"
        ]
      },
      "ISlack.IGetUserListInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit\n\nIndicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details, it is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          },
          "cursor": {
            "type": "string",
            "title": "cursor\n\nIf you pass the cursor value received from the previous inquiry, you can inquire from the data after the cursor.\nIf you don't put a value, it will be recognized as the first page.\nThis should never be null. If you don't have a value, don't forward properties."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ISlack.IGetReplyOutput": {
        "type": "object",
        "properties": {
          "replies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ISlack.Reply"
            },
            "title": "replies",
            "description": "This value refers to replies that depend on the currently viewed thread."
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`."
          }
        },
        "required": [
          "replies",
          "next_cursor"
        ]
      },
      "ISlack.Reply": {
        "type": "object",
        "properties": {
          "thread_ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "thread ts"
          },
          "parent_user_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "ID of the person who made parent message of this message\n\nIf this Reply has been published from thread to thread,\noutside of thread, and also as a channel,\nthere is no parent_user_id."
          },
          "type": {
            "const": "message",
            "title": "type"
          },
          "user": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "ID of the person who made this message\n\nIf not a user, message does not have an ID."
          },
          "text": {
            "type": "string",
            "title": "message contents\n\nWhen users occasionally call others, they can be called in the form of '@USERNAME', which is called a tag."
          },
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.Attachmenttitleid"
            },
            "title": "Attachments\n\nAttachement contains all types of files and can sometimes be an external link.\nIt is not the type that can be confirmed because the internal properties can vary depending on the type of block it is making up."
          },
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp\n\nfor example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          },
          "ts_date": {
            "type": "string",
            "title": "date format of `ts`\n\nThis is the value changed to ISO String to make it easier to recognize the current time value by separating 'ts'."
          }
        },
        "required": [
          "thread_ts",
          "parent_user_id",
          "type",
          "user",
          "text",
          "ts",
          "ts_date"
        ]
      },
      "ISlack.IGetReplyInput": {
        "type": "object",
        "properties": {
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-channel-histories",
              "jmesPath": "messages[].{value: ts, label: text}"
            },
            "title": "ts",
            "description": "It means the 'ts' value of the chat you want to look up."
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id\n\nIt refers to the channel on which you want to view the conversation history.\nYou need to view the channel first.\nThis is a string that always begins with a capital letter 'C' or 'D'."
          },
          "latestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "latestDateTime\n\nOnly messages before this date-time will be included in results. Default is the current time.\nIt is a value that takes precedence over 'latest', 'latestTimestamp'."
          },
          "oldestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "oldestDateTime\n\nOnly messages after this date-time will be included in results.\nIt is a value that takes precedence over 'oldest', 'oldestTimestamp'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit\n\nIndicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details, it is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          },
          "cursor": {
            "type": "string",
            "title": "cursor\n\nIf you pass the cursor value received from the previous inquiry, you can inquire from the data after the cursor.\nIf you don't put a value, it will be recognized as the first page.\nThis should never be null. If you don't have a value, don't forward properties."
          }
        },
        "required": [
          "ts",
          "channel",
          "secretKey"
        ]
      },
      "ISlack.IGetChannelLinkHistoryOutput": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitISlack.LinkMessagetypeattachments"
            },
            "title": "message\n\nThis refers to the history of conversations made on the channel.\nThe closer you are to the 0th in the array, the more recent it is.\nHowever, Slack's message can be modified, so just because it is the 0th, it may not be the last writing/modified."
          },
          "members": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.IGetUserOutputiddisplay_name"
            },
            "title": "members\n\nThis is a list of people who participated in the conversation in this conversation list."
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`."
          }
        },
        "required": [
          "messages",
          "members",
          "next_cursor"
        ]
      },
      "StrictOmitISlack.LinkMessagetypeattachments": {
        "type": "object",
        "properties": {
          "user": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "ID of the person who made this message\n\nIf not a user, message does not have an ID."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "shortcut link\n\nLink to view the conversation history immediately.\nWe can provide you with a shortcut link if user want, but you don't have to expose it to them in normal times."
          },
          "text": {
            "type": "string",
            "title": "message contents\n\nWhen users occasionally call others, they can be called in the form of '@USERNAME', which is called a tag."
          },
          "channel": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id"
          },
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp\n\nfor example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          },
          "reply_count": {
            "type": "number",
            "title": "reply_count\n\nIndicates the number of replies on this thread.\nIf there are many replies, active discussions are underway."
          },
          "reply_users_count": {
            "type": "number",
            "title": "reply_users_count\n\nThis means the person who has one or more Replys in this thread.\nThe number of unique people discussing in the thread."
          },
          "ts_date": {
            "type": "string",
            "title": "date format of `ts`\n\nThis is the value changed to ISO String to make it easier to recognize the current time value by separating 'ts'."
          },
          "links": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iri"
            },
            "title": "links\n\nLinks from the chat"
          }
        },
        "required": [
          "user",
          "link",
          "text",
          "channel",
          "ts",
          "reply_count",
          "reply_users_count",
          "ts_date",
          "links"
        ]
      },
      "MyPickISlack.IGetUserOutputiddisplay_name": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "display_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "display name",
            "description": "The user has a separate display name.\nA display name is a name that the user has chosen to show.\nTherefore, it would be best to use this name as a courtesy."
          }
        },
        "required": [
          "id",
          "display_name"
        ]
      },
      "ISlack.IGetChannelHistoryInput": {
        "type": "object",
        "properties": {
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "channel id\n\nIt refers to the channel on which you want to view the conversation history.\nYou need to view the channel first.\nThis is a string that always begins with a capital letter 'C' or 'D'."
          },
          "latestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "latestDateTime\n\nOnly messages before this date-time will be included in results. Default is the current time.\nIt is a value that takes precedence over 'latest', 'latestTimestamp'."
          },
          "oldestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "oldestDateTime\n\nOnly messages after this date-time will be included in results.\nIt is a value that takes precedence over 'oldest', 'oldestTimestamp'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit\n\nIndicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details, it is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          },
          "cursor": {
            "type": "string",
            "title": "cursor\n\nIf you pass the cursor value received from the previous inquiry, you can inquire from the data after the cursor.\nIf you don't put a value, it will be recognized as the first page.\nThis should never be null. If you don't have a value, don't forward properties."
          }
        },
        "required": [
          "channel",
          "secretKey"
        ]
      },
      "ISlack.IGetChannelHistoryOutput": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitISlack.Messagetypeattachments"
            },
            "title": "message\n\nThis refers to the history of conversations made on the channel.\nThe closer you are to the 0th in the array, the more recent it is.\nHowever, Slack's message can be modified, so just because it is the 0th, it may not be the last writing/modified."
          },
          "members": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.IGetUserOutputiddisplay_name"
            },
            "title": "members\n\nThis is a list of people who participated in the conversation in this conversation list."
          },
          "next_cursor": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "next_cursor\n\nIf the following data exist, the cursor value exists.\nIf you want to see the next data from these data,\nyou can pass this value to the next request condition, `cursor`."
          }
        },
        "required": [
          "messages",
          "members",
          "next_cursor"
        ]
      },
      "StrictOmitISlack.Messagetypeattachments": {
        "type": "object",
        "properties": {
          "user": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "ID of the person who made this message\n\nIf not a user, message does not have an ID."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "shortcut link\n\nLink to view the conversation history immediately.\nWe can provide you with a shortcut link if user want, but you don't have to expose it to them in normal times."
          },
          "text": {
            "type": "string",
            "title": "message contents\n\nWhen users occasionally call others, they can be called in the form of '@USERNAME', which is called a tag."
          },
          "channel": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id"
          },
          "ts": {
            "type": "string",
            "x-wrtn-placeholder": "1234567890.123456",
            "title": "timestamp\n\nfor example, `1721804246.083609`.\nThis is the time value expression method used by Slack."
          },
          "reply_count": {
            "type": "number",
            "title": "reply_count\n\nIndicates the number of replies on this thread.\nIf there are many replies, active discussions are underway."
          },
          "reply_users_count": {
            "type": "number",
            "title": "reply_users_count\n\nThis means the person who has one or more Replys in this thread.\nThe number of unique people discussing in the thread."
          },
          "ts_date": {
            "type": "string",
            "title": "date format of `ts`\n\nThis is the value changed to ISO String to make it easier to recognize the current time value by separating 'ts'."
          }
        },
        "required": [
          "user",
          "link",
          "text",
          "channel",
          "ts",
          "reply_count",
          "reply_users_count",
          "ts_date"
        ]
      },
      "ISlack.PrivateChannel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "channel name"
          },
          "id": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id\n\nThe channel ID starts with 'C' and 'D', and for a private DM channel, 'D'.\nBut Sometimes there are channel names that start with a G."
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "ISlack.IGetChannelInput": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "deprecated": true,
            "title": "limit"
          },
          "cursor": {
            "type": "string",
            "deprecated": true,
            "title": "cursor"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ],
        "title": "request condition"
      },
      "ISlack.PublicChannel": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "channel name"
          },
          "id": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id\n\nThe channel ID starts with 'C' and 'D', and for a private DM channel, 'D'.\nBut Sometimes there are channel names that start with a G."
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "ISlack.ImChannel": {
        "type": "object",
        "properties": {
          "created": {
            "type": "integer",
            "title": "created time"
          },
          "is_im": {
            "const": true,
            "title": "Is it the `im` type or not"
          },
          "is_org_shared": {
            "type": "boolean",
            "title": "is org shared"
          },
          "is_user_deleted": {
            "type": "boolean",
            "title": "is user deleted"
          },
          "priority": {
            "type": "number",
            "title": "priority"
          },
          "user": {
            "type": "string",
            "title": "channel owner's id"
          },
          "id": {
            "type": "string",
            "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
            "title": "channel id\n\nThe channel ID starts with 'C' and 'D', and for a private DM channel, 'D'.\nBut Sometimes there are channel names that start with a G."
          }
        },
        "required": [
          "created",
          "is_im",
          "is_org_shared",
          "is_user_deleted",
          "priority",
          "user",
          "id"
        ]
      },
      "ISlack.IGetFileOutput": {
        "type": "object",
        "properties": {
          "ok": {
            "type": "boolean"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickISlack.Filenameusersizeidchannelscomments_countcreatedmimetypeurl_privateurl_private_downloadthumb_1024"
            }
          },
          "paging": {
            "type": "object",
            "properties": {
              "count": {
                "type": "number",
                "title": "current file count"
              },
              "total": {
                "type": "number",
                "title": "total page"
              },
              "page": {
                "type": "number",
                "title": "current page"
              },
              "pages": {
                "type": "number",
                "title": "total page"
              }
            },
            "required": [
              "count",
              "total",
              "page",
              "pages"
            ]
          }
        },
        "required": [
          "ok",
          "files",
          "paging"
        ],
        "title": "File Lookup Results"
      },
      "MyPickISlack.Filenameusersizeidchannelscomments_countcreatedmimetypeurl_privateurl_private_downloadthumb_1024": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name"
          },
          "user": {
            "type": "string",
            "title": "user"
          },
          "size": {
            "type": "integer",
            "title": "size"
          },
          "id": {
            "type": "string",
            "title": "id"
          },
          "channels": {
            "type": "array",
            "items": {
              "type": "string",
              "pattern": "^((C(.*))|(D(.*))|(G(.*)))"
            },
            "title": "channels"
          },
          "comments_count": {
            "type": "integer",
            "title": "comments_count"
          },
          "created": {
            "type": "number",
            "title": "created"
          },
          "mimetype": {
            "type": "string",
            "title": "mimetype"
          },
          "url_private": {
            "type": "string",
            "format": "iri",
            "title": "url_private"
          },
          "url_private_download": {
            "type": "string",
            "format": "iri",
            "title": "url_private_download"
          },
          "thumb_1024": {
            "type": "string",
            "format": "iri",
            "title": "thumb_1024"
          }
        },
        "required": [
          "name",
          "user",
          "size",
          "id",
          "channels",
          "comments_count",
          "created",
          "mimetype"
        ]
      },
      "ISlack.IGetFileInput": {
        "type": "object",
        "properties": {
          "page": {
            "type": "number",
            "default": 1,
            "title": "page"
          },
          "channel": {
            "oneOf": [
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-public-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-private-channels",
                  "jmesPath": "[].{value:id, label:name}"
                }
              },
              {
                "type": "string",
                "pattern": "^((C(.*))|(D(.*))|(G(.*)))",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/slack/get-im-channels",
                  "jmesPath": "[].{value:id, label:name || '개인 채널'}"
                }
              }
            ],
            "title": "Channel ID to browse the file\n\nIf not specified, the entire Slack workspace will be explored."
          },
          "user": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/slack/get-users",
              "jmesPath": "users[].{value: id, label: display_name}"
            },
            "title": "user id\n\nIf you only want to check files sent by a particular user, enter your ID."
          },
          "types": {
            "type": "object",
            "properties": {
              "spaces": {
                "type": "boolean",
                "title": "spaces\n\nSlack's Post is a feature that allows users to write and share long forms of documents or writings.\nIt is more formatting free than regular messages and can contain code blocks or sections, which are useful for creating structured documents.\nSlack often categorizes these documented files into spaces, helping to share knowledge or information easily within the team."
              },
              "snippets": {
                "type": "boolean",
                "title": "snippets\n\nSnippets are used to share short code or text snippets.\nThey are usually useful when programmers share short code blocks or snippets of log files with their teams.\nSnippets quickly uploads text or code, and allows others to refer to or copy the content. In Slack, these files are classified into a file type called snippets."
              },
              "images": {
                "type": "boolean",
                "title": "images"
              },
              "gdocs": {
                "type": "boolean",
                "title": "gdocs\n\nGoogle docs"
              },
              "zips": {
                "type": "boolean",
                "title": "zips"
              },
              "pdfs": {
                "type": "boolean",
                "title": "pdfs"
              }
            },
            "title": "file types to include\n\nThe file types you may encounter include (but are not limited to):\nIf you want to look up all of them regardless of the file type, you can ignore the properties.\nIf the file type is important, you can specify the file type property as true inside the object."
          },
          "latestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "latestDateTime\n\nOnly files before this date-time will be included in results. Default is the current time.\nIt is a value that takes precedence over 'latest', 'latestTimestamp'."
          },
          "oldestDateTime": {
            "type": "string",
            "format": "date-time",
            "title": "oldestDateTime\n\nOnly files after this date-time will be included in results.\nIt is a value that takes precedence over 'oldest', 'oldestTimestamp'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "slack",
            "x-wrtn-secret-scopes": [
              "channels:read",
              "channels:history",
              "users.profile:read",
              "im:read",
              "groups:history",
              "groups:read",
              "chat:write",
              "users:read",
              "files:read"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 1000,
            "x-wrtn-placeholder": "200",
            "title": "limit\n\nIndicates the number of data to look up at at once.\nIf not entered, use 100 as the default.\nThis should never be null. If you don't have a value, don't forward properties.\n\nIn reality, the value can be from 1 to 1000, so the recommendation is a number over 200.\nIf there is a user's request and there is a section that is cumbersome to page, you can enter 200.\n\nSince it is burdensome for users to inquire too many conversation details, it is recommended to page 100 to 200 conversation details at a time if more data is needed.\nAlternatively, it is also helpful to get a date to inquire from the user."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "StrictOmitIDeleteCommentInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key\n\nThis connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "commentId": {
            "type": "string",
            "title": "ID of comment to delete"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "commentId",
          "secretKey"
        ]
      },
      "IJira.IUpdateCommentByMarkdownInput": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/StrictOmittypedocversion1contentTopLevelBlockNodecontentcontentstring",
            "title": "body of comment"
          },
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key\n\nThis connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "commentId": {
            "type": "string",
            "title": "ID of comment to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "body",
          "issueIdOrKey",
          "commentId",
          "secretKey"
        ]
      },
      "StrictOmittypedocversion1contentTopLevelBlockNodecontentcontentstring": {
        "type": "object",
        "properties": {
          "version": {
            "const": 1
          },
          "type": {
            "const": "doc"
          },
          "content": {
            "type": "string",
            "title": "contents of description\n\nYou must use markdown format string.\n\nIt is recommended to contain as much detail as possible on the issue raised by the user,\nso that the next person who reads this issue can see the summary and description of this issue to resolve the issue."
          }
        },
        "required": [
          "version",
          "type",
          "content"
        ]
      },
      "IJira.ICreateCommentOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "ID of comment"
          }
        },
        "required": [
          "id"
        ]
      },
      "IJira.ICreateCommentByMarkdownInput": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/StrictOmittypedocversion1contentTopLevelBlockNodecontentcontentstring.o1",
            "title": "body of comment"
          },
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key\n\nThis connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "body",
          "issueIdOrKey",
          "secretKey"
        ]
      },
      "StrictOmittypedocversion1contentTopLevelBlockNodecontentcontentstring.o1": {
        "type": "object",
        "properties": {
          "version": {
            "const": 1
          },
          "type": {
            "const": "doc"
          },
          "content": {
            "type": "string",
            "title": "contents of description\n\nYou must use markdown format string.\n\nIt is recommended to contain as much detail as possible on the issue raised by the user,\nso that the next person who reads this issue can see the summary and description of this issue to resolve the issue."
          }
        },
        "required": [
          "version",
          "type",
          "content"
        ]
      },
      "IJira.IGetCommentOutput": {
        "type": "object",
        "properties": {
          "comments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIJira.CommentidbodyupdatedcreatedauthorupdateAuthor"
            },
            "title": "comments"
          },
          "isLast": {
            "type": "boolean",
            "title": "Wheather is last page"
          },
          "total": {
            "type": "integer",
            "title": "total count"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          }
        },
        "required": [
          "comments",
          "total"
        ]
      },
      "MyPickIJira.CommentidbodyupdatedcreatedauthorupdateAuthor": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id of comment"
          },
          "body": {
            "type": "object",
            "properties": {
              "type": {
                "const": "doc"
              },
              "version": {
                "const": 1
              },
              "content": {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/IJira.BlockquoteNode"
                    },
                    {
                      "$ref": "#/components/schemas/ListNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.CodeBlockNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.HeadingNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.MediaSingleNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.PanelNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.ParagraphNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.TableNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.MediaGroupNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.RuleNode"
                    }
                  ]
                },
                "title": "A document in Jira is a combination of several blocks, so a single comment appears in the form of an array",
                "description": "A document in Jira is a combination of several blocks, so a single comment appears in the form of an array.\nBy combining each element in the array, you can understand the entire comment content."
              }
            },
            "required": [
              "type",
              "version",
              "content"
            ],
            "title": "body of comment"
          },
          "updated": {
            "type": "string",
            "title": "updated time of this comment"
          },
          "created": {
            "type": "string",
            "title": "created time of this comment"
          },
          "author": {
            "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName",
            "title": "author of this comment"
          },
          "updateAuthor": {
            "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName",
            "title": "who updates this comment"
          }
        },
        "required": [
          "id",
          "body",
          "updated",
          "created",
          "author",
          "updateAuthor"
        ]
      },
      "IJira.BlockquoteNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "blockquote",
            "title": "blockquote type"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ListNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.ParagraphContentWithoutNoMarks"
                }
              ]
            },
            "minItems": 1,
            "description": "content must contain array of one or more of the following nodes:\n- paragraph with no marks.\n- bulletList\n- orderedList"
          }
        },
        "required": [
          "type",
          "content"
        ],
        "title": "Blockquote node\n\nThe blockquote node is a container for quotes.\nblockquote is a top-level block node."
      },
      "ListNode": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "bulletList"
              },
              {
                "const": "orderedList"
              }
            ]
          },
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ListItemNode_1"
            }
          }
        },
        "required": [
          "type",
          "content"
        ]
      },
      "ListItemNode_1": {
        "type": "object",
        "properties": {
          "type": {
            "const": "listItem"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IJira.CodeBlockNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.MediaSingleNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.ParagraphContentWithoutNoMarks"
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "oneOf": [
                        {
                          "const": "bulletList"
                        },
                        {
                          "const": "orderedList"
                        }
                      ]
                    }
                  },
                  "required": [
                    "type"
                  ]
                }
              ]
            },
            "title": "content\ncontent must contain at least one of the following nodes:\n- bulletList\n- codeBlock with no marks\n- mediaSingle\n- orderedList\n- paragraph with no marks"
          }
        },
        "required": [
          "type",
          "content"
        ]
      },
      "IJira.CodeBlockNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "codeBlock"
          },
          "attrs": {
            "type": "object",
            "properties": {
              "language": {
                "type": "string",
                "x-wrtn-placeholder": "TypeScript",
                "title": "programming language name"
              }
            },
            "title": "attrs\n\nIf you do not specify a programming language, this property may not exist."
          },
          "content": {
            "type": "array",
            "prefixItems": [
              {
                "type": "object",
                "properties": {
                  "type": {
                    "const": "text"
                  },
                  "text": {
                    "type": "string",
                    "title": "text includeing code"
                  }
                },
                "required": [
                  "type",
                  "text"
                ]
              }
            ],
            "additionalItems": false,
            "title": "code content\n\ncontent takes an array of one or more text nodes without marks."
          }
        },
        "required": [
          "type"
        ],
        "title": "code block"
      },
      "IJira.MediaSingleNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "mediaSingle",
            "title": "mediaSingle type"
          },
          "attrs": {
            "type": "object",
            "properties": {
              "layout": {
                "oneOf": [
                  {
                    "const": "wrap-left"
                  },
                  {
                    "const": "center"
                  },
                  {
                    "const": "wrap-right"
                  },
                  {
                    "const": "wide"
                  },
                  {
                    "const": "full-width"
                  },
                  {
                    "const": "align-start"
                  },
                  {
                    "const": "align-end"
                  }
                ],
                "title": "layout determines the placement of the node on the page. wrap-left and wrap-right provide an image floated to the left or right of the page respectively, with text wrapped around it. center center aligns the image as a block, while wide does the same but bleeds into the margins. full-width makes the image stretch from edge to edge of the page",
                "description": "layout determines the placement of the node on the page. wrap-left and wrap-right provide an image floated to the left or right of the page respectively, with text wrapped around it. center center aligns the image as a block, while wide does the same but bleeds into the margins. full-width makes the image stretch from edge to edge of the page."
              },
              "width": {
                "type": "number",
                "minimum": 0,
                "maximum": 100,
                "title": "width determines the width of the image as a percentage of the width of the text content area. Has no effect if layout mode is wide or full-width",
                "description": "width determines the width of the image as a percentage of the width of the text content area. Has no effect if layout mode is wide or full-width."
              },
              "widthType": {
                "oneOf": [
                  {
                    "const": "pixel",
                    "default": "percentage"
                  },
                  {
                    "const": "percentage",
                    "default": "percentage"
                  }
                ],
                "title": "widthType [optional] determines what the \"unit\" of the width attribute is presenting. Possible values are pixel and percentage. If the widthType attribute is undefined, it fallbacks to percentage",
                "description": "widthType [optional] determines what the \"unit\" of the width attribute is presenting. Possible values are pixel and percentage. If the widthType attribute is undefined, it fallbacks to percentage."
              }
            },
            "required": [
              "layout"
            ]
          },
          "content": {
            "type": "array",
            "prefixItems": [
              {
                "oneOf": [
                  {
                    "type": "object",
                    "properties": {
                      "type": {
                        "const": "media"
                      },
                      "attrs": {
                        "type": "object",
                        "properties": {
                          "width": {
                            "type": "number",
                            "title": "width defines the display width of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed",
                            "description": "width defines the display width of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed."
                          },
                          "height": {
                            "type": "number",
                            "title": "height defines the display height of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed",
                            "description": "height defines the display height of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed."
                          },
                          "id": {
                            "type": "string",
                            "title": "id is the Media Services ID and is used for querying the media services API to retrieve metadata, such as, filename. Consumers of the document should always fetch fresh metadata using the Media API",
                            "description": "id is the Media Services ID and is used for querying the media services API to retrieve metadata, such as, filename. Consumers of the document should always fetch fresh metadata using the Media API."
                          },
                          "type": {
                            "oneOf": [
                              {
                                "const": "link"
                              },
                              {
                                "const": "file"
                              }
                            ],
                            "title": "type\nThere are three types.\nHowever, in our service, we have to use \"external\" type only, because we are only considering universal users who do not save images through Media API, but save images through external links."
                          }
                        },
                        "required": [
                          "type"
                        ],
                        "title": "Attributes"
                      },
                      "marks": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "const": "link"
                          },
                          "attrs": {
                            "type": "object",
                            "properties": {
                              "href": {
                                "type": "string",
                                "format": "iri",
                                "title": "link"
                              }
                            },
                            "required": [
                              "href"
                            ]
                          }
                        },
                        "required": [
                          "type",
                          "attrs"
                        ],
                        "title": "marks"
                      }
                    },
                    "required": [
                      "type",
                      "attrs",
                      "marks"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "type": {
                        "const": "media"
                      },
                      "attrs": {
                        "type": "object",
                        "properties": {
                          "width": {
                            "type": "number",
                            "title": "width defines the display width of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed",
                            "description": "width defines the display width of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed."
                          },
                          "height": {
                            "type": "number",
                            "title": "height defines the display height of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed",
                            "description": "height defines the display height of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed."
                          },
                          "id": {
                            "type": "string",
                            "title": "id is the Media Services ID and is used for querying the media services API to retrieve metadata, such as, filename. Consumers of the document should always fetch fresh metadata using the Media API",
                            "description": "id is the Media Services ID and is used for querying the media services API to retrieve metadata, such as, filename. Consumers of the document should always fetch fresh metadata using the Media API."
                          },
                          "type": {
                            "const": "external",
                            "title": "type\nThere are three types.\nHowever, in our service, we have to use \"external\" type only, because we are only considering universal users who do not save images through Media API, but save images through external links."
                          },
                          "url": {
                            "type": "string",
                            "format": "iri",
                            "title": "url"
                          }
                        },
                        "required": [
                          "type",
                          "url"
                        ],
                        "title": "Attributes"
                      }
                    },
                    "required": [
                      "type",
                      "attrs"
                    ]
                  }
                ]
              }
            ],
            "additionalItems": false,
            "title": "media\n\nonly single of media node type"
          }
        },
        "required": [
          "type",
          "attrs",
          "content"
        ],
        "description": "The mediaSingle node is a container for one media item.\nThis node enables the display of the content in full,\nin contrast to a mediaGroup that is intended for a list of attachments.\nA common use case is to display an image,\nbut it can also be used for videos,\nor other types of content usually renderable by a"
      },
      "IJira.ParagraphContentWithoutNoMarks": {
        "type": "object",
        "properties": {
          "type": {
            "const": "paragraph",
            "title": "paragraph type"
          },
          "attrs": {
            "$ref": "#/components/schemas/Recordstringnever"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IJira.EmojiNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.HardBreakNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.InlineCardNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.MentionNode"
                },
                {
                  "$ref": "#/components/schemas/StrictOmitIJira.TextContentmarks"
                }
              ],
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "emoji": "#/components/schemas/IJira.EmojiNode",
                  "hardBreak": "#/components/schemas/IJira.HardBreakNode",
                  "inlineCard": "#/components/schemas/IJira.InlineCardNode",
                  "mention": "#/components/schemas/IJira.MentionNode",
                  "text": "#/components/schemas/StrictOmitIJira.TextContentmarks"
                }
              }
            },
            "title": "content\n\nIf you want to make a new line, there will be an empty array."
          }
        },
        "required": [
          "type",
          "content"
        ],
        "title": "paragraph type"
      },
      "IJira.EmojiNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "emoji",
            "title": "emoji type"
          },
          "attrs": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "Emoji service ID of the emoji\n\nFor custom emojis by atlasian or user, you may have an ID."
              },
              "shortName": {
                "type": "string",
                "pattern": "^(:(.*):)$",
                "title": "icon name\n\nA string exists between a colon and a colon, meaning a name for representing the emoji."
              },
              "text": {
                "type": "string",
                "title": "emoji icon"
              }
            },
            "required": [
              "shortName"
            ],
            "title": "attributes of emoji node"
          }
        },
        "required": [
          "type",
          "attrs"
        ],
        "title": "emoji node"
      },
      "IJira.HardBreakNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "hardBreak",
            "title": "hardBreak type"
          },
          "attrs": {
            "type": "object",
            "properties": {
              "text": {
                "const": "\n",
                "title": "text\n\nIt can be only `\\n` text for braking."
              }
            },
            "title": "attributes of hard break node"
          }
        },
        "required": [
          "type"
        ],
        "title": "hard break node"
      },
      "IJira.InlineCardNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "inlineCard",
            "title": "inline card type"
          },
          "attrs": {
            "type": "object",
            "properties": {
              "url": {
                "type": "string",
                "format": "iri",
                "title": "url\nIndicates the address value that the inline card will represent.\nTo allow you to move when you click on the card, you need to put a link in advance."
              },
              "data": {
                "$ref": "#/components/schemas/object",
                "title": "representation of the link"
              }
            },
            "required": [
              "url"
            ],
            "title": "attributes of inline card node"
          }
        },
        "required": [
          "type",
          "attrs"
        ],
        "title": "inline card\n\nThe inlineCard node is an Atlassian link card with a type icon and content description derived from the link."
      },
      "object": {
        "type": "object",
        "properties": {}
      },
      "IJira.MentionNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "mention",
            "title": "mention type"
          },
          "attrs": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "title": "id\n\nadd any string like as uuid"
              },
              "text": {
                "type": "string",
                "pattern": "^(@(.*))",
                "title": "Who is mentioned\n\nIt means a string that connects @ and the user's name"
              },
              "accessLevel": {
                "type": "string",
                "title": "accessLevel"
              }
            },
            "required": [
              "text"
            ],
            "title": "content of this mention content"
          }
        },
        "required": [
          "type",
          "attrs"
        ],
        "title": "content with mention"
      },
      "StrictOmitIJira.TextContentmarks": {
        "type": "object",
        "properties": {
          "type": {
            "const": "text",
            "title": "text type"
          },
          "text": {
            "type": "string",
            "title": "content of this text content"
          }
        },
        "required": [
          "type",
          "text"
        ]
      },
      "IJira.HeadingNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "heading",
            "title": "heading type"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IJira.EmojiNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.HardBreakNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.InlineCardNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.MentionNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.TextContent"
                }
              ],
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "emoji": "#/components/schemas/IJira.EmojiNode",
                  "hardBreak": "#/components/schemas/IJira.HardBreakNode",
                  "inlineCard": "#/components/schemas/IJira.InlineCardNode",
                  "mention": "#/components/schemas/IJira.MentionNode",
                  "text": "#/components/schemas/IJira.TextContent"
                }
              }
            },
            "title": "content\n\nHeading node's content can be combined with only inline nodes."
          },
          "attrs": {
            "type": "object",
            "properties": {
              "level": {
                "oneOf": [
                  {
                    "const": 1
                  },
                  {
                    "const": 2
                  },
                  {
                    "const": 3
                  },
                  {
                    "const": 4
                  },
                  {
                    "const": 5
                  },
                  {
                    "const": 6
                  }
                ],
                "title": "level represents the depth of the heading following the same convention as HTML: when level is set to 1 it's the equivalent of <h1>",
                "description": "level represents the depth of the heading following the same convention as HTML: when level is set to 1 it's the equivalent of <h1>."
              }
            },
            "required": [
              "level"
            ],
            "title": "attributes of heading node"
          }
        },
        "required": [
          "type",
          "content",
          "attrs"
        ],
        "title": "heading node\n\nIt means h1, h2, h3, h4, h5, h6 node."
      },
      "IJira.TextContent": {
        "type": "object",
        "properties": {
          "type": {
            "const": "text",
            "title": "text type"
          },
          "text": {
            "type": "string",
            "title": "content of this text content"
          },
          "marks": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "backgroundColor"
                    },
                    "attrs": {
                      "type": "object",
                      "properties": {
                        "color": {
                          "type": "string",
                          "pattern": "^#([0-9A-Fa-f]{6})$",
                          "title": "color\n\nColor can be expressed using symbols('#') and RGB values."
                        }
                      },
                      "required": [
                        "color"
                      ]
                    }
                  },
                  "required": [
                    "type",
                    "attrs"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "code"
                    }
                  },
                  "required": [
                    "type"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "em"
                    }
                  },
                  "required": [
                    "type"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "strike"
                    }
                  },
                  "required": [
                    "type"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "strong"
                    }
                  },
                  "required": [
                    "type"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "underline"
                    }
                  },
                  "required": [
                    "type"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "link"
                    },
                    "attrs": {
                      "type": "object",
                      "properties": {
                        "href": {
                          "type": "string",
                          "format": "iri",
                          "title": "link"
                        }
                      },
                      "required": [
                        "href"
                      ]
                    }
                  },
                  "required": [
                    "type",
                    "attrs"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "subsup"
                    },
                    "attrs": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "oneOf": [
                            {
                              "const": "sub"
                            },
                            {
                              "const": "sup"
                            }
                          ]
                        }
                      },
                      "required": [
                        "type"
                      ]
                    }
                  },
                  "required": [
                    "type",
                    "attrs"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "textColor"
                    },
                    "attrs": {
                      "type": "object",
                      "properties": {
                        "color": {
                          "type": "string",
                          "pattern": "^#([0-9A-Fa-f]{6})$",
                          "title": "color\n\nColor can be expressed using symbols('#') and RGB values."
                        }
                      },
                      "required": [
                        "color"
                      ]
                    }
                  },
                  "required": [
                    "type",
                    "attrs"
                  ]
                }
              ]
            },
            "title": "marks\n\nIt means the emphasis of the markdown format, and it means that there is a string between the backticks."
          }
        },
        "required": [
          "type",
          "text"
        ],
        "title": "content with only text"
      },
      "IJira.PanelNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "panel"
          },
          "attrs": {
            "type": "object",
            "properties": {
              "panelType": {
                "oneOf": [
                  {
                    "const": "info"
                  },
                  {
                    "const": "error"
                  },
                  {
                    "const": "note"
                  },
                  {
                    "const": "warning"
                  },
                  {
                    "const": "success"
                  }
                ]
              }
            },
            "required": [
              "panelType"
            ]
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ListNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.ParagraphContentWithoutNoMarks"
                },
                {
                  "$ref": "#/components/schemas/IJira.HeadingNodeWithoutMarks"
                }
              ]
            }
          }
        },
        "required": [
          "type",
          "attrs",
          "content"
        ],
        "description": "The panel node is a container that highlights content."
      },
      "IJira.HeadingNodeWithoutMarks": {
        "type": "object",
        "properties": {
          "type": {
            "const": "heading",
            "title": "heading type"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IJira.EmojiNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.HardBreakNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.InlineCardNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.MentionNode"
                },
                {
                  "$ref": "#/components/schemas/StrictOmitIJira.TextContentmarks"
                }
              ],
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "emoji": "#/components/schemas/IJira.EmojiNode",
                  "hardBreak": "#/components/schemas/IJira.HardBreakNode",
                  "inlineCard": "#/components/schemas/IJira.InlineCardNode",
                  "mention": "#/components/schemas/IJira.MentionNode",
                  "text": "#/components/schemas/StrictOmitIJira.TextContentmarks"
                }
              }
            },
            "title": "content\n\nHeading node's content can be combined with only inline nodes.\nA property called marks is not available here."
          },
          "attrs": {
            "type": "object",
            "properties": {
              "level": {
                "oneOf": [
                  {
                    "const": 1,
                    "title": "1",
                    "description": "level"
                  },
                  {
                    "const": 2,
                    "title": "2",
                    "description": "level"
                  },
                  {
                    "const": 3,
                    "title": "3",
                    "description": "level"
                  },
                  {
                    "const": 4,
                    "title": "4",
                    "description": "level"
                  },
                  {
                    "const": 5,
                    "title": "5",
                    "description": "level"
                  },
                  {
                    "const": 6,
                    "title": "6",
                    "description": "level"
                  }
                ],
                "title": "level\n\nlevel represents the depth of the heading following the same convention as HTML: when level is set to 1 it's the equivalent of <h1>."
              }
            },
            "required": [
              "level"
            ],
            "title": "attributes of heading node"
          }
        },
        "required": [
          "type",
          "content",
          "attrs"
        ],
        "title": "heading node without `marks` property"
      },
      "IJira.ParagraphNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "paragraph",
            "title": "paragraph type"
          },
          "attrs": {
            "$ref": "#/components/schemas/Recordstringnever"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IJira.EmojiNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.HardBreakNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.InlineCardNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.MentionNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.TextContent"
                }
              ],
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "emoji": "#/components/schemas/IJira.EmojiNode",
                  "hardBreak": "#/components/schemas/IJira.HardBreakNode",
                  "inlineCard": "#/components/schemas/IJira.InlineCardNode",
                  "mention": "#/components/schemas/IJira.MentionNode",
                  "text": "#/components/schemas/IJira.TextContent"
                }
              }
            },
            "title": "content\n\nIf you want to make a new line, there will be an empty array."
          }
        },
        "required": [
          "type",
          "content"
        ],
        "title": "paragraph type\nThe paragraph node is a container for a block of formatted text delineated by a carriage return. It's the equivalent of the HTML <p> tag."
      },
      "IJira.TableNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "table"
          },
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IJira.TableRowNode"
            }
          },
          "attrs": {
            "type": "object",
            "properties": {
              "isNumberColumnEnabled": {
                "type": "boolean",
                "default": true,
                "title": "When isNumberColumnEnabled is set to 'true' the first table column provides numbering for the table rows",
                "description": "When isNumberColumnEnabled is set to 'true' the first table column provides numbering for the table rows."
              },
              "width": {
                "type": "number",
                "minimum": 0,
                "title": "width sets the length (in pixels) of the table on the page",
                "description": "width sets the length (in pixels) of the table on the page.\nThis value is independent of the table's column width, this allows control of the table's overflow.\nIt supersedes the existing layout attribute and will be used instead of it at runtime.\nIf width is not provided the editor will convert layout to pixels (default=760, wide=960 and full-width=1800).\nAlthough no minimum and maximum width is enforced it is recommended to follow these guidelines:\n\n- Minimum width\n\n- 1 column table = 48px\n- 2 column table = 96px\n- 3 column table = 144px\n- > 3 column table = 144px\n- Maximum width\n- 1800"
              },
              "layout": {
                "oneOf": [
                  {
                    "const": "center"
                  },
                  {
                    "const": "align-start"
                  }
                ],
                "title": "layout determines the alignment of a table in the full page editor, relevant to the line length. Currently only center and left alignment options are supported",
                "description": "layout determines the alignment of a table in the full page editor, relevant to the line length. Currently only center and left alignment options are supported.\nThe layout values are mapped as follows:\n- 'center' : will align the table to the center of page, its width can be larger than the line length\n- 'align-start' : will align the table left of the line length, its width cannot be larger than the line length"
              },
              "displayMode": {
                "oneOf": [
                  {
                    "const": "default"
                  },
                  {
                    "const": "fixed"
                  }
                ],
                "description": "displayMode attribute controls how tables adapt to narrow screens:\nWhen displayMode is set to 'default' or left unset, the table's columns will automatically scale down to accommodate narrow screens, with a maximum reduction of up to 40%.\nWhen displayMode is set to 'fixed', the table's columns will maintain their original width, regardless of screen size."
              }
            }
          }
        },
        "required": [
          "type",
          "content"
        ],
        "description": "The table node provides a container for the nodes that define a table.\n\nNote: only supported on web and desktop. Mobile rendering support for tables is not available."
      },
      "IJira.TableRowNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "tableRow"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IJira.TableHeaderNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.TableCellNode"
                }
              ],
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "tableHeader": "#/components/schemas/IJira.TableHeaderNode",
                  "tableCell": "#/components/schemas/IJira.TableCellNode"
                }
              }
            },
            "title": "content takes an array of one or more tableHeader or tableCell nodes",
            "description": "content takes an array of one or more tableHeader or tableCell nodes."
          }
        },
        "required": [
          "type",
          "content"
        ],
        "description": "The tableRow node defines rows within a table and is a container for table heading and table cell nodes.\ntableRow is a child block node of the table node."
      },
      "IJira.TableHeaderNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "tableHeader"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IJira.BlockquoteNode"
                },
                {
                  "$ref": "#/components/schemas/ListNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.CodeBlockNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.HeadingNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.PanelNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.ParagraphNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.MediaGroupNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.RuleNode"
                }
              ]
            }
          },
          "attrs": {
            "type": "object",
            "properties": {
              "background": {
                "type": "string",
                "description": "Short or long hex color code or HTML color name"
              },
              "colspan": {
                "type": "integer",
                "default": 1,
                "title": "colspan\ncolspan defines the number of columns the cell spans."
              },
              "colwidth": {
                "type": "array",
                "prefixItems": [
                  {
                    "type": "integer"
                  },
                  {
                    "type": "integer"
                  },
                  {
                    "type": "integer"
                  }
                ],
                "additionalItems": false,
                "description": "defines the width of the column or,\nwhere the cell spans columns, the width of the columns it spans in pixels.\nThe length of the array should be equal to the number of spanned columns.\n0 is permitted as an array value if the column size is not fixed,\nfor example, a cell merged across 3 columns where one unfixed column is surrounded by two fixed might be represented as `[120, 0, 120]."
              },
              "rowspan": {
                "type": "integer",
                "default": 1,
                "title": "rowspan\nrowspan defines the number of rows a cell spans."
              }
            }
          }
        },
        "required": [
          "type",
          "content"
        ]
      },
      "IJira.MediaGroupNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "mediaGroup"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "media"
                    },
                    "attrs": {
                      "type": "object",
                      "properties": {
                        "width": {
                          "type": "number",
                          "title": "width defines the display width of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed",
                          "description": "width defines the display width of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed."
                        },
                        "height": {
                          "type": "number",
                          "title": "height defines the display height of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed",
                          "description": "height defines the display height of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed."
                        },
                        "id": {
                          "type": "string",
                          "title": "id is the Media Services ID and is used for querying the media services API to retrieve metadata, such as, filename. Consumers of the document should always fetch fresh metadata using the Media API",
                          "description": "id is the Media Services ID and is used for querying the media services API to retrieve metadata, such as, filename. Consumers of the document should always fetch fresh metadata using the Media API."
                        },
                        "type": {
                          "oneOf": [
                            {
                              "const": "link"
                            },
                            {
                              "const": "file"
                            }
                          ],
                          "title": "type\nThere are three types.\nHowever, in our service, we have to use \"external\" type only, because we are only considering universal users who do not save images through Media API, but save images through external links."
                        }
                      },
                      "required": [
                        "type"
                      ],
                      "title": "Attributes"
                    },
                    "marks": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "const": "link"
                        },
                        "attrs": {
                          "type": "object",
                          "properties": {
                            "href": {
                              "type": "string",
                              "format": "iri",
                              "title": "link"
                            }
                          },
                          "required": [
                            "href"
                          ]
                        }
                      },
                      "required": [
                        "type",
                        "attrs"
                      ],
                      "title": "marks"
                    }
                  },
                  "required": [
                    "type",
                    "attrs",
                    "marks"
                  ]
                },
                {
                  "type": "object",
                  "properties": {
                    "type": {
                      "const": "media"
                    },
                    "attrs": {
                      "type": "object",
                      "properties": {
                        "width": {
                          "type": "number",
                          "title": "width defines the display width of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed",
                          "description": "width defines the display width of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed."
                        },
                        "height": {
                          "type": "number",
                          "title": "height defines the display height of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed",
                          "description": "height defines the display height of the media item in pixels. Must be provided within mediaSingle or the media isn't displayed."
                        },
                        "id": {
                          "type": "string",
                          "title": "id is the Media Services ID and is used for querying the media services API to retrieve metadata, such as, filename. Consumers of the document should always fetch fresh metadata using the Media API",
                          "description": "id is the Media Services ID and is used for querying the media services API to retrieve metadata, such as, filename. Consumers of the document should always fetch fresh metadata using the Media API."
                        },
                        "type": {
                          "const": "external",
                          "title": "type\nThere are three types.\nHowever, in our service, we have to use \"external\" type only, because we are only considering universal users who do not save images through Media API, but save images through external links."
                        },
                        "url": {
                          "type": "string",
                          "format": "iri",
                          "title": "url"
                        }
                      },
                      "required": [
                        "type",
                        "url"
                      ],
                      "title": "Attributes"
                    }
                  },
                  "required": [
                    "type",
                    "attrs"
                  ]
                }
              ]
            },
            "title": "content\ncontent must contain one or more media nodes."
          }
        },
        "required": [
          "type",
          "content"
        ]
      },
      "IJira.RuleNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "rule"
          }
        },
        "required": [
          "type"
        ],
        "description": "The rule node represents a divider, it is equivalent to the HTML <hr/> tag."
      },
      "IJira.TableCellNode": {
        "type": "object",
        "properties": {
          "type": {
            "const": "tableCell"
          },
          "content": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/IJira.BlockquoteNode"
                },
                {
                  "$ref": "#/components/schemas/ListNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.CodeBlockNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.HeadingNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.PanelNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.ParagraphNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.MediaGroupNode"
                },
                {
                  "$ref": "#/components/schemas/IJira.RuleNode"
                }
              ]
            }
          },
          "attrs": {
            "type": "object",
            "properties": {
              "background": {
                "type": "string",
                "description": "Short or long hex color code or HTML color name"
              },
              "colspan": {
                "type": "integer",
                "default": 1,
                "title": "colspan\ncolspan defines the number of columns the cell spans."
              },
              "colwidth": {
                "type": "array",
                "prefixItems": [
                  {
                    "type": "integer"
                  },
                  {
                    "type": "integer"
                  },
                  {
                    "type": "integer"
                  }
                ],
                "additionalItems": false,
                "description": "defines the width of the column or,\nwhere the cell spans columns, the width of the columns it spans in pixels.\nThe length of the array should be equal to the number of spanned columns.\n0 is permitted as an array value if the column size is not fixed,\nfor example, a cell merged across 3 columns where one unfixed column is surrounded by two fixed might be represented as `[120, 0, 120]."
              },
              "rowspan": {
                "type": "integer",
                "default": 1,
                "title": "rowspan\nrowspan defines the number of rows a cell spans."
              }
            }
          }
        },
        "required": [
          "type",
          "content"
        ]
      },
      "MyPickIJira.UseractiveaccountIddisplayName": {
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean",
            "title": "Whether is user active"
          },
          "accountId": {
            "type": "string",
            "title": "id of this user account"
          },
          "displayName": {
            "type": "string",
            "title": "creator's name"
          }
        },
        "required": [
          "active",
          "accountId",
          "displayName"
        ]
      },
      "StrictOmitIGetCommentInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key\n\nThis connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "secretKey"
        ]
      },
      "IJira.IGetTransitionOutput": {
        "type": "object",
        "properties": {
          "transitions": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "title": "id of transition"
                },
                "to": {
                  "$ref": "#/components/schemas/MyPickIJira.StatusdescriptionnameidstatusCategory",
                  "title": "to\n\nStatusDetail.\nDetails of the issue status after the transition."
                }
              },
              "required": [
                "id",
                "to"
              ]
            },
            "title": "transition list of this jira issue"
          }
        },
        "required": [
          "transitions"
        ]
      },
      "MyPickIJira.StatusdescriptionnameidstatusCategory": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "title": "status description"
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "해야 할 일",
            "title": "status name"
          },
          "id": {
            "type": "string",
            "title": "status id"
          },
          "statusCategory": {
            "type": "object",
            "properties": {
              "id": {
                "type": "number",
                "title": "category id"
              },
              "key": {
                "type": "string",
                "x-wrtn-placeholder": "new",
                "title": "category key"
              }
            },
            "required": [
              "id",
              "key"
            ],
            "title": "status category"
          }
        },
        "required": [
          "description",
          "name",
          "id",
          "statusCategory"
        ]
      },
      "StrictOmitIGetTransitionInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key\n\nThis connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "secretKey"
        ]
      },
      "StrictOmitIUnAssignInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "issueId": {
            "type": "string",
            "title": "ID of issue"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueId",
          "secretKey"
        ]
      },
      "StrictOmitIAssignInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "asigneeId": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/issues/get-users-assignable",
                  "jmesPath": "[].{value:accountId, label:displayName}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/project/get-users-assignable",
                  "jmesPath": "[].{value:accountId, label:displayName}"
                }
              }
            ],
            "title": "accountId of the user you want to designate as the person in charge\n\nIf you want to designate a person in charge, you need that user's ID. Therefore, you need to look up the user first. There are connectors that look up who can be assigned to a project or issue. You can find the ID of the person in charge by choosing what you want.\nThe person in charge is inevitably one of Jira's users."
          },
          "issueId": {
            "type": "string",
            "title": "ID of issue"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "asigneeId",
          "issueId",
          "secretKey"
        ]
      },
      "StrictOmitIUpdateStatusInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key\n\nThis connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "transitionId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/issue-get-transitions",
              "jmesPath": "transitions[].{value:id, label: to.name}"
            },
            "title": "ID of transition"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "transitionId",
          "secretKey"
        ]
      },
      "StrictOmitIUpdateIssueInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "fields": {
            "$ref": "#/components/schemas/MyPartial__type",
            "title": "fields to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "fields",
          "secretKey"
        ]
      },
      "MyPartial__type": {
        "type": "object",
        "properties": {
          "assignee": {
            "type": "object",
            "properties": {
              "id": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/issues/get-users-assignable",
                      "jmesPath": "[].{value:accountId, label:displayName}"
                    }
                  },
                  {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/project/get-users-assignable",
                      "jmesPath": "[].{value:accountId, label:displayName}"
                    }
                  }
                ],
                "title": "accountId of the user you want to designate as the person in charge\n\nIf you want to designate a person in charge, you need that user's ID. Therefore, you need to look up the user first. There are connectors that look up who can be assigned to a project or issue. You can find the ID of the person in charge by choosing what you want.\nThe person in charge is inevitably one of Jira's users."
              }
            },
            "required": [
              "id"
            ],
            "title": "Specify a representative at the same time as you create"
          },
          "description": {
            "type": "object",
            "properties": {
              "type": {
                "const": "doc",
                "title": "type of description\n\nAllow doc type only Now"
              },
              "version": {
                "const": 1,
                "title": "version"
              },
              "content": {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/IJira.BlockquoteNode"
                    },
                    {
                      "$ref": "#/components/schemas/ListNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.CodeBlockNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.HeadingNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.MediaSingleNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.PanelNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.ParagraphNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.TableNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.MediaGroupNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.RuleNode"
                    }
                  ]
                },
                "title": "contents of description\n\nYou must use node types that are configured with TopLevelBlockNodes.\n\nIt is recommended to contain as much detail as possible on the issue raised by the user,\nso that the next person who reads this issue can see the summary and description of this issue to resolve the issue."
              }
            },
            "required": [
              "type",
              "version",
              "content"
            ],
            "title": "description\n\nThe content of the Jira issue consists of a combination of various contents."
          },
          "duedate": {
            "type": "string",
            "format": "date",
            "title": "due date\n\ndate format type.\nIndicates the schedule you want to be closed.Of course, it will be good to create a date or today."
          },
          "issuetype": {
            "type": "object",
            "properties": {
              "id": {
                "0": {
                  "type": "string",
                  "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                  "x-wrtn-prerequisite": {
                    "method": "post",
                    "path": "/connector/jira/get-issue-types",
                    "jmesPath": "issuetypes[].{value:id, label:name}"
                  }
                },
                "title": "id of issue type\n\nThe ID of the issue.\nSometimes the user can say the name of the issue type,\nsuch as 'bug' or 'story', but you cannot specify the issue type with the name of the issue type.\nBecause there can be types with the same name.\nTherefore, you must check the issue type with a different connector to verify that it is an issue type that can be used in the project.\n\nHowever, if you handed over the number string type from the beginning, it could be the ID of the issue type."
              }
            },
            "required": [
              "id"
            ],
            "title": "issuetype"
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels\nYou can add labels to make it easier to read issues.\nLabels are simply strings, which can be added immediately without having to look up using other connectors."
          },
          "parent": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                },
                "title": "key of parent issue\n\nSometimes an issue can be a sub-issue of another issue.\nIn this case, you need to specify the key for the parent issue.\nIf you want to know the key, use an issue list query or another connector to look up the details of the issue."
              }
            },
            "required": [
              "key"
            ],
            "title": "parent of this issue"
          },
          "priority": {
            "type": "object",
            "properties": {
              "id": {
                "0": {
                  "type": "string",
                  "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                  "x-wrtn-prerequisite": {
                    "method": "post",
                    "path": "/connector/jira/get-issue-priorities",
                    "jmesPath": "[].{value:id, label:name}"
                  }
                },
                "title": "id of proirity\n\nYou can prioritize issues.\nUsers can also prioritize issues in natural languages such as Low, Medium, High, and so on,\nbut when creating issues, ID values for these priorities are required.\nTherefore, you should first call a connector that looks up what priorities are available for the project and issue."
              }
            },
            "required": [
              "id"
            ],
            "title": "priority"
          },
          "project": {
            "oneOf": [
              {
                "type": "object",
                "properties": {
                  "id": {
                    "0": {
                      "type": "string",
                      "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                      "x-wrtn-prerequisite": {
                        "method": "post",
                        "path": "/connector/jira/get-projects",
                        "jmesPath": "[].{value:id, label:name}"
                      }
                    },
                    "title": "id of project"
                  }
                },
                "required": [
                  "id"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/get-project",
                      "jmesPath": "[].{value:key, label:name}"
                    },
                    "title": "key of project"
                  }
                },
                "required": [
                  "key"
                ]
              }
            ],
            "title": "project\n\nIssues must inevitably belong to the project.\nAt this point, the project can be specified by receiving an ID or key.\nIf you do not know the key or ID of the project, you should first look up the project."
          },
          "summary": {
            "type": "string",
            "title": "summary\n\nMeaning the title of the issue.\nMake sure you write a sentence that best represents this issue."
          }
        }
      },
      "IJira.ICreateIssueOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "ID of the issue that was created just now"
          },
          "key": {
            "type": "string",
            "title": "Key of the issue that was created just now"
          }
        },
        "required": [
          "id",
          "key"
        ],
        "title": "output of creation of issue"
      },
      "IJira.ICreateIssueByMarkdownInput": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "properties": {
              "assignee": {
                "type": "object",
                "properties": {
                  "id": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "x-wrtn-prerequisite": {
                          "method": "post",
                          "path": "/connector/jira/issues/get-users-assignable",
                          "jmesPath": "[].{value:accountId, label:displayName}"
                        }
                      },
                      {
                        "type": "string",
                        "x-wrtn-prerequisite": {
                          "method": "post",
                          "path": "/connector/jira/project/get-users-assignable",
                          "jmesPath": "[].{value:accountId, label:displayName}"
                        }
                      }
                    ],
                    "title": "accountId of the user you want to designate as the person in charge\n\nIf you want to designate a person in charge, you need that user's ID. Therefore, you need to look up the user first. There are connectors that look up who can be assigned to a project or issue. You can find the ID of the person in charge by choosing what you want.\nThe person in charge is inevitably one of Jira's users."
                  }
                },
                "required": [
                  "id"
                ],
                "title": "Specify a representative at the same time as you create"
              },
              "description": {
                "type": "object",
                "properties": {
                  "type": {
                    "const": "doc",
                    "title": "type of description\n\nAllow doc type only Now"
                  },
                  "version": {
                    "const": 1,
                    "title": "version"
                  },
                  "content": {
                    "type": "string",
                    "title": "contents of description\n\nYou must use markdown format string.\n\nIt is recommended to contain as much detail as possible on the issue raised by the user,\nso that the next person who reads this issue can see the summary and description of this issue to resolve the issue."
                  }
                },
                "required": [
                  "type",
                  "version",
                  "content"
                ],
                "title": "description\n\nThe content of the Jira issue consists of a combination of various contents."
              },
              "duedate": {
                "type": "string",
                "format": "date",
                "title": "due date\n\ndate format type.\nIndicates the schedule you want to be closed.Of course, it will be good to create a date or today."
              },
              "issuetype": {
                "type": "object",
                "properties": {
                  "id": {
                    "0": {
                      "type": "string",
                      "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                      "x-wrtn-prerequisite": {
                        "method": "post",
                        "path": "/connector/jira/get-issue-types",
                        "jmesPath": "issuetypes[].{value:id, label:name}"
                      }
                    },
                    "title": "id of issue type\n\nThe ID of the issue.\nSometimes the user can say the name of the issue type,\nsuch as 'bug' or 'story', but you cannot specify the issue type with the name of the issue type.\nBecause there can be types with the same name.\nTherefore, you must check the issue type with a different connector to verify that it is an issue type that can be used in the project.\n\nHowever, if you handed over the number string type from the beginning, it could be the ID of the issue type."
                  }
                },
                "required": [
                  "id"
                ],
                "title": "issuetype"
              },
              "labels": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "labels\nYou can add labels to make it easier to read issues.\nLabels are simply strings, which can be added immediately without having to look up using other connectors."
              },
              "parent": {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-prerequisite": {
                      "method": "post",
                      "path": "/connector/jira/get-issues",
                      "jmesPath": "issues[].{value:key, label:key}"
                    },
                    "title": "key of parent issue\n\nSometimes an issue can be a sub-issue of another issue.\nIn this case, you need to specify the key for the parent issue.\nIf you want to know the key, use an issue list query or another connector to look up the details of the issue."
                  }
                },
                "required": [
                  "key"
                ],
                "title": "parent of this issue"
              },
              "priority": {
                "type": "object",
                "properties": {
                  "id": {
                    "0": {
                      "type": "string",
                      "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                      "x-wrtn-prerequisite": {
                        "method": "post",
                        "path": "/connector/jira/get-issue-priorities",
                        "jmesPath": "[].{value:id, label:name}"
                      }
                    },
                    "title": "id of proirity\n\nYou can prioritize issues.\nUsers can also prioritize issues in natural languages such as Low, Medium, High, and so on,\nbut when creating issues, ID values for these priorities are required.\nTherefore, you should first call a connector that looks up what priorities are available for the project and issue."
                  }
                },
                "required": [
                  "id"
                ],
                "title": "priority"
              },
              "project": {
                "oneOf": [
                  {
                    "type": "object",
                    "properties": {
                      "id": {
                        "0": {
                          "type": "string",
                          "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
                          "x-wrtn-prerequisite": {
                            "method": "post",
                            "path": "/connector/jira/get-projects",
                            "jmesPath": "[].{value:id, label:name}"
                          }
                        },
                        "title": "id of project"
                      }
                    },
                    "required": [
                      "id"
                    ]
                  },
                  {
                    "type": "object",
                    "properties": {
                      "key": {
                        "type": "string",
                        "x-wrtn-prerequisite": {
                          "method": "post",
                          "path": "/connector/jira/get-project",
                          "jmesPath": "[].{value:key, label:name}"
                        },
                        "title": "key of project"
                      }
                    },
                    "required": [
                      "key"
                    ]
                  }
                ],
                "title": "project\n\nIssues must inevitably belong to the project.\nAt this point, the project can be specified by receiving an ID or key.\nIf you do not know the key or ID of the project, you should first look up the project."
              },
              "summary": {
                "type": "string",
                "title": "summary\n\nMeaning the title of the issue.\nMake sure you write a sentence that best represents this issue."
              }
            },
            "required": [
              "issuetype",
              "project",
              "summary"
            ],
            "title": "fields\n\nIndicates the fields that you need to fill in when you want to create an issue."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "fields",
          "secretKey"
        ]
      },
      "IJira.IGetIssueDetailOutput": {
        "type": "object",
        "properties": {
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels attached to the issue"
          },
          "fields": {
            "$ref": "#/components/schemas/IJira.DetailedIssueField",
            "title": "Details of the issue"
          },
          "id": {
            "type": "string",
            "title": "The ID of the issue"
          },
          "key": {
            "type": "string",
            "title": "The key of the issue"
          }
        },
        "required": [
          "fields",
          "id",
          "key"
        ]
      },
      "IJira.DetailedIssueField": {
        "type": "object",
        "properties": {
          "comment": {
            "type": "object",
            "properties": {
              "maxResults": {
                "type": "number",
                "title": "Number of comments viewed at one time"
              },
              "total": {
                "type": "number",
                "title": "Total count of comments"
              },
              "startAt": {
                "type": "number",
                "title": "page offset",
                "description": "The index of the first item to return in a page of results (page offset)."
              },
              "comments": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IJira.Comment"
                },
                "title": "list of comments"
              }
            },
            "required": [
              "maxResults",
              "total",
              "startAt",
              "comments"
            ],
            "title": "comment infomation"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "content": {
                    "type": "array",
                    "items": {
                      "oneOf": [
                        {
                          "$ref": "#/components/schemas/IJira.BlockquoteNode"
                        },
                        {
                          "$ref": "#/components/schemas/ListNode"
                        },
                        {
                          "$ref": "#/components/schemas/IJira.CodeBlockNode"
                        },
                        {
                          "$ref": "#/components/schemas/IJira.HeadingNode"
                        },
                        {
                          "$ref": "#/components/schemas/IJira.MediaSingleNode"
                        },
                        {
                          "$ref": "#/components/schemas/IJira.PanelNode"
                        },
                        {
                          "$ref": "#/components/schemas/IJira.ParagraphNode"
                        },
                        {
                          "$ref": "#/components/schemas/IJira.TableNode"
                        },
                        {
                          "$ref": "#/components/schemas/IJira.MediaGroupNode"
                        },
                        {
                          "$ref": "#/components/schemas/IJira.RuleNode"
                        }
                      ]
                    }
                  }
                },
                "required": [
                  "content"
                ]
              }
            ]
          },
          "statuscategorychangedate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "statuscategorychangedate\n\nThe date and time when the status category of the issue was last changed.\n\nThis property indicates the most recent timestamp when the issue transitioned\nbetween status categories (e.g., from \"To Do\" to \"In Progress\" or from\n\"In Progress\" to \"Done\"). Status categories in Jira typically include:\n- \"To Do\": The issue is pending and not yet started.\n- \"In Progress\": The issue is currently being worked on.\n- \"Done\": The issue has been completed."
          },
          "reporter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "reporter"
          },
          "creator": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "creator"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "assignee"
          },
          "summary": {
            "type": "string",
            "title": "summary"
          },
          "issuetype": {
            "$ref": "#/components/schemas/MyPickIJira.IssueTypenameid",
            "title": "issue type"
          },
          "status": {
            "$ref": "#/components/schemas/MyPickIJira.StatusdescriptionnameidstatusCategoryuntranslatedName",
            "title": "status"
          },
          "priority": {
            "$ref": "#/components/schemas/MyPickIJira.Prioritynameid",
            "title": "priority"
          },
          "parent": {
            "$ref": "#/components/schemas/IJira.Parent",
            "title": "parent of this issue"
          }
        },
        "required": [
          "comment",
          "description",
          "status",
          "priority"
        ]
      },
      "IJira.Comment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "id of comment"
          },
          "author": {
            "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName",
            "title": "author of this comment"
          },
          "updateAuthor": {
            "$ref": "#/components/schemas/MyPickIJira.UseractiveaccountIddisplayName",
            "title": "who updates this comment"
          },
          "body": {
            "type": "object",
            "properties": {
              "type": {
                "const": "doc"
              },
              "version": {
                "const": 1
              },
              "content": {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/IJira.BlockquoteNode"
                    },
                    {
                      "$ref": "#/components/schemas/ListNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.CodeBlockNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.HeadingNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.MediaSingleNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.PanelNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.ParagraphNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.TableNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.MediaGroupNode"
                    },
                    {
                      "$ref": "#/components/schemas/IJira.RuleNode"
                    }
                  ]
                },
                "title": "A document in Jira is a combination of several blocks, so a single comment appears in the form of an array",
                "description": "A document in Jira is a combination of several blocks, so a single comment appears in the form of an array.\nBy combining each element in the array, you can understand the entire comment content."
              }
            },
            "required": [
              "type",
              "version",
              "content"
            ],
            "title": "body of comment"
          },
          "created": {
            "type": "string",
            "title": "created time of this comment"
          },
          "updated": {
            "type": "string",
            "title": "updated time of this comment"
          }
        },
        "required": [
          "id",
          "author",
          "updateAuthor",
          "body",
          "created",
          "updated"
        ]
      },
      "IJira.User": {
        "type": "object",
        "properties": {
          "accountId": {
            "type": "string",
            "title": "id of this user account"
          },
          "displayName": {
            "type": "string",
            "title": "creator's name"
          },
          "active": {
            "type": "boolean",
            "title": "Whether is user active"
          }
        },
        "required": [
          "accountId",
          "displayName",
          "active"
        ]
      },
      "MyPickIJira.IssueTypenameid": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "스토리",
            "title": "issue type name\n\nIt may be name, bug, story or etc."
          },
          "id": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$"
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "MyPickIJira.StatusdescriptionnameidstatusCategoryuntranslatedName": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "title": "status description"
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "해야 할 일",
            "title": "status name"
          },
          "id": {
            "type": "string",
            "title": "status id"
          },
          "statusCategory": {
            "type": "object",
            "properties": {
              "id": {
                "type": "number",
                "title": "category id"
              },
              "key": {
                "type": "string",
                "x-wrtn-placeholder": "new",
                "title": "category key"
              }
            },
            "required": [
              "id",
              "key"
            ],
            "title": "status category"
          },
          "untranslatedName": {
            "type": "string",
            "title": "untranslated name"
          }
        },
        "required": [
          "description",
          "name",
          "id",
          "statusCategory"
        ]
      },
      "MyPickIJira.Prioritynameid": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "priority name\n\nIt may be Low, Medium, High."
          },
          "id": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "id"
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "IJira.Parent": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "The ID of the parent issue"
          },
          "key": {
            "type": "string",
            "title": "The key of the parent issue"
          },
          "fields": {
            "type": "object",
            "properties": {
              "summary": {
                "type": "string",
                "title": "summary"
              }
            }
          }
        },
        "required": [
          "id",
          "key",
          "fields"
        ]
      },
      "StrictOmitIGetIssueDetailInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "issueIdOrKey": {
            "oneOf": [
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:id, label:key}"
                }
              },
              {
                "type": "string",
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/jira/get-issues",
                  "jmesPath": "issues[].{value:key, label:key}"
                }
              }
            ],
            "title": "issue id or key\n\nThis connector doesn't matter the key or ID of the issue.\nIf you hand over one of them, you can use it to look up."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issueIdOrKey",
          "secretKey"
        ]
      },
      "IJira.IGetIssueOutput": {
        "type": "object",
        "properties": {
          "issues": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIJira.Issuekeyidfields"
            },
            "title": "Jira issue list"
          },
          "isLast": {
            "type": "boolean",
            "title": "Wheather is last page"
          },
          "total": {
            "type": "integer",
            "title": "total count"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          }
        },
        "required": [
          "issues",
          "total"
        ]
      },
      "MyPickIJira.Issuekeyidfields": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "title": "The key of the issue"
          },
          "id": {
            "type": "string",
            "title": "The ID of the issue"
          },
          "fields": {
            "$ref": "#/components/schemas/IJira.IssueField",
            "title": "fields"
          }
        },
        "required": [
          "key",
          "id",
          "fields"
        ]
      },
      "IJira.IssueField": {
        "type": "object",
        "properties": {
          "statuscategorychangedate": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "statuscategorychangedate\n\nThe date and time when the status category of the issue was last changed.\n\nThis property indicates the most recent timestamp when the issue transitioned\nbetween status categories (e.g., from \"To Do\" to \"In Progress\" or from\n\"In Progress\" to \"Done\"). Status categories in Jira typically include:\n- \"To Do\": The issue is pending and not yet started.\n- \"In Progress\": The issue is currently being worked on.\n- \"Done\": The issue has been completed."
          },
          "reporter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "reporter"
          },
          "creator": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "creator"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IJira.User"
              }
            ],
            "title": "assignee"
          },
          "summary": {
            "type": "string",
            "title": "summary"
          },
          "issuetype": {
            "$ref": "#/components/schemas/MyPickIJira.IssueTypenameid",
            "title": "issue type"
          },
          "status": {
            "$ref": "#/components/schemas/MyPickIJira.StatusdescriptionnameidstatusCategoryuntranslatedName",
            "title": "status"
          },
          "priority": {
            "$ref": "#/components/schemas/MyPickIJira.Prioritynameid",
            "title": "priority"
          },
          "parent": {
            "$ref": "#/components/schemas/IJira.Parent",
            "title": "parent of this issue"
          }
        },
        "required": [
          "status",
          "priority"
        ]
      },
      "StrictOmitIGetIssueInputByBasicAuthemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "title": "search keyword\n\nIt is a keyword you want to find in the title or explanation of an issue, which is useful when searching."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "status": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-statuses",
              "jmesPath": "[].{value:id, label:untranslatedName}"
            },
            "title": "status"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "project_key": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-projects",
              "jmesPath": "values[].{value:key, label:name}"
            },
            "title": "key of project"
          },
          "issuetype": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-issue-types",
              "jmesPath": "[].{label:untranslatedName, value:untranslatedName}"
            },
            "title": "issue type"
          },
          "assignee": {
            "type": "string",
            "title": "name of assignee"
          },
          "reporter": {
            "type": "string",
            "title": "name of reporter"
          },
          "created_start_date": {
            "type": "string",
            "format": "date",
            "title": "Search for issues created after this date"
          },
          "created_end_date": {
            "type": "string",
            "format": "date",
            "title": "Search for issues created after this date"
          },
          "priority": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-issue-priorities",
              "jmesPath": "[].{value:name, label:name}"
            },
            "title": "priority name\n\nIf you want to search based on priority, deliver the name of the priority.\nThere are five priorities: 'Highest', 'High', 'Medium', 'Low', and 'Lowest'.\nAlthough it is a Deprecated feature, you can still query the priority level that can be assigned to an issue with the API.\nIt also exists as our connector, so use it if necessary."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "label titles\n\nComplex searches are possible using various labels."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "project_key",
          "secretKey"
        ]
      },
      "IJira.IGetProjectOutput": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IJira.Project"
            },
            "title": "Jira project list"
          },
          "isLast": {
            "type": "boolean",
            "title": "Wheather is last page"
          },
          "total": {
            "type": "integer",
            "title": "total count"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          }
        },
        "required": [
          "values",
          "total"
        ],
        "title": "output of getting Jira projects"
      },
      "IJira.Project": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$",
            "title": "id"
          },
          "key": {
            "type": "string",
            "title": "key of project\n\nKey properties used to query the inside of a project."
          },
          "name": {
            "type": "string",
            "title": "name of this project"
          },
          "projectCategory": {
            "type": "object",
            "properties": {
              "description": {
                "type": "string",
                "title": "description"
              },
              "id": {
                "type": "string",
                "title": "id"
              },
              "name": {
                "type": "string",
                "title": "name"
              }
            },
            "required": [
              "description",
              "id",
              "name"
            ],
            "title": "project category info"
          }
        },
        "required": [
          "id",
          "key",
          "name"
        ]
      },
      "StrictOmitIGetProjectInputByBasicAuthemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "orderBy": {
            "oneOf": [
              {
                "const": "issueCount",
                "title": "issueCount",
                "description": "Sorts by the total number of issues in each project."
              },
              {
                "const": "lastIssueUpdatedTime",
                "title": "lastIssueUpdatedTime",
                "description": "Sorts by the last issue update time."
              },
              {
                "const": "name",
                "title": "name",
                "description": "Sorts by project name."
              }
            ],
            "title": "order by",
            "description": "Order the results by a field.\n\n- issueCount : Sorts by the total number of issues in each project.\n- lastIssueUpdatedTime : Sorts by the last issue update time.\n- name : Sorts by project name."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IJira.IGetIssueLabelOutput": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "label list"
          },
          "isLast": {
            "type": "boolean",
            "title": "Wheather is last page"
          },
          "total": {
            "type": "integer",
            "title": "total count"
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          }
        },
        "required": [
          "values",
          "total"
        ]
      },
      "StrictOmitIGetIssueLabelInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IJira.IGetIssueTypeOutput": {
        "type": "object",
        "properties": {
          "issuetypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IJira.IssueType"
            },
            "title": "issue types in this projects"
          }
        },
        "required": [
          "issuetypes"
        ]
      },
      "IJira.IssueType": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "pattern": "^([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)$"
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "스토리",
            "title": "issue type name\n\nIt may be name, bug, story or etc."
          },
          "description": {
            "type": "string",
            "title": "description"
          },
          "subtask": {
            "type": "boolean",
            "title": "whether is for substask issue type"
          }
        },
        "required": [
          "id",
          "name",
          "description",
          "subtask"
        ]
      },
      "StrictOmitIGetIssueTypeInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "projectId": {
            "0": {
              "type": "string",
              "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connectors/jira/get-projects",
                "jmesPath": "values[].{value:id,label:name}"
              }
            },
            "title": "id of project"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "projectId",
          "secretKey"
        ]
      },
      "IJira.IGetIssueStatusOutput": {
        "type": "object",
        "properties": {
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickStatusnameiduntranslatedNameprojectIdstringundefined"
            }
          }
        },
        "required": [
          "statuses"
        ]
      },
      "MyPickStatusnameiduntranslatedNameprojectIdstringundefined": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "해야 할 일",
            "title": "status name"
          },
          "id": {
            "type": "string",
            "title": "status id"
          },
          "untranslatedName": {
            "type": "string",
            "title": "untranslated name"
          },
          "projectId": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "StrictOmitIGetIssueStatusInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "projectId": {
            "0": {
              "type": "string",
              "pattern": "([+-]?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connectors/jira/get-projects",
                "jmesPath": "values[].{value:id,label:name}"
              }
            },
            "title": "id of project\n\nIf the status does not have the project ID,\nit means this status is beyond the scope of the project and can be selected by the entire team.\nIt can also be the default status created from the beginning by Jira."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "StrictOmitBasicAuthorizationemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "StrictOmitIGetIssueAssignableInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "project": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-projects",
              "jmesPath": "values[].{value:key, label:name}"
            },
            "title": "key of project\n\nIt refers to the key of the project to search for the user to be assigned."
          },
          "issueKey": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connectors/jira/get-issues",
              "jmesPath": "issues[].{value:key, label:key}"
            },
            "title": "key of issue\n\nIt refers to the key of the issue to search for the user to be assigned."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "project",
          "issueKey",
          "secretKey"
        ]
      },
      "StrictOmitIGetProjectAssignableInputemaildomaintokenIBasicSecret": {
        "type": "object",
        "properties": {
          "maxResults": {
            "type": "integer",
            "default": 50,
            "title": "max results",
            "description": "The maximum number of items to return per page.\nIn the issue, it seems that up to 100 can be viewed at a time."
          },
          "startAt": {
            "type": "integer",
            "default": 0,
            "title": "page offset",
            "description": "The index of the first item to return in a page of results (page offset)."
          },
          "project_key": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/jira/get-projects",
              "jmesPath": "values[].{value:key, label:name}"
            },
            "title": "key of project\n\nIt refers to the key of the project to search for the user to be assigned."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "atlassian",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "project_key",
          "secretKey"
        ]
      },
      "IJira.StatusCategory": {
        "type": "object",
        "properties": {
          "colorName": {
            "type": "string",
            "title": "name of color"
          },
          "id": {
            "type": "number",
            "title": "The ID of status category"
          },
          "key": {
            "type": "string",
            "title": "The key of status category"
          },
          "name": {
            "type": "string",
            "title": "name of the status category"
          }
        },
        "required": [
          "colorName",
          "id",
          "key",
          "name"
        ]
      },
      "IGoogleTrend.IResponse": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "title": "날짜",
            "description": "트렌드 조회 날짜입니다."
          },
          "query": {
            "type": "string",
            "title": "검색어",
            "description": "데일리 트렌드로 조회된 검색어입니다."
          },
          "related_queries": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "연관 검색어",
            "description": "데일리 트렌드로 조회된 검색어와 연관된 검색어 목록입니다."
          },
          "traffic": {
            "type": "string",
            "title": "트래픽 수",
            "description": "해당 키워드가 검색된 트래픽 수입니다."
          }
        },
        "required": [
          "date",
          "query",
          "related_queries",
          "traffic"
        ],
        "title": "구글 데일리 트렌드 조회 결과",
        "description": "데일리 트렌드 조회 결과입니다."
      },
      "IGoogleTrend.IRequest": {
        "type": "object",
        "properties": {
          "date": {
            "type": "string",
            "format": "date",
            "title": "날짜",
            "description": "데일리 트렌드를 조회할 날짜 입니다.\n\n입력되지 않으면 오늘 날짜를 기준으로 조회합니다.\nyear-month-day 형식의 date 타입 문자열을 제공해주어야 한다."
          }
        },
        "title": "구글 데일리 트렌드 조회를 위한 정보",
        "description": "입력한 날짜의 트렌드를 조회합니다.\n\n입력하지 않으면 오늘 날짜를 기준으로 조회합니다.\n\n날짜 형식은 \"20241231\" 형식입니다."
      },
      "IGoogleMap.IResponse": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string",
            "title": "Name",
            "description": "It's the name of a restaurant."
          },
          "place_id": {
            "type": "string",
            "title": "unique ID",
            "description": "This is the unique ID of the restaurant.\n\nThis is the information needed to search for reviews."
          },
          "gps_coordinate": {
            "type": "object",
            "properties": {
              "latitude": {
                "type": "number",
                "title": "Latitude",
                "description": "This is the latitude of the restaurant's coordinates."
              },
              "longitude": {
                "type": "number",
                "title": "Longitude",
                "description": "This is the coordinates of the restaurant."
              }
            },
            "required": [
              "latitude",
              "longitude"
            ],
            "title": "Coordinates",
            "description": "Here are the coordinates for the restaurant."
          },
          "rating": {
            "type": "number",
            "title": "ratings",
            "description": "Here are the restaurant ratings."
          },
          "reviews": {
            "type": "number",
            "title": "Number of reviews",
            "description": "This is the number of restaurant reviews."
          },
          "address": {
            "type": "string",
            "title": "Address",
            "description": "Here is the address of the restaurant."
          },
          "open_state": {
            "type": "string",
            "title": "Operation Information",
            "description": "Information about whether the restaurant is currently operating."
          },
          "operating_hours": {
            "type": "object",
            "properties": {},
            "title": "Information on operating hours",
            "description": "Here is the information on the restaurant's operating hours.",
            "additionalProperties": {
              "type": "string"
            }
          },
          "phone_number": {
            "type": "string",
            "title": "Phone number",
            "description": "This is the phone number for the restaurant."
          },
          "service_options": {
            "type": "object",
            "properties": {},
            "title": "Service options",
            "description": "Service options provided by the restaurant.",
            "additionalProperties": {
              "type": "boolean"
            }
          },
          "user_review": {
            "type": "string",
            "title": "User Review",
            "description": "This is a user review of a delicious restaurant."
          },
          "thumbnail": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri",
                "contentMediaType": "image/*"
              }
            ],
            "title": "image",
            "description": "This is a thumbnail image of a delicious restaurant."
          }
        },
        "required": [
          "title",
          "place_id",
          "gps_coordinate",
          "address"
        ],
        "title": "Google Maps Restaurant Search Results"
      },
      "IGoogleMap.IRequest": {
        "type": "object",
        "properties": {
          "keyword": {
            "type": "string",
            "minLength": 1,
            "x-wrtn-placeholder": "강남역 맛집",
            "title": "Search term",
            "description": "Please enter your search term"
          }
        },
        "required": [
          "keyword"
        ],
        "title": "Information for searching restaurants on Google Maps"
      },
      "IGoogleMap.IReviewResponse": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "Author's name",
            "description": "Reviewer's name."
          },
          "rating": {
            "type": "number",
            "title": "Review ratings",
            "description": "Here are the review ratings."
          },
          "description": {
            "type": "string",
            "title": "Review content",
            "description": "Here is the review content."
          },
          "link": {
            "type": "string",
            "format": "iri",
            "title": "Review Link",
            "description": "Here is the review link."
          },
          "images": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iri",
              "contentMediaType": "image/*"
            },
            "title": "Review Image",
            "description": "This is the image registered in the review."
          },
          "date": {
            "type": "string",
            "title": "Review Date",
            "description": "The date the review was written."
          }
        },
        "required": [
          "username",
          "rating",
          "description",
          "link",
          "images",
          "date"
        ],
        "title": "Review search results"
      },
      "IGoogleMap.IReviewRequest": {
        "type": "object",
        "properties": {
          "place_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/google-map/search",
              "jmesPath": "[].{value:place_id, label:place_id}"
            }
          }
        },
        "required": [
          "place_id"
        ]
      },
      "IGithub.IGetEventOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "title": "id"
                },
                "type": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "const": "CommitCommentEvent",
                      "title": "CommitCommentEvent",
                      "description": "Triggered when a comment is added to a commit."
                    },
                    {
                      "const": "CreateEvent",
                      "title": "CreateEvent",
                      "description": "Triggered when a new branch, tag, or repository is created."
                    },
                    {
                      "const": "DeleteEvent",
                      "title": "DeleteEvent",
                      "description": "Triggered when a branch or tag is deleted."
                    },
                    {
                      "const": "ForkEvent",
                      "title": "ForkEvent",
                      "description": "Triggered when a user forks a repository."
                    },
                    {
                      "const": "GollumEvent",
                      "title": "GollumEvent",
                      "description": "Triggered when a Wiki page is created or updated."
                    },
                    {
                      "const": "IssueCommentEvent",
                      "title": "IssueCommentEvent",
                      "description": "Triggered when a comment is added to an issue."
                    },
                    {
                      "const": "IssuesEvent",
                      "title": "IssuesEvent",
                      "description": "Triggered when an issue is opened, edited, or closed."
                    },
                    {
                      "const": "MemberEvent",
                      "title": "MemberEvent",
                      "description": "Triggered when a user is added as a collaborator to a repository."
                    },
                    {
                      "const": "PublicEvent",
                      "title": "PublicEvent",
                      "description": "Triggered when a private repository is made public."
                    },
                    {
                      "const": "PullRequestEvent",
                      "title": "PullRequestEvent",
                      "description": "Triggered when a pull request is opened, edited, merged, or closed."
                    },
                    {
                      "const": "PullRequestReviewEvent",
                      "title": "PullRequestReviewEvent",
                      "description": "Triggered when a review is submitted for a pull request."
                    },
                    {
                      "const": "PullRequestReviewCommentEvent",
                      "title": "PullRequestReviewCommentEvent",
                      "description": "Triggered when a comment is added to a pull request's review."
                    },
                    {
                      "const": "PullRequestReviewThreadEvent",
                      "title": "PullRequestReviewThreadEvent",
                      "description": "Triggered when a review thread in a pull request has a change."
                    },
                    {
                      "const": "PushEvent",
                      "title": "PushEvent",
                      "description": "Triggered when commits are pushed to a repository."
                    },
                    {
                      "const": "ReleaseEvent",
                      "title": "ReleaseEvent",
                      "description": "Triggered when a release is published."
                    },
                    {
                      "const": "SponsorshipEvent",
                      "title": "SponsorshipEvent",
                      "description": "Triggered when a sponsorship is started or modified."
                    },
                    {
                      "const": "WatchEvent",
                      "title": "WatchEvent",
                      "description": "Triggered when a user stars a repository."
                    }
                  ],
                  "title": "event type\nThere are various events such as `WatchEvent`, `CreateEvent`, `ForkEvent`."
                },
                "actor": {
                  "$ref": "#/components/schemas/MyPickIGithub.Useridlogin",
                  "title": "user"
                },
                "repo": {
                  "$ref": "#/components/schemas/MyPickIGithub.Repositorynameid",
                  "title": "repo"
                },
                "org": {
                  "$ref": "#/components/schemas/MyPickIGithub.Organizationidlogindisplay_login",
                  "title": "org"
                },
                "payload": {
                  "$ref": "#/components/schemas/IGithub.Payload",
                  "title": "payload"
                },
                "public": {
                  "type": "boolean",
                  "title": "whather is public"
                },
                "created_at": {
                  "oneOf": [
                    {
                      "type": "null"
                    },
                    {
                      "type": "string",
                      "format": "date-time"
                    }
                  ],
                  "title": "created_at"
                }
              },
              "required": [
                "id",
                "type",
                "actor",
                "repo",
                "payload",
                "public",
                "created_at"
              ]
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "MyPickIGithub.Useridlogin": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          }
        },
        "required": [
          "id",
          "login"
        ]
      },
      "MyPickIGithub.Repositorynameid": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name"
          },
          "id": {
            "type": "number",
            "title": "id"
          }
        },
        "required": [
          "name",
          "id"
        ]
      },
      "MyPickIGithub.Organizationidlogindisplay_login": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "login": {
            "type": "string",
            "title": "login"
          },
          "display_login": {
            "type": "string",
            "title": "display_login"
          }
        },
        "required": [
          "id",
          "login"
        ]
      },
      "IGithub.Payload": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "title": "action\n\nIt means what this event means.\nAlthough the type of event usually has a resource or the name of the event,\nit is necessary to view it with this property because it does not specify what actions occurred in that event are modified, deleted, created, etc."
          },
          "issue": {
            "$ref": "#/components/schemas/IGithub.Issue",
            "title": "issue\n\nIf it is an event for an issue, contain the issue information."
          },
          "comment": {
            "$ref": "#/components/schemas/IGithub.Comment",
            "title": "comment\n\nIf it is an event for an comment, contain the comment information."
          }
        }
      },
      "IGithub.Issue": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to see the issue or pull_request on the web, you can go to this link.\nIf pull is included on this link path, it is pull_request, and if issue is included, it is issue.\nIn essence, pull_request and issue are numbered together from the beginning, so while this connector does not distinguish the two, it can be distinguished by the url path."
          },
          "number": {
            "type": "integer",
            "title": "issue number\n\nNumber uniquely identifying the issue within its repository"
          },
          "state": {
            "type": "string",
            "title": "state\n\nState of the issue; either 'open' or 'closed'"
          },
          "state_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "completed"
              },
              {
                "const": "reopened"
              },
              {
                "const": "not_planned"
              }
            ],
            "description": "The reason for the current state"
          },
          "title": {
            "type": "string",
            "description": "Title of the issue"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin",
            "title": "user"
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "body\n\nContents of the issue\n\nYou can also render this content because it is in a markdown format."
          },
          "labels": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "integer"
                    },
                    "url": {
                      "type": "string",
                      "format": "iri"
                    },
                    "name": {
                      "type": "string"
                    },
                    "description": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    },
                    "color": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    },
                    "default": {
                      "type": "boolean"
                    }
                  }
                }
              ]
            },
            "title": "labels\n\nLabels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
              }
            ],
            "title": "assignee"
          },
          "assignees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            ],
            "title": "assignees\n\nIf there are many people in charge, you can be included in the array."
          }
        },
        "required": [
          "id",
          "html_url",
          "number",
          "state",
          "title",
          "user",
          "labels",
          "assignee"
        ]
      },
      "MyPickIGithub.Usertypeidlogin": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          }
        },
        "required": [
          "type",
          "id",
          "login"
        ]
      },
      "MyPickIGithub.Userlogin": {
        "type": "object",
        "properties": {
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          }
        },
        "required": [
          "login"
        ]
      },
      "IGithub.Comment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "title": "id"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Usertypeidloginhtml_urlavatar_url",
            "title": "user"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "pages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Page"
            },
            "title": "pages"
          }
        },
        "required": [
          "id",
          "user",
          "created_at",
          "updated_at"
        ]
      },
      "MyPickIGithub.Usertypeidloginhtml_urlavatar_url": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to look up your profile, you can access this website."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "type",
          "id",
          "login",
          "html_url",
          "avatar_url"
        ]
      },
      "IGithub.Page": {
        "type": "object",
        "properties": {
          "page_name": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "summary": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "action": {
            "type": "string"
          },
          "sha": {
            "type": "string"
          },
          "html_url": {
            "type": "string"
          }
        }
      },
      "IGithub.IGetReceivedEventInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetUserPinnedRepositoryInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "username": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-users",
              "jmesPath": "items[].{value:login, label:login}"
            },
            "title": "username\n\nThis refers to the nickname of the user who will look up the repository."
          }
        },
        "required": [
          "secretKey",
          "username"
        ]
      },
      "IGithub.IGetUserRepositoryOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.RepositoryWithReadmeFile"
            },
            "title": "repositories"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.RepositoryWithReadmeFile": {
        "type": "object",
        "properties": {
          "readme": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.RepositoryFile"
              }
            ],
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "file": "#/components/schemas/IGithub.RepositoryFile"
              }
            },
            "title": "readme"
          },
          "id": {
            "type": "number",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "full_name": {
            "type": "string",
            "title": "full_name\n\nThis is in the form '{username}/{reponame}'."
          },
          "private": {
            "type": "boolean",
            "title": "private"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          },
          "fork": {
            "type": "boolean",
            "title": "fork"
          },
          "forks_count": {
            "type": "integer",
            "title": "forks_count"
          },
          "stargazers_count": {
            "type": "integer",
            "title": "stargazers_count"
          },
          "watchers_count": {
            "type": "integer",
            "title": "watchers_count"
          },
          "size": {
            "type": "number",
            "title": "size"
          },
          "default_branch": {
            "type": "string",
            "title": "default_branch"
          },
          "open_issues_count": {
            "type": "integer",
            "title": "open_issues_count"
          },
          "is_template": {
            "type": "boolean",
            "title": "is_template"
          },
          "topics": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "topics"
          },
          "has_issues": {
            "type": "boolean",
            "title": "has_issues"
          },
          "has_projects": {
            "type": "boolean",
            "title": "has_projects"
          },
          "has_wiki": {
            "type": "boolean",
            "title": "has_wiki"
          },
          "has_pages": {
            "type": "boolean",
            "title": "has_pages"
          },
          "has_downloads": {
            "type": "boolean",
            "title": "has_downloads"
          },
          "archived": {
            "type": "boolean",
            "title": "archived"
          },
          "disabled": {
            "type": "boolean",
            "title": "disabled"
          },
          "visibility": {
            "oneOf": [
              {
                "const": "public"
              },
              {
                "const": "private"
              }
            ],
            "title": "visibility"
          },
          "pushed_at": {
            "type": "string",
            "format": "date-time",
            "title": "pushed_at"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "permissions": {
            "type": "object",
            "properties": {
              "admin": {
                "type": "boolean",
                "title": "admin"
              },
              "push": {
                "type": "boolean",
                "title": "push"
              },
              "pull": {
                "type": "boolean",
                "title": "pull"
              }
            },
            "required": [
              "admin",
              "push",
              "pull"
            ]
          },
          "allow_rebase_merge": {
            "type": "boolean",
            "title": "allow_rebase_merge"
          },
          "allow_squash_merge": {
            "type": "boolean",
            "title": "allow_squash_merge"
          },
          "allow_auto_merge": {
            "type": "boolean",
            "title": "allow_auto_merge"
          },
          "delete_branch_on_merge": {
            "type": "boolean",
            "title": "delete_branch_on_merge"
          },
          "allow_merge_commit": {
            "type": "boolean",
            "title": "allow_merge_commit"
          },
          "subscribers_count": {
            "type": "integer",
            "title": "subscribers_count"
          },
          "network_count": {
            "type": "integer",
            "title": "network_count"
          },
          "license": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-placeholder": "mit",
                    "title": "key"
                  },
                  "name": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT License",
                    "title": "name"
                  },
                  "url": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "x-wrtn-placeholder": "https://api.github.com/licenses/mit"
                      }
                    ],
                    "title": "url"
                  },
                  "spdx_id": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT",
                    "title": "spdx_id"
                  }
                },
                "required": [
                  "key",
                  "name",
                  "url",
                  "spdx_id"
                ]
              }
            ]
          },
          "forks": {
            "type": "integer",
            "title": "forks"
          },
          "open_issues": {
            "type": "integer",
            "title": "open_issues"
          },
          "watchers": {
            "type": "integer",
            "title": "watchers"
          }
        },
        "required": [
          "readme",
          "id",
          "name",
          "full_name",
          "private",
          "html_url",
          "description",
          "fork",
          "forks_count",
          "stargazers_count",
          "watchers_count",
          "size",
          "default_branch",
          "open_issues_count",
          "is_template",
          "topics",
          "has_issues",
          "has_projects",
          "has_wiki",
          "has_pages",
          "has_downloads",
          "archived",
          "disabled",
          "visibility",
          "pushed_at",
          "created_at",
          "updated_at",
          "license",
          "forks",
          "open_issues",
          "watchers"
        ]
      },
      "IGithub.RepositoryFile": {
        "type": "object",
        "properties": {
          "type": {
            "const": "file"
          },
          "encoding": {
            "type": "string",
            "x-wrtn-placeholder": "base64"
          },
          "size": {
            "type": "number",
            "title": "Indicates the file size in bytes."
          },
          "name": {
            "type": "string",
            "title": "name of this file"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          },
          "content": {
            "type": "string",
            "title": "content"
          },
          "sha": {
            "type": "string",
            "title": "sha"
          },
          "url": {
            "type": "string",
            "title": "url\n\nA link that allows you to view the contents of the file as an Url value for viewing the details of the file."
          },
          "download_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "download_url\n\nThe url that allows you to download a file, which is useful if it is a media file containing an image."
          }
        },
        "required": [
          "type",
          "encoding",
          "size",
          "name",
          "path",
          "content",
          "sha",
          "url"
        ]
      },
      "IGithub.IGetUserRepositoryInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-users",
              "jmesPath": "items[].{value:login, label:login}"
            },
            "title": "username\n\nThis refers to the nickname of the user who will look up the repository."
          },
          "per_page": {
            "type": "integer",
            "default": 10,
            "maximum": 10,
            "title": "per_page\nThe number of results per page (max 10).\n\nThe response capacity may be very large because it even comes out with the reedy of the repository.\nTherefore, it is recommended to check by cutting up to 10 pieces."
          },
          "sort": {
            "oneOf": [
              {
                "const": "updated",
                "default": "full_name"
              },
              {
                "const": "created",
                "default": "full_name"
              },
              {
                "const": "pushed",
                "default": "full_name"
              },
              {
                "const": "full_name",
                "default": "full_name"
              }
            ],
            "title": "sorting condition\n\nThe property to sort the results by.\nIt must be one of: \"created\" | \"updated\" | \"pushed\" | \"full_name\""
          },
          "direction": {
            "oneOf": [
              {
                "const": "asc",
                "default": "desc"
              },
              {
                "const": "desc",
                "default": "desc"
              }
            ],
            "title": "direction\nThe order to sort by.\nDefault: asc when using full_name, otherwise desc."
          },
          "since": {
            "type": "string",
            "format": "date-time",
            "title": "since\nOnly show repositories updated after the given time. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ."
          },
          "before": {
            "type": "string",
            "format": "date-time",
            "title": "before\nOnly show repositories updated before the given time. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetOrganizationEventInput": {
        "type": "object",
        "properties": {
          "organization": {
            "type": "string",
            "title": "organization's name\n\nYou can also change it to your nickname."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "organization",
          "secretKey"
        ]
      },
      "IGithub.IGetOrganizationAuthenticationUserIssueOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Issue"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.IGetOrganizationAuthenticationUserIssueInput": {
        "type": "object",
        "properties": {
          "organization": {
            "type": "string",
            "title": "organization\nThe organization name. The name is not case sensitive."
          },
          "direction": {
            "oneOf": [
              {
                "const": "asc",
                "default": "desc"
              },
              {
                "const": "desc",
                "default": "desc"
              }
            ],
            "title": "direction\nThe order to sort by.\nDefault: asc when using full_name, otherwise desc."
          },
          "filter": {
            "oneOf": [
              {
                "const": "assigned",
                "title": "assigned",
                "description": "Indicates which sorts of issues to return.",
                "default": "assigned"
              },
              {
                "const": "created",
                "title": "created",
                "description": "assigned means issues assigned to you.",
                "default": "assigned"
              },
              {
                "const": "mentioned",
                "title": "mentioned",
                "description": "created means issues created by you.",
                "default": "assigned"
              },
              {
                "const": "subscribed",
                "title": "subscribed",
                "description": "mentioned means issues mentioning you.",
                "default": "assigned"
              },
              {
                "const": "repos",
                "title": "repos",
                "description": "subscribed means issues you're subscribed to updates for.",
                "default": "assigned"
              },
              {
                "const": "all",
                "title": "all",
                "description": "all or repos means all issues you can see, regardless of participation or creation.",
                "default": "assigned"
              }
            ],
            "title": "filter\n\nIt must be one of: \"assigned\", \"created\", \"mentioned\", \"subscribed\", \"repos\", \"all\"\n\nIndicates which sorts of issues to return.\nassigned means issues assigned to you.\ncreated means issues created by you.\nmentioned means issues mentioning you.\nsubscribed means issues you're subscribed to updates for.\nall or repos means all issues you can see, regardless of participation or creation."
          },
          "state": {
            "oneOf": [
              {
                "const": "open",
                "title": "open",
                "default": "open"
              },
              {
                "const": "closed",
                "title": "closed",
                "default": "open"
              },
              {
                "const": "all",
                "title": "all",
                "default": "open"
              }
            ],
            "title": "state\n\nIndicates the state of the issues to return.\nIt must be one of: 'open', 'closed', 'all'"
          },
          "labels": {
            "type": "string",
            "title": "label\n\nA list of comma separated label names. Example: `bug,ui,@high`"
          },
          "sort": {
            "oneOf": [
              {
                "const": "created",
                "title": "created",
                "default": "created"
              },
              {
                "const": "updated",
                "title": "updated",
                "default": "created"
              },
              {
                "const": "comments",
                "title": "comments",
                "default": "created"
              }
            ],
            "title": "sort\nIt must be 'created', 'updated', 'comments'"
          },
          "owned": {
            "type": "boolean",
            "title": "owned"
          },
          "pulls": {
            "type": "boolean",
            "title": "pulls"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user",
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "organization",
          "secretKey"
        ]
      },
      "IGithub.IGetOrganizationRepositoryOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Repository"
            },
            "title": "repositories"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Repository": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "full_name": {
            "type": "string",
            "title": "full_name\n\nThis is in the form '{username}/{reponame}'."
          },
          "private": {
            "type": "boolean",
            "title": "private"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          },
          "fork": {
            "type": "boolean",
            "title": "fork"
          },
          "forks_count": {
            "type": "integer",
            "title": "forks_count"
          },
          "stargazers_count": {
            "type": "integer",
            "title": "stargazers_count"
          },
          "watchers_count": {
            "type": "integer",
            "title": "watchers_count"
          },
          "size": {
            "type": "number",
            "title": "size"
          },
          "default_branch": {
            "type": "string",
            "title": "default_branch"
          },
          "open_issues_count": {
            "type": "integer",
            "title": "open_issues_count"
          },
          "is_template": {
            "type": "boolean",
            "title": "is_template"
          },
          "topics": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "topics"
          },
          "has_issues": {
            "type": "boolean",
            "title": "has_issues"
          },
          "has_projects": {
            "type": "boolean",
            "title": "has_projects"
          },
          "has_wiki": {
            "type": "boolean",
            "title": "has_wiki"
          },
          "has_pages": {
            "type": "boolean",
            "title": "has_pages"
          },
          "has_downloads": {
            "type": "boolean",
            "title": "has_downloads"
          },
          "archived": {
            "type": "boolean",
            "title": "archived"
          },
          "disabled": {
            "type": "boolean",
            "title": "disabled"
          },
          "visibility": {
            "oneOf": [
              {
                "const": "public"
              },
              {
                "const": "private"
              }
            ],
            "title": "visibility"
          },
          "pushed_at": {
            "type": "string",
            "format": "date-time",
            "title": "pushed_at"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "permissions": {
            "type": "object",
            "properties": {
              "admin": {
                "type": "boolean",
                "title": "admin"
              },
              "push": {
                "type": "boolean",
                "title": "push"
              },
              "pull": {
                "type": "boolean",
                "title": "pull"
              }
            },
            "required": [
              "admin",
              "push",
              "pull"
            ]
          },
          "allow_rebase_merge": {
            "type": "boolean",
            "title": "allow_rebase_merge"
          },
          "allow_squash_merge": {
            "type": "boolean",
            "title": "allow_squash_merge"
          },
          "allow_auto_merge": {
            "type": "boolean",
            "title": "allow_auto_merge"
          },
          "delete_branch_on_merge": {
            "type": "boolean",
            "title": "delete_branch_on_merge"
          },
          "allow_merge_commit": {
            "type": "boolean",
            "title": "allow_merge_commit"
          },
          "subscribers_count": {
            "type": "integer",
            "title": "subscribers_count"
          },
          "network_count": {
            "type": "integer",
            "title": "network_count"
          },
          "license": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-placeholder": "mit",
                    "title": "key"
                  },
                  "name": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT License",
                    "title": "name"
                  },
                  "url": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "x-wrtn-placeholder": "https://api.github.com/licenses/mit"
                      }
                    ],
                    "title": "url"
                  },
                  "spdx_id": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT",
                    "title": "spdx_id"
                  }
                },
                "required": [
                  "key",
                  "name",
                  "url",
                  "spdx_id"
                ]
              }
            ]
          },
          "forks": {
            "type": "integer",
            "title": "forks"
          },
          "open_issues": {
            "type": "integer",
            "title": "open_issues"
          },
          "watchers": {
            "type": "integer",
            "title": "watchers"
          }
        },
        "required": [
          "id",
          "name",
          "full_name",
          "private",
          "html_url",
          "description",
          "fork",
          "forks_count",
          "stargazers_count",
          "watchers_count",
          "size",
          "default_branch",
          "open_issues_count",
          "is_template",
          "topics",
          "has_issues",
          "has_projects",
          "has_wiki",
          "has_pages",
          "has_downloads",
          "archived",
          "disabled",
          "visibility",
          "pushed_at",
          "created_at",
          "updated_at",
          "license",
          "forks",
          "open_issues",
          "watchers"
        ]
      },
      "IGithub.IGetCollaboratorOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Collaborator"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Collaborator": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to look up your profile, you can access this website."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "type",
          "id",
          "login",
          "html_url",
          "avatar_url"
        ]
      },
      "IGithub.IGetCollaboratorInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "affiliation": {
            "oneOf": [
              {
                "const": "outside",
                "title": "outside",
                "default": "all"
              },
              {
                "const": "direct",
                "title": "direct",
                "default": "all"
              },
              {
                "const": "all",
                "title": "all",
                "default": "all"
              }
            ],
            "title": "affiliation\n\nFilter collaborators returned by their affiliation.\noutside means all outside collaborators of an organization-owned repository. direct means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. all means all collaborators the authenticated user can see.\nIt must be one of: \"outside\", \"direct\", \"all\"."
          },
          "permission": {
            "oneOf": [
              {
                "const": "pull",
                "title": "pull"
              },
              {
                "const": "triage",
                "title": "triage"
              },
              {
                "const": "push",
                "title": "push"
              },
              {
                "const": "maintain",
                "title": "maintain"
              },
              {
                "const": "admin",
                "title": "admin"
              }
            ],
            "title": "permission\n\nFilter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.\nIt must be one of: \"pull\", \"triage\", \"push\", \"maintain\", \"admin\"."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "admin:org",
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IDeleteFileContentInput": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "title": "commit message\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message."
          },
          "path": {
            "type": "string",
            "title": "path parameters\n\nIt refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The author of the file.\n\nIf you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: The committer or the authenticated user if you omit committer."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "sha": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repos/get-contents",
              "jmesPath": "[].{value:sha, label:path} || {value:sha, label:path}"
            },
            "title": "sha of file content\n\nAs the sha value of the file to be modified, a conflict may occur if it is not the latest sha value among the sha values of the file.\nIt's safe when you look up a list of files through API to check sha and put in a value, or want to re-modify the sha value of a file you just created."
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The person that committed the file.\nIf you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: the authenticated user."
          },
          "branch": {
            "type": "string",
            "title": "branch name\n\nThe branch name. Default: the repository’s default branch"
          }
        },
        "required": [
          "message",
          "path",
          "secretKey",
          "owner",
          "repo",
          "sha"
        ]
      },
      "IGithub.IUpsertFileContentOutput": {
        "type": "object",
        "properties": {
          "content": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "file or folder name"
              },
              "path": {
                "type": "string",
                "title": "file or folder path"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "size": {
                "type": "number",
                "title": "size"
              }
            },
            "required": [
              "name",
              "path",
              "sha",
              "size"
            ],
            "title": "content"
          },
          "commit": {
            "type": "object",
            "properties": {
              "sha": {
                "type": "string",
                "title": "sha"
              }
            },
            "required": [
              "sha"
            ],
            "title": "commit"
          }
        },
        "required": [
          "content",
          "commit"
        ]
      },
      "IGithub.IUpdateFileContentInput": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repos/get-contents",
              "jmesPath": "[].{value:sha, label:path} || {value:sha, label:path}"
            },
            "title": "sha of file content\n\nAs the sha value of the file to be modified, a conflict may occur if it is not the latest sha value among the sha values of the file.\nIt's safe when you look up a list of files through API to check sha and put in a value, or want to re-modify the sha value of a file you just created."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "path": {
            "type": "string",
            "title": "path parameters\n\nIt refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "message": {
            "type": "string",
            "title": "commit message\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message."
          },
          "content": {
            "type": "string",
            "title": "the new file content\n\nMeaning of the file is text and text.\nIf you want to create code content, you should write code content.\nSince it encodes with base64 internally, we need to deliver text here before encoding."
          },
          "branch": {
            "type": "string",
            "title": "branch name\n\nThe branch name. Default: the repository’s default branch"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The person that committed the file.\nIf you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: the authenticated user."
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The author of the file.\n\nIf you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: The committer or the authenticated user if you omit committer."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "sha",
          "owner",
          "repo",
          "path",
          "message",
          "content",
          "secretKey"
        ]
      },
      "IGithub.ICreateFileContentInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "path": {
            "type": "string",
            "title": "path parameters\n\nIt refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "message": {
            "type": "string",
            "title": "commit message\nMany repositories are working on commit conventions. Before committing, it's a good idea to look up the commit-list to see how you leave the commit message."
          },
          "content": {
            "type": "string",
            "title": "the new file content\n\nMeaning of the file is text and text.\nIf you want to create code content, you should write code content.\nSince it encodes with base64 internally, we need to deliver text here before encoding."
          },
          "branch": {
            "type": "string",
            "title": "branch name\n\nThe branch name. Default: the repository’s default branch"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The person that committed the file.\nIf you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: the authenticated user."
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "The name of the author or committer of the commit"
              },
              "email": {
                "type": "string",
                "title": "The email of the author or committer of the commit"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "The author of the file.\n\nIf you don't put anything in, your own information will be injected, so you can leave the value alone.\nSince the user's email cannot necessarily be guaranteed to be the same as Github's email, it is advantageous not to get confirmation from the user or put it in.\n\nDefault: The committer or the authenticated user if you omit committer."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "path",
          "message",
          "content",
          "secretKey"
        ]
      },
      "RepositoryFolderchildrenany": {
        "type": "object",
        "properties": {
          "type": {
            "const": "dir",
            "title": "type"
          },
          "size": {
            "const": 0,
            "title": "Indicates the file size in bytes."
          },
          "name": {
            "type": "string",
            "title": "name of this folder"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          },
          "sha": {
            "type": "string",
            "title": "sha"
          },
          "children": {
            "type": "array",
            "items": {},
            "title": "children\n\nFor folders, you may have other files or folders inside.\nThis should also be a folder or file type object,\nbut here, we specify it as any type to prevent it because it can be recursively infinitely large."
          }
        },
        "required": [
          "type",
          "size",
          "name",
          "path",
          "sha",
          "children"
        ]
      },
      "StrictOmitIGithub.RepositoryFilecontentencoding": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name of this file"
          },
          "url": {
            "type": "string",
            "title": "url\n\nA link that allows you to view the contents of the file as an Url value for viewing the details of the file."
          },
          "type": {
            "const": "file"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          },
          "size": {
            "type": "number",
            "title": "Indicates the file size in bytes."
          },
          "sha": {
            "type": "string",
            "title": "sha"
          },
          "download_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "download_url\n\nThe url that allows you to download a file, which is useful if it is a media file containing an image."
          }
        },
        "required": [
          "name",
          "url",
          "type",
          "path",
          "size",
          "sha"
        ]
      },
      "IGithub.IGetRepositoryFolderStructureInput": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "default": "",
            "title": "folder name\n\nThe path delivered is treated like a Root folder and continues the navigation from this folder.\nBrowse by this folder, and it must be a folder, not a file.\nIf omitted, start the circuit based on the top Root folder."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author.\n\nIf it is an organization's repository, it can also be the name of the organization."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          }
        },
        "required": [
          "secretKey",
          "owner",
          "repo"
        ]
      },
      "IGithub.RepositoryFolder": {
        "type": "object",
        "properties": {
          "type": {
            "const": "dir",
            "title": "type"
          },
          "size": {
            "const": 0,
            "title": "Indicates the file size in bytes."
          },
          "name": {
            "type": "string",
            "title": "name of this folder"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          },
          "sha": {
            "type": "string",
            "title": "sha"
          }
        },
        "required": [
          "type",
          "size",
          "name",
          "path",
          "sha"
        ]
      },
      "IGithub.IGetBulkFileContentInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "paths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "path parameters\n\nIt refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "branch": {
            "type": "string",
            "title": "branch name"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetFileContentInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author.\n\nIf it is an organization's repository, it can also be the name of the organization."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "path": {
            "type": "string",
            "title": "path parameters\n\nIt refers to the path of the file, and is the path of the file including folders and extensions.\nIf you want to make index.ts in src, you need to add 'src/index.ts'."
          },
          "branch": {
            "type": "string",
            "title": "branch name"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetReadmeFileContentInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author.\n\nIf it is an organization's repository, it can also be the name of the organization."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          }
        },
        "required": [
          "secretKey",
          "owner",
          "repo"
        ]
      },
      "IGithub.IGetRepoEventInput": {
        "type": "object",
        "properties": {
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "repo",
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetUserEventInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetUserOrganizationOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Organization"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Organization": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "login": {
            "type": "string",
            "title": "login"
          },
          "display_login": {
            "type": "string",
            "title": "display_login"
          },
          "description": {
            "type": "string",
            "title": "description"
          }
        },
        "required": [
          "id",
          "login"
        ]
      },
      "IGithub.IGetUserOrganizationInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetEventInput": {
        "type": "object",
        "properties": {
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IGithub.IGetRepositoryActivityOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Activity"
            },
            "title": "result of repository activities"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Activity": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "ref": {
            "type": "string",
            "x-wrtn-placeholder": "refs/heads/main",
            "title": "ref"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "timestamp"
          },
          "activity_type": {
            "oneOf": [
              {
                "const": "push",
                "title": "push"
              },
              {
                "const": "force_push",
                "title": "force_push"
              },
              {
                "const": "branch_creation",
                "title": "branch_creation"
              },
              {
                "const": "branch_deletion",
                "title": "branch_deletion"
              },
              {
                "const": "pr_merge",
                "title": "pr_merge"
              },
              {
                "const": "merge_queue_merge",
                "title": "merge_queue_merge"
              }
            ],
            "title": "activity type"
          },
          "actor": {
            "$ref": "#/components/schemas/MyPickIGithub.Usertypeidloginavatar_url",
            "title": "actor"
          }
        },
        "required": [
          "id",
          "ref",
          "timestamp",
          "activity_type",
          "actor"
        ]
      },
      "MyPickIGithub.Usertypeidloginavatar_url": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "type",
          "id",
          "login",
          "avatar_url"
        ]
      },
      "IGithub.IGetRepositoryActivityInput": {
        "type": "object",
        "properties": {
          "direction": {
            "oneOf": [
              {
                "const": "asc",
                "default": "desc"
              },
              {
                "const": "desc",
                "default": "desc"
              }
            ],
            "title": "direction\nThe order to sort by.\nDefault: asc when using full_name, otherwise desc."
          },
          "before": {
            "type": "string",
            "title": "before\n\nA cursor, as given in the Link header.\nIf specified, the query only searches for results before this cursor."
          },
          "after": {
            "type": "string",
            "title": "after\n\nA cursor, as given in the Link header.\nIf specified, the query only searches for results after this cursor."
          },
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "ref": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-branches",
              "jmesPath": "result[].{value:name, label:name}"
            },
            "title": "ref\n\nThe name of one of the branches of this repository."
          },
          "actor": {
            "type": "string",
            "title": "username"
          },
          "time_period": {
            "oneOf": [
              {
                "const": "year"
              },
              {
                "const": "month"
              },
              {
                "const": "day"
              },
              {
                "const": "week"
              },
              {
                "const": "quarter"
              }
            ],
            "title": "time_period"
          },
          "activity_type": {
            "oneOf": [
              {
                "const": "push",
                "title": "push"
              },
              {
                "const": "force_push",
                "title": "force_push"
              },
              {
                "const": "branch_creation",
                "title": "branch_creation"
              },
              {
                "const": "branch_deletion",
                "title": "branch_deletion"
              },
              {
                "const": "pr_merge",
                "title": "pr_merge"
              },
              {
                "const": "merge_queue_merge",
                "title": "merge_queue_merge"
              }
            ],
            "title": "activity_type"
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IUpdatePullRequestOutput": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "number of this pull request"
          },
          "title": {
            "type": "string",
            "description": "Title of the issue"
          },
          "id": {
            "type": "integer"
          }
        },
        "required": [
          "number",
          "title",
          "id"
        ]
      },
      "IGithub.IUpdatePullRequestInput": {
        "type": "object",
        "properties": {
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "state": {
            "oneOf": [
              {
                "const": "open",
                "title": "open"
              },
              {
                "const": "closed",
                "title": "closed"
              }
            ],
            "title": "state\n\nState of this Pull Request. Either open or closed.\nCan be one of: open, closed"
          },
          "base": {
            "type": "string",
            "title": "base\n\nThe name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository."
          },
          "head": {
            "type": "string",
            "title": "head\n\nThe name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace head with a user like this: username:branch."
          },
          "title": {
            "type": "string",
            "title": "title\n\nThe title of the new pull request. Required unless issue is specified."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "body": {
            "type": "string",
            "title": "body\n\nThe contents of the pull request."
          },
          "draft": {
            "type": "boolean",
            "title": "draft\n\nIndicates whether the pull request is a draft. See \"Draft Pull Requests\" in the GitHub Help documentation to learn more."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "head_repo": {
            "type": "string",
            "title": "head_repo\n\nThe name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization."
          },
          "maintainer_can_modify": {
            "type": "boolean",
            "title": "maintainer_can_modify\n\nIndicates whether maintainers can modify the pull request."
          },
          "issue": {
            "type": "number",
            "title": "issue\n\nAn issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless title is specified."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels"
          }
        },
        "required": [
          "pull_number",
          "secretKey",
          "owner",
          "repo"
        ]
      },
      "IGithub.ICreatePullRequestOutput": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "number of this pull request"
          },
          "title": {
            "type": "string",
            "description": "Title of the issue"
          },
          "id": {
            "type": "integer"
          }
        },
        "required": [
          "number",
          "title",
          "id"
        ]
      },
      "IGithub.ICreatePullRequestInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "title": {
            "type": "string",
            "title": "title\n\nThe title of the new pull request. Required unless issue is specified."
          },
          "head": {
            "type": "string",
            "title": "head\n\nThe name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace head with a user like this: username:branch."
          },
          "head_repo": {
            "type": "string",
            "title": "head_repo\n\nThe name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization."
          },
          "base": {
            "type": "string",
            "title": "base\n\nThe name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository."
          },
          "body": {
            "type": "string",
            "title": "body\n\nThe contents of the pull request."
          },
          "maintainer_can_modify": {
            "type": "boolean",
            "title": "maintainer_can_modify\n\nIndicates whether maintainers can modify the pull request."
          },
          "draft": {
            "type": "boolean",
            "title": "draft\n\nIndicates whether the pull request is a draft. See \"Draft Pull Requests\" in the GitHub Help documentation to learn more."
          },
          "issue": {
            "type": "number",
            "title": "issue\n\nAn issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless title is specified."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "head",
          "base",
          "secretKey"
        ]
      },
      "IGithub.IGetIssueCommentsOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.IssueComment"
            },
            "title": "issue comments"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.IssueComment": {
        "type": "object",
        "properties": {
          "issue_url": {
            "type": "string",
            "format": "iri",
            "title": "issue_url"
          },
          "author_association": {
            "oneOf": [
              {
                "const": "NONE"
              },
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Usertypeidloginhtml_urlavatar_url",
            "title": "user"
          },
          "id": {
            "type": "integer",
            "title": "id"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          }
        },
        "required": [
          "issue_url",
          "author_association",
          "user",
          "id",
          "created_at",
          "updated_at"
        ]
      },
      "IGithub.IGetPullRequestCommentsInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.ICreateIssueCommentInput": {
        "type": "object",
        "properties": {
          "body": {
            "type": "string",
            "title": "The contents of the comment"
          },
          "issue_number": {
            "type": "integer",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repositories/get-issues",
              "jmesPath": "fetchedIssues[].{value:number, label:title}"
            },
            "title": "issue number to get detailed info"
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "body",
          "issue_number",
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IReadPullRequestRequestedReviewerOutput": {
        "type": "object",
        "properties": {
          "users": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Collaborator"
            },
            "title": "requested reviewers"
          },
          "teams": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Teamdescriptionnameidpermissionslugnotification_settingprivacy"
            },
            "title": "team"
          }
        },
        "required": [
          "users",
          "teams"
        ]
      },
      "MyPickIGithub.Teamdescriptionnameidpermissionslugnotification_settingprivacy": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "title": "description"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "id": {
            "type": "number",
            "title": "id"
          },
          "permission": {
            "type": "string",
            "title": "permission"
          },
          "slug": {
            "type": "string",
            "title": "slug"
          },
          "notification_setting": {
            "type": "string",
            "title": "notification_setting"
          },
          "privacy": {
            "oneOf": [
              {
                "const": "closed"
              },
              {
                "const": "open"
              }
            ],
            "title": "privacy"
          }
        },
        "required": [
          "description",
          "name",
          "id",
          "permission",
          "slug",
          "notification_setting",
          "privacy"
        ]
      },
      "IGithub.IReadPullRequestDetailInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IRequestReviewerInput": {
        "type": "object",
        "properties": {
          "reviewers": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/github/repos/get-collaborators",
                "jmesPath": "result[].{value:login, label:login}"
              }
            }
          },
          "team_reviewers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "team_reviewers\nAn array of team slugs that will be requested."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IGetReviewCommentOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.ReviewComment"
            },
            "title": "result"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.ReviewComment": {
        "type": "object",
        "properties": {
          "pull_request_review_id": {
            "type": "integer",
            "title": "pull_request_review_id"
          },
          "diff_hunk": {
            "type": "string",
            "title": "diff_hunk\n\ndiff_hunk is a form for representing a change in code in github.\nIt consists of strings, and the first line, based on the new line character,\nhas meta information about the change point between the symbols"
          },
          "path": {
            "type": "string",
            "title": "path"
          },
          "position": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "position\n\nThe position in the diff where you want to add a review comment.\nNote this value is not the same as the line number in the file.\nThe position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment.\nThe line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.\n\nPosition value, which is the number of rows based on diff_hunk."
          },
          "original_position": {
            "type": "integer",
            "title": "original_position\n\nOriginal position value, which is the number of rows based on diff_hunk."
          },
          "commit_id": {
            "type": "string",
            "title": "commit_id"
          },
          "original_commit_id": {
            "type": "string",
            "title": "original_commit_id"
          },
          "in_reply_to_id": {
            "type": "integer",
            "title": "in_reply_to_id\n\nIn_reply_to_id is a field used by GitHub's review or comment API that is used to write a reply to a particular review or comment."
          },
          "user": {
            "$ref": "#/components/schemas/IGithub.Collaborator",
            "title": "user"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "author_association": {
            "oneOf": [
              {
                "const": "NONE"
              },
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          },
          "id": {
            "type": "integer",
            "title": "id"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          }
        },
        "required": [
          "pull_request_review_id",
          "diff_hunk",
          "path",
          "position",
          "original_position",
          "commit_id",
          "original_commit_id",
          "user",
          "html_url",
          "author_association",
          "id",
          "created_at",
          "updated_at"
        ]
      },
      "IGithub.IGetReviewCommentInput": {
        "type": "object",
        "properties": {
          "review_id": {
            "type": "integer",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/repositories/pull-requests/get-reviews",
              "jmesPath": "result[].{value:id, label: join('', [user.login, ''s review'])}"
            },
            "title": "review_id"
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "review_id",
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IReadPullRequestReviewOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Review"
            },
            "title": "commit list of this pull request"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Review": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "title": "id"
          },
          "user": {
            "$ref": "#/components/schemas/IGithub.Collaborator",
            "title": "reviewer"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "state": {
            "type": "string",
            "x-wrtn-placeholder": "APPROVED",
            "title": "state"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "pull_request_url": {
            "type": "string",
            "format": "iri",
            "title": "pull_request_url"
          },
          "submitted_at": {
            "type": "string",
            "format": "date-time",
            "title": "submitted_at"
          },
          "commit_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "commit_id\n\nA commit SHA for the review.\nIf the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`."
          },
          "author_association": {
            "oneOf": [
              {
                "const": "NONE"
              },
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          }
        },
        "required": [
          "id",
          "user",
          "body",
          "state",
          "html_url",
          "pull_request_url",
          "commit_id",
          "author_association"
        ]
      },
      "IGithub.IReadPullRequestReviewInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IReviewPullRequestOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "title": "id"
          }
        },
        "required": [
          "id"
        ]
      },
      "IGithub.IReviewPullRequestInput": {
        "type": "object",
        "properties": {
          "commit_id": {
            "type": "string",
            "title": "commit_id\n\nThe SHA of the commit that needs a review.\nNot using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the position.\nDefaults to the most recent commit in the pull request when you do not specify a value."
          },
          "body": {
            "type": "string",
            "title": "body\n\nRequired when using REQUEST_CHANGES or COMMENT for the event parameter.\nThe body text of the pull request review."
          },
          "event": {
            "oneOf": [
              {
                "const": "APPROVE",
                "title": "APPROVE"
              },
              {
                "const": "REQUEST_CHANGES",
                "title": "REQUEST_CHANGES"
              },
              {
                "const": "COMMENT",
                "title": "COMMENT"
              }
            ],
            "title": "event\n\nThe review action you want to perform.\nThe review actions include: APPROVE, REQUEST_CHANGES, or COMMENT.\nBy leaving this blank, you set the review action state to PENDING, which means you will need to submit the pull request review when you are ready."
          },
          "comments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.IPullRequestComment"
            },
            "title": "comments\n\nUse the following table to specify the location, destination, and contents of the draft review comment."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IPullRequestComment": {
        "type": "object",
        "properties": {
          "line": {
            "type": "integer"
          },
          "side": {
            "type": "string"
          },
          "start_line": {
            "type": "integer"
          },
          "start_side": {
            "type": "string"
          },
          "path": {
            "type": "string",
            "title": "path"
          },
          "body": {
            "type": "string",
            "title": "body"
          },
          "position": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "integer"
              }
            ],
            "title": "position\n\nThe position in the diff where you want to add a review comment.\nNote this value is not the same as the line number in the file.\nThe position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment.\nThe line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.\n\nPosition value, which is the number of rows based on diff_hunk."
          }
        },
        "required": [
          "line",
          "side",
          "start_line",
          "start_side",
          "path",
          "position"
        ]
      },
      "IGithub.IReadPullRequestFileOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.File"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.File": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "title": "hash of this file"
          },
          "filename": {
            "type": "string",
            "title": "filename"
          },
          "status": {
            "oneOf": [
              {
                "const": "added"
              },
              {
                "const": "removed"
              },
              {
                "const": "modified"
              },
              {
                "const": "renamed"
              },
              {
                "const": "copied"
              },
              {
                "const": "changed"
              },
              {
                "const": "unchanged"
              }
            ],
            "title": "status of file in this commit"
          },
          "additions": {
            "type": "integer",
            "title": "additions"
          },
          "deletions": {
            "type": "integer",
            "title": "deletions"
          },
          "changes": {
            "type": "integer",
            "title": "changes"
          },
          "blob_url": {
            "type": "string",
            "format": "iri",
            "title": "blob_url\n\nThis is the path through which you can view the file through the github website."
          },
          "raw_url": {
            "type": "string",
            "format": "iri",
            "title": "raw_url\n\nThe API path through which the contents of the file can be viewed."
          },
          "patch": {
            "type": "string",
            "title": "patch\n\nIt means how much it has changed compared to previous commitments.\nIt gives you a text form to see what code has actually changed."
          }
        },
        "required": [
          "sha",
          "filename",
          "status",
          "additions",
          "deletions",
          "changes",
          "blob_url",
          "raw_url"
        ]
      },
      "IGithub.IReadPullRequestFileInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.IReadPullRequestCommitOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGithub.Commitsha"
            },
            "title": "commit list of this pull request"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "StrictOmitIGithub.Commitsha": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "title": "commit message"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "uri\n\nuri to look up details of commitment"
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "email": {
                "type": "string"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "author"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "email": {
                "type": "string"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "committer"
          },
          "tree": {
            "type": "object",
            "properties": {
              "sha": {
                "type": "string"
              },
              "url": {
                "type": "string",
                "format": "iri"
              }
            },
            "required": [
              "sha",
              "url"
            ]
          },
          "comment_count": {
            "type": "integer"
          }
        },
        "required": [
          "message",
          "url",
          "author",
          "committer",
          "tree",
          "comment_count"
        ]
      },
      "IGithub.IReadPullRequestCommitInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "pull_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/get-pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/repositories/pull-requests",
                  "jmesPath": "pullRequests[].{value:number, label:number}"
                }
              }
            ],
            "title": "pull request number to update"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "owner",
          "repo",
          "pull_number",
          "secretKey"
        ]
      },
      "IGithub.PullRequest": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "number of this pull request"
          },
          "milestone": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.MileStone"
              }
            ],
            "title": "milestone"
          },
          "head": {
            "type": "object",
            "properties": {
              "label": {
                "type": "string",
                "title": "label"
              },
              "ref": {
                "type": "string",
                "title": "ref"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "user": {
                "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin",
                "title": "user"
              },
              "repo": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/MyPickIGithub.Repositoryfull_name"
                  }
                ],
                "title": "repo"
              }
            },
            "required": [
              "label",
              "ref",
              "sha",
              "user",
              "repo"
            ],
            "title": "head branch info"
          },
          "base": {
            "type": "object",
            "properties": {
              "label": {
                "type": "string",
                "title": "label"
              },
              "ref": {
                "type": "string",
                "title": "ref"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "user": {
                "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin",
                "title": "user"
              },
              "repo": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/MyPickIGithub.Repositoryfull_name"
                  }
                ],
                "title": "repo"
              }
            },
            "required": [
              "label",
              "ref",
              "sha",
              "user",
              "repo"
            ],
            "title": "base branch info"
          },
          "author_association": {
            "oneOf": [
              {
                "const": "NONE"
              },
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          },
          "draft": {
            "type": "boolean",
            "title": "draft\n\nIndicates whether or not the pull request is a draft."
          },
          "requested_reviewers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin"
            },
            "title": "requested_reviewers"
          },
          "requested_teams": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartialIGithub.Team"
            },
            "title": "requested_teams"
          },
          "auto_merge": {
            "title": "auto_merge"
          },
          "merged": {
            "type": "boolean",
            "title": "merged"
          },
          "mergeable": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "mergeable"
          },
          "rebaseable": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "boolean"
              }
            ],
            "title": "rebaseable"
          },
          "mergeable_state": {
            "type": "string",
            "title": "mergeable_state"
          },
          "merged_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin"
              }
            ],
            "title": "merged_by"
          },
          "maintainer_can_modify": {
            "type": "boolean",
            "title": "maintainer_can_modify"
          },
          "comments": {
            "type": "integer",
            "minimum": 0,
            "title": "comments"
          },
          "review_comments": {
            "type": "integer",
            "minimum": 0,
            "title": "review_comments"
          },
          "commits": {
            "type": "integer",
            "minimum": 0,
            "title": "commits"
          },
          "additions": {
            "type": "integer",
            "minimum": 0,
            "title": "additions"
          },
          "deletions": {
            "type": "integer",
            "minimum": 0,
            "title": "deletions"
          },
          "changed_files": {
            "type": "integer",
            "minimum": 0,
            "title": "changed_files"
          },
          "locked": {
            "type": "boolean",
            "title": "locked"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "closed_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "closed_at"
          },
          "merged_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "merged_at"
          },
          "id": {
            "type": "integer"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to see the issue or pull_request on the web, you can go to this link.\nIf pull is included on this link path, it is pull_request, and if issue is included, it is issue.\nIn essence, pull_request and issue are numbered together from the beginning, so while this connector does not distinguish the two, it can be distinguished by the url path."
          },
          "state": {
            "type": "string",
            "title": "state\n\nState of the issue; either 'open' or 'closed'"
          },
          "state_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "completed"
              },
              {
                "const": "reopened"
              },
              {
                "const": "not_planned"
              }
            ],
            "description": "The reason for the current state"
          },
          "title": {
            "type": "string",
            "description": "Title of the issue"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin",
            "title": "user"
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "body\n\nContents of the issue\n\nYou can also render this content because it is in a markdown format."
          },
          "labels": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "integer"
                    },
                    "url": {
                      "type": "string",
                      "format": "iri"
                    },
                    "name": {
                      "type": "string"
                    },
                    "description": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    },
                    "color": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    },
                    "default": {
                      "type": "boolean"
                    }
                  }
                }
              ]
            },
            "title": "labels\n\nLabels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
              }
            ],
            "title": "assignee"
          },
          "assignees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            ],
            "title": "assignees\n\nIf there are many people in charge, you can be included in the array."
          }
        },
        "required": [
          "number",
          "milestone",
          "head",
          "base",
          "author_association",
          "requested_reviewers",
          "requested_teams",
          "auto_merge",
          "mergeable",
          "rebaseable",
          "mergeable_state",
          "merged_by",
          "maintainer_can_modify",
          "comments",
          "review_comments",
          "commits",
          "additions",
          "deletions",
          "changed_files",
          "locked",
          "created_at",
          "updated_at",
          "closed_at",
          "merged_at",
          "id",
          "html_url",
          "state",
          "title",
          "user",
          "labels",
          "assignee"
        ]
      },
      "IGithub.MileStone": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "number": {
            "type": "number"
          },
          "state": {
            "oneOf": [
              {
                "const": "closed"
              },
              {
                "const": "open"
              }
            ]
          },
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "creator": {
            "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin"
          },
          "open_issues": {
            "type": "integer",
            "minimum": 0
          },
          "closed_issues": {
            "type": "integer",
            "minimum": 0
          },
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time"
          },
          "closed_at": {
            "type": "string",
            "format": "date-time"
          },
          "due_on": {
            "type": "string",
            "format": "date-time"
          }
        },
        "required": [
          "id",
          "number",
          "state",
          "title",
          "description",
          "creator",
          "open_issues",
          "closed_issues",
          "created_at",
          "updated_at",
          "closed_at",
          "due_on"
        ]
      },
      "MyPickIGithub.Repositoryfull_name": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string",
            "title": "full_name\n\nThis is in the form '{username}/{reponame}'."
          }
        },
        "required": [
          "full_name"
        ]
      },
      "PartialIGithub.Team": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "slug": {
            "type": "string",
            "title": "slug"
          },
          "description": {
            "type": "string",
            "title": "description"
          },
          "privacy": {
            "oneOf": [
              {
                "const": "closed"
              },
              {
                "const": "open"
              }
            ],
            "title": "privacy"
          },
          "notification_setting": {
            "type": "string",
            "title": "notification_setting"
          },
          "permission": {
            "type": "string",
            "title": "permission"
          }
        },
        "description": "Make all properties in T optional"
      },
      "IGithub.IFetchRepositoryPullRequestOutput": {
        "type": "object",
        "properties": {
          "pullRequests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.FetchedPullRequest"
            }
          },
          "pageInfo": {
            "type": "object",
            "properties": {
              "endCursor": {
                "type": "string",
                "title": "Cursor to be used to look up the next page"
              },
              "hasNextPage": {
                "type": "boolean",
                "title": "hasNextPage\n\ntrue if there is a next page"
              }
            },
            "required": [
              "hasNextPage"
            ],
            "title": "page info"
          }
        },
        "required": [
          "pullRequests",
          "pageInfo"
        ]
      },
      "IGithub.FetchedPullRequest": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "issue id"
          },
          "state": {
            "oneOf": [
              {
                "const": "OPEN",
                "title": "OPEN"
              },
              {
                "const": "CLOSED",
                "title": "CLOSED"
              },
              {
                "const": "MERGED",
                "title": "MERGED"
              }
            ],
            "title": "issue state"
          },
          "number": {
            "type": "integer",
            "title": "number of pull request"
          },
          "title": {
            "type": "string",
            "title": "Pull request title"
          },
          "comments": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total count of comments"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "comments"
          },
          "reviews": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total counr of reviews"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "reviews"
          },
          "reactions": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total count of reactions"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "reactions"
          },
          "labels": {
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Labeldescriptionname"
                }
              }
            },
            "required": [
              "nodes"
            ],
            "title": "labels"
          },
          "assignees": {
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            },
            "required": [
              "nodes"
            ],
            "title": "assignees"
          },
          "author": {
            "$ref": "#/components/schemas/MyPickIGithub.Userlogin",
            "title": "author"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "createdAt"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "updatedAt"
          }
        },
        "required": [
          "id",
          "number",
          "title",
          "comments",
          "reviews",
          "reactions",
          "labels",
          "assignees",
          "author",
          "createdAt",
          "updatedAt"
        ]
      },
      "MyPickIGithub.Labeldescriptionname": {
        "type": "object",
        "properties": {
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          },
          "name": {
            "type": "string",
            "title": "label name"
          }
        },
        "required": [
          "description",
          "name"
        ]
      },
      "IGithub.IFetchRepositoryPullRequestInput": {
        "type": "object",
        "properties": {
          "sort": {
            "oneOf": [
              {
                "const": "CREATED_AT",
                "title": "CREATED_AT"
              },
              {
                "const": "UPDATED_AT",
                "title": "UPDATED_AT"
              }
            ],
            "title": "sort\nIt must be one of: \"CREATED_AT\", \"UPDATED_AT\"."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels\nIf you want to filter the issue by label, pass the string.\nIf it is an empty array, it is ignored."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100
          },
          "after": {
            "type": "string",
            "title": "after\ncursor of next page"
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "state": {
            "oneOf": [
              {
                "const": "OPEN",
                "title": "OPEN"
              },
              {
                "const": "CLOSED",
                "title": "CLOSED"
              },
              {
                "const": "MERGED",
                "title": "MERGED"
              }
            ],
            "title": "state\n\nIf you don't want to filter, you don't put anything in.\nIt must be one of: \"OPEN\", \"CLOSED\", \"MERGED\"."
          },
          "direction": {
            "oneOf": [
              {
                "const": "ASC",
                "title": "ASC"
              },
              {
                "const": "DESC",
                "title": "DESC"
              }
            ],
            "title": "direction\nIt must be one of: \"ASC\", \"DESC\"."
          }
        },
        "required": [
          "sort",
          "secretKey",
          "owner",
          "repo",
          "direction"
        ]
      },
      "IGithub.DetailedIssue": {
        "type": "object",
        "properties": {
          "milestone": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.MileStone"
              }
            ],
            "title": "milestone"
          },
          "reactions": {
            "type": "object",
            "properties": {
              "total_count": {
                "type": "integer",
                "title": "total_count"
              },
              "+1": {
                "type": "integer",
                "title": "\"+1\""
              },
              "-1": {
                "type": "integer",
                "title": "\"-1\""
              },
              "laugh": {
                "type": "integer",
                "title": "laugh"
              },
              "hooray": {
                "type": "integer",
                "title": "hooray"
              },
              "confused": {
                "type": "integer",
                "title": "confused"
              },
              "heart": {
                "type": "integer",
                "title": "heart"
              },
              "rocket": {
                "type": "integer",
                "title": "rocket"
              },
              "eyes": {
                "type": "integer",
                "title": "eyes"
              }
            },
            "required": [
              "total_count",
              "+1",
              "-1",
              "laugh",
              "hooray",
              "confused",
              "heart",
              "rocket",
              "eyes"
            ],
            "title": "reactions"
          },
          "closed_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin"
              }
            ],
            "title": "closed_by"
          },
          "id": {
            "type": "integer"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to see the issue or pull_request on the web, you can go to this link.\nIf pull is included on this link path, it is pull_request, and if issue is included, it is issue.\nIn essence, pull_request and issue are numbered together from the beginning, so while this connector does not distinguish the two, it can be distinguished by the url path."
          },
          "number": {
            "type": "integer",
            "title": "issue number\n\nNumber uniquely identifying the issue within its repository"
          },
          "state": {
            "type": "string",
            "title": "state\n\nState of the issue; either 'open' or 'closed'"
          },
          "state_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "completed"
              },
              {
                "const": "reopened"
              },
              {
                "const": "not_planned"
              }
            ],
            "description": "The reason for the current state"
          },
          "title": {
            "type": "string",
            "description": "Title of the issue"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin",
            "title": "user"
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "body\n\nContents of the issue\n\nYou can also render this content because it is in a markdown format."
          },
          "labels": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "integer"
                    },
                    "url": {
                      "type": "string",
                      "format": "iri"
                    },
                    "name": {
                      "type": "string"
                    },
                    "description": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    },
                    "color": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    },
                    "default": {
                      "type": "boolean"
                    }
                  }
                }
              ]
            },
            "title": "labels\n\nLabels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
              }
            ],
            "title": "assignee"
          },
          "assignees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            ],
            "title": "assignees\n\nIf there are many people in charge, you can be included in the array."
          }
        },
        "required": [
          "milestone",
          "reactions",
          "id",
          "html_url",
          "number",
          "state",
          "title",
          "user",
          "labels",
          "assignee"
        ]
      },
      "IGithub.IGetIssueDetailInput": {
        "type": "object",
        "properties": {
          "issue_number": {
            "type": "integer",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repositories/get-issues",
              "jmesPath": "fetchedIssues[].{value:number, label:title}"
            },
            "title": "issue number to get detailed info"
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "issue_number",
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetIssueCommentsInput": {
        "type": "object",
        "properties": {
          "issue_number": {
            "type": "integer",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/repositories/get-issues",
              "jmesPath": "fetchedIssues[].{value:number, label:title}"
            },
            "title": "issue number to get detailed info"
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "issue_number",
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IFetchRepositoryOutput": {
        "type": "object",
        "properties": {
          "fetchedIssues": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StrictOmitIGithub.FetchedIssuebody"
            },
            "title": "issues"
          },
          "pageInfo": {
            "type": "object",
            "properties": {
              "endCursor": {
                "type": "string",
                "title": "Cursor to be used to look up the next page"
              },
              "hasNextPage": {
                "type": "boolean",
                "title": "hasNextPage\n\ntrue if there is a next page"
              }
            },
            "required": [
              "hasNextPage"
            ],
            "title": "page info"
          }
        },
        "required": [
          "fetchedIssues",
          "pageInfo"
        ]
      },
      "StrictOmitIGithub.FetchedIssuebody": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "issue number\n\nNumber uniquely identifying the issue within its repository"
          },
          "title": {
            "type": "string",
            "title": "issue title"
          },
          "id": {
            "type": "string",
            "title": "issue id"
          },
          "comments": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total count of comments"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "comments"
          },
          "labels": {
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Labeldescriptionname"
                }
              }
            },
            "required": [
              "nodes"
            ],
            "title": "labels"
          },
          "author": {
            "$ref": "#/components/schemas/MyPickIGithub.Userlogin",
            "title": "author"
          },
          "state": {
            "oneOf": [
              {
                "const": "OPEN",
                "title": "OPEN"
              },
              {
                "const": "CLOSED",
                "title": "CLOSED"
              },
              {
                "const": "MERGED",
                "title": "MERGED"
              }
            ],
            "title": "issue state"
          },
          "stateReason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "reason of state"
          },
          "reactions": {
            "type": "object",
            "properties": {
              "totalCount": {
                "type": "number",
                "minimum": 0,
                "title": "total count of reactions"
              }
            },
            "required": [
              "totalCount"
            ],
            "title": "reactions"
          },
          "assignees": {
            "type": "object",
            "properties": {
              "nodes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            },
            "required": [
              "nodes"
            ],
            "title": "assignees"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "createdAt"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "updatedAt"
          }
        },
        "required": [
          "number",
          "title",
          "id",
          "comments",
          "labels",
          "author",
          "reactions",
          "assignees",
          "createdAt",
          "updatedAt"
        ]
      },
      "IGithub.IFetchRepositoryInput": {
        "type": "object",
        "properties": {
          "after": {
            "type": "string",
            "title": "after\ncursor of next page"
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels\nIf you want to filter the issue by label, pass the string.\nIf it is an empty array, it is ignored."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100
          },
          "state": {
            "oneOf": [
              {
                "const": "OPEN",
                "title": "OPEN"
              },
              {
                "const": "CLOSED",
                "title": "CLOSED"
              },
              {
                "const": "MERGED",
                "title": "MERGED"
              }
            ],
            "title": "state\n\nIf you don't want to filter, you don't put anything in.\nIt must be one of: \"OPEN\", \"CLOSED\", \"MERGED\"."
          },
          "direction": {
            "oneOf": [
              {
                "const": "ASC",
                "title": "ASC"
              },
              {
                "const": "DESC",
                "title": "DESC"
              }
            ],
            "title": "direction\nIt must be one of: \"ASC\", \"DESC\"."
          },
          "sort": {
            "oneOf": [
              {
                "const": "CREATED_AT",
                "title": "CREATED_AT"
              },
              {
                "const": "UPDATED_AT",
                "title": "UPDATED_AT"
              },
              {
                "const": "COMMENTS",
                "title": "COMMENTS"
              }
            ],
            "title": "condition of direction\nIt must be one of: \"CREATED_AT\", \"UPDATED_AT\", \"COMMENTS\"."
          },
          "owner": {
            "type": "string",
            "title": "owner's name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository.\nSo the owner here is the nickname of the repository owner, not the name of the person committing or the author."
          },
          "repo": {
            "type": "string",
            "title": "repository name\n\nThe owner's name and the repository's name can be combined to form '${owner}/${repo}' and can be a unique path name for a single repository."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "direction",
          "sort",
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.ISearchUserOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.User"
            },
            "title": "User Search Result Item\n\nUser Search Result Item"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.User": {
        "type": "object",
        "properties": {
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to look up your profile, you can access this website."
          },
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "score": {
            "type": "number",
            "title": "score"
          }
        },
        "required": [
          "login",
          "id",
          "avatar_url",
          "html_url",
          "type",
          "score"
        ]
      },
      "IGithub.ISearchUserInput": {
        "type": "object",
        "properties": {
          "q": {
            "type": "string",
            "title": "keyword\n\nThe query contains one or more search keywords and qualifiers.\nQualifiers allow you to limit your search to specific areas of GitHub.\nThe REST API supports the same qualifiers as the web interface for GitHub."
          },
          "sort": {
            "oneOf": [
              {
                "const": "followers"
              },
              {
                "const": "repositories"
              },
              {
                "const": "joined"
              }
            ],
            "title": "sorting condition\n\nSorts the results of your query by number of followers or repositories, or when the person joined GitHub. Default: best match\nIt must be one of this: \"followers\" | \"repositories\" | \"joined\""
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "order": {
            "oneOf": [
              {
                "const": "asc",
                "default": "desc"
              },
              {
                "const": "desc",
                "default": "desc"
              }
            ],
            "title": "order\n\nDetermines whether the first search result returned is the highest number of matches (desc) or lowest number of matches (asc).\nThis parameter is ignored unless you provide sort."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "q",
          "secretKey"
        ]
      },
      "IGithub.IGetUserProfileOutput": {
        "type": "object",
        "properties": {
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "name\nIt means the actual name that the user has written, not the user's nickname."
          },
          "company": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "comany name\n\nAs the name of the company,\nit cannot be said to be the exact name listed as the business operator because it was written by the user himself.\nAlso, we cannot guarantee that the user wrote the company name.\nSometimes the user jokingly writes down strange names."
          },
          "blog": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "blog\n\nIndicates the blog address."
          },
          "location": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "location\n\nIt means the location of the user.\nUsually, I write the country down, but the user can jokingly record the strange location."
          },
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "email address"
          },
          "bio": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "bio\n\nWrite down what the user wants to say or a history."
          },
          "twitter_username": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "twitter_username"
          },
          "public_repos": {
            "type": "integer",
            "title": "count of public repos"
          },
          "public_gists": {
            "type": "integer",
            "title": "count of public gists"
          },
          "followers": {
            "type": "integer",
            "title": "count of followers"
          },
          "following": {
            "type": "integer",
            "title": "count of follwing"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "profile_repository": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RepositoryreadmeIGetReadmeFileContentOutput"
              }
            ],
            "title": "profile_repo"
          },
          "pinned_repositories": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "pinned_repositories\nIt is a repository where the user puts a pin on his profile, which is usually used to display his or her proud history."
          },
          "type": {
            "oneOf": [
              {
                "const": "User"
              },
              {
                "const": "Bot"
              },
              {
                "const": "Organization"
              }
            ],
            "title": "type"
          },
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "public_repos",
          "public_gists",
          "followers",
          "following",
          "created_at",
          "updated_at",
          "profile_repository",
          "pinned_repositories",
          "type",
          "id",
          "login",
          "avatar_url"
        ]
      },
      "RepositoryreadmeIGetReadmeFileContentOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id"
          },
          "name": {
            "type": "string",
            "title": "name"
          },
          "full_name": {
            "type": "string",
            "title": "full_name\n\nThis is in the form '{username}/{reponame}'."
          },
          "private": {
            "type": "boolean",
            "title": "private"
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url"
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          },
          "fork": {
            "type": "boolean",
            "title": "fork"
          },
          "forks_count": {
            "type": "integer",
            "title": "forks_count"
          },
          "stargazers_count": {
            "type": "integer",
            "title": "stargazers_count"
          },
          "watchers_count": {
            "type": "integer",
            "title": "watchers_count"
          },
          "size": {
            "type": "number",
            "title": "size"
          },
          "default_branch": {
            "type": "string",
            "title": "default_branch"
          },
          "open_issues_count": {
            "type": "integer",
            "title": "open_issues_count"
          },
          "is_template": {
            "type": "boolean",
            "title": "is_template"
          },
          "topics": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "topics"
          },
          "has_issues": {
            "type": "boolean",
            "title": "has_issues"
          },
          "has_projects": {
            "type": "boolean",
            "title": "has_projects"
          },
          "has_wiki": {
            "type": "boolean",
            "title": "has_wiki"
          },
          "has_pages": {
            "type": "boolean",
            "title": "has_pages"
          },
          "has_downloads": {
            "type": "boolean",
            "title": "has_downloads"
          },
          "archived": {
            "type": "boolean",
            "title": "archived"
          },
          "disabled": {
            "type": "boolean",
            "title": "disabled"
          },
          "visibility": {
            "oneOf": [
              {
                "const": "public"
              },
              {
                "const": "private"
              }
            ],
            "title": "visibility"
          },
          "pushed_at": {
            "type": "string",
            "format": "date-time",
            "title": "pushed_at"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "permissions": {
            "type": "object",
            "properties": {
              "admin": {
                "type": "boolean",
                "title": "admin"
              },
              "push": {
                "type": "boolean",
                "title": "push"
              },
              "pull": {
                "type": "boolean",
                "title": "pull"
              }
            },
            "required": [
              "admin",
              "push",
              "pull"
            ]
          },
          "allow_rebase_merge": {
            "type": "boolean",
            "title": "allow_rebase_merge"
          },
          "allow_squash_merge": {
            "type": "boolean",
            "title": "allow_squash_merge"
          },
          "allow_auto_merge": {
            "type": "boolean",
            "title": "allow_auto_merge"
          },
          "delete_branch_on_merge": {
            "type": "boolean",
            "title": "delete_branch_on_merge"
          },
          "allow_merge_commit": {
            "type": "boolean",
            "title": "allow_merge_commit"
          },
          "subscribers_count": {
            "type": "integer",
            "title": "subscribers_count"
          },
          "network_count": {
            "type": "integer",
            "title": "network_count"
          },
          "license": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "key": {
                    "type": "string",
                    "x-wrtn-placeholder": "mit",
                    "title": "key"
                  },
                  "name": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT License",
                    "title": "name"
                  },
                  "url": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "type": "string",
                        "x-wrtn-placeholder": "https://api.github.com/licenses/mit"
                      }
                    ],
                    "title": "url"
                  },
                  "spdx_id": {
                    "type": "string",
                    "x-wrtn-placeholder": "MIT",
                    "title": "spdx_id"
                  }
                },
                "required": [
                  "key",
                  "name",
                  "url",
                  "spdx_id"
                ]
              }
            ]
          },
          "forks": {
            "type": "integer",
            "title": "forks"
          },
          "open_issues": {
            "type": "integer",
            "title": "open_issues"
          },
          "watchers": {
            "type": "integer",
            "title": "watchers"
          },
          "readme": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.RepositoryFile"
              }
            ],
            "discriminator": {
              "propertyName": "type",
              "mapping": {
                "file": "#/components/schemas/IGithub.RepositoryFile"
              }
            }
          }
        },
        "required": [
          "id",
          "name",
          "full_name",
          "private",
          "html_url",
          "description",
          "fork",
          "forks_count",
          "stargazers_count",
          "watchers_count",
          "size",
          "default_branch",
          "open_issues_count",
          "is_template",
          "topics",
          "has_issues",
          "has_projects",
          "has_wiki",
          "has_pages",
          "has_downloads",
          "archived",
          "disabled",
          "visibility",
          "pushed_at",
          "created_at",
          "updated_at",
          "license",
          "forks",
          "open_issues",
          "watchers",
          "readme"
        ]
      },
      "IGithub.IGetUserProfileInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "username"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetAuthenticatedUserOrganizationOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Organization"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.IGetAuthenticatedUserOrganizationInput": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IGithub.IGetBranchOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Branch"
            },
            "title": "branches"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Branch": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name of Branch"
          },
          "commit": {
            "$ref": "#/components/schemas/StrictOmitIGithub.Commitsha",
            "title": "commit\n\nIn github, branch is just another name for the last node of a commit,\nso this property called commit is logically the same as what it means for that branch."
          }
        },
        "required": [
          "name",
          "commit"
        ]
      },
      "IGithub.IGetBranchInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.ICreateBranchOutput": {
        "type": "object",
        "properties": {
          "ref": {
            "type": "string",
            "x-wrtn-placeholder": "refs/heads/featureA",
            "title": "ref"
          },
          "object": {
            "type": "object",
            "properties": {
              "type": {
                "const": "commit"
              },
              "sha": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "sha"
            ]
          }
        },
        "required": [
          "ref",
          "object"
        ]
      },
      "IGithub.ICreateBranchInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "ref": {
            "type": "string",
            "title": "ref\nThe name of the fully qualified reference (ie: refs/heads/master). If it doesn't start with 'refs' and have at least two slashes, it will be rejected."
          },
          "sha": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-commit-list",
              "jmesPath": "result[].{value:sha, label: commit.message}"
            },
            "title": "sha\nThe SHA1 value for this reference."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "ref",
          "sha",
          "secretKey"
        ]
      },
      "StrictOmitIGithub.PullRequestcommentsmaintainer_can_modifymergeablerebaseablemergeable_statemerged_byreview_commentscommitsadditionsdeletionschanged_files": {
        "type": "object",
        "properties": {
          "number": {
            "type": "integer",
            "title": "number of this pull request"
          },
          "title": {
            "type": "string",
            "description": "Title of the issue"
          },
          "base": {
            "type": "object",
            "properties": {
              "label": {
                "type": "string",
                "title": "label"
              },
              "ref": {
                "type": "string",
                "title": "ref"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "user": {
                "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin",
                "title": "user"
              },
              "repo": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/MyPickIGithub.Repositoryfull_name"
                  }
                ],
                "title": "repo"
              }
            },
            "required": [
              "label",
              "ref",
              "sha",
              "user",
              "repo"
            ],
            "title": "base branch info"
          },
          "user": {
            "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin",
            "title": "user"
          },
          "head": {
            "type": "object",
            "properties": {
              "label": {
                "type": "string",
                "title": "label"
              },
              "ref": {
                "type": "string",
                "title": "ref"
              },
              "sha": {
                "type": "string",
                "title": "sha"
              },
              "user": {
                "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin",
                "title": "user"
              },
              "repo": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/MyPickIGithub.Repositoryfull_name"
                  }
                ],
                "title": "repo"
              }
            },
            "required": [
              "label",
              "ref",
              "sha",
              "user",
              "repo"
            ],
            "title": "head branch info"
          },
          "id": {
            "type": "integer"
          },
          "body": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "body\n\nContents of the issue\n\nYou can also render this content because it is in a markdown format."
          },
          "draft": {
            "type": "boolean",
            "title": "draft\n\nIndicates whether or not the pull request is a draft."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at"
          },
          "assignee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
              }
            ],
            "title": "assignee"
          },
          "labels": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "integer"
                    },
                    "url": {
                      "type": "string",
                      "format": "iri"
                    },
                    "name": {
                      "type": "string"
                    },
                    "description": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    },
                    "color": {
                      "oneOf": [
                        {
                          "type": "null"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    },
                    "default": {
                      "type": "boolean"
                    }
                  }
                }
              ]
            },
            "title": "labels\n\nLabels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository"
          },
          "state": {
            "type": "string",
            "title": "state\n\nState of the issue; either 'open' or 'closed'"
          },
          "assignees": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/MyPickIGithub.Userlogin"
                }
              }
            ],
            "title": "assignees\n\nIf there are many people in charge, you can be included in the array."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to see the issue or pull_request on the web, you can go to this link.\nIf pull is included on this link path, it is pull_request, and if issue is included, it is issue.\nIn essence, pull_request and issue are numbered together from the beginning, so while this connector does not distinguish the two, it can be distinguished by the url path."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at"
          },
          "milestone": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IGithub.MileStone"
              }
            ],
            "title": "milestone"
          },
          "author_association": {
            "oneOf": [
              {
                "const": "NONE"
              },
              {
                "const": "COLLABORATOR"
              },
              {
                "const": "CONTRIBUTOR"
              },
              {
                "const": "FIRST_TIMER"
              },
              {
                "const": "FIRST_TIME_CONTRIBUTOR"
              },
              {
                "const": "MANNEQUIN"
              },
              {
                "const": "MEMBER"
              },
              {
                "const": "OWNER"
              }
            ],
            "title": "author_association"
          },
          "requested_reviewers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Usertypeidlogin"
            },
            "title": "requested_reviewers"
          },
          "requested_teams": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PartialIGithub.Team"
            },
            "title": "requested_teams"
          },
          "auto_merge": {
            "title": "auto_merge"
          },
          "merged": {
            "type": "boolean",
            "title": "merged"
          },
          "locked": {
            "type": "boolean",
            "title": "locked"
          },
          "closed_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "closed_at"
          },
          "merged_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "merged_at"
          },
          "state_reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "completed"
              },
              {
                "const": "reopened"
              },
              {
                "const": "not_planned"
              }
            ],
            "description": "The reason for the current state"
          }
        },
        "required": [
          "number",
          "title",
          "base",
          "user",
          "head",
          "id",
          "created_at",
          "assignee",
          "labels",
          "state",
          "html_url",
          "updated_at",
          "milestone",
          "author_association",
          "requested_reviewers",
          "requested_teams",
          "auto_merge",
          "locked",
          "closed_at",
          "merged_at"
        ]
      },
      "IGithub.IGetPullRequestInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "commit_sha": {
            "type": "string",
            "title": "commit_sha\n\nThe SHA of the commit."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "commit_sha",
          "secretKey"
        ]
      },
      "IGithub.IGetCommitHeadOutput": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string"
          },
          "commit": {
            "$ref": "#/components/schemas/MyPickIGithub.Commitmessageurlauthorcommittertreecomment_count"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.File"
            }
          }
        },
        "required": [
          "sha",
          "commit",
          "files"
        ]
      },
      "MyPickIGithub.Commitmessageurlauthorcommittertreecomment_count": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "title": "commit message"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "uri\n\nuri to look up details of commitment"
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "email": {
                "type": "string"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "author"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "email": {
                "type": "string"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "committer"
          },
          "tree": {
            "type": "object",
            "properties": {
              "sha": {
                "type": "string"
              },
              "url": {
                "type": "string",
                "format": "iri"
              }
            },
            "required": [
              "sha",
              "url"
            ]
          },
          "comment_count": {
            "type": "integer"
          }
        },
        "required": [
          "message",
          "url",
          "author",
          "committer",
          "tree",
          "comment_count"
        ]
      },
      "IGithub.IGetCommitHeadInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "commit_sha": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-commit-list",
              "jmesPath": "result[].{value:sha, label:comment.message}"
            },
            "title": "commit_sha\n\nThe SHA of the commit."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "commit_sha",
          "secretKey"
        ]
      },
      "IGithub.IGetCommitOutput": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "title": "hash of this commit"
          },
          "commit": {
            "$ref": "#/components/schemas/StrictOmitIGithub.Commitsha",
            "title": "commit"
          },
          "html_url": {
            "type": "string",
            "format": "iri"
          },
          "parents": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Commitsha"
            },
            "title": "Parents of this commit"
          },
          "stats": {
            "type": "object",
            "properties": {
              "total": {
                "type": "integer",
                "title": "sum of additions and deletions"
              },
              "additions": {
                "type": "integer",
                "title": "lines of additions"
              },
              "deletions": {
                "type": "integer",
                "title": "lines of deletions"
              }
            },
            "required": [
              "total",
              "additions",
              "deletions"
            ]
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.File"
            },
            "title": "files\n\nYou can see the changes for each file."
          }
        },
        "required": [
          "sha",
          "commit",
          "html_url",
          "parents",
          "stats",
          "files"
        ]
      },
      "MyPickIGithub.Commitsha": {
        "type": "object",
        "properties": {
          "sha": {
            "type": "string",
            "title": "hash of this commit"
          }
        },
        "required": [
          "sha"
        ]
      },
      "IGithub.IGetCommitInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "ref": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/github/get-branches",
              "jmesPath": "result[].{value:name, label:name}"
            },
            "title": "commit hash or branch name"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetCommitListOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "sha": {
                  "type": "string"
                },
                "commit": {
                  "$ref": "#/components/schemas/MyPickIGithub.Commitmessageurlauthorcommitter"
                }
              },
              "required": [
                "sha",
                "commit"
              ]
            },
            "title": "commit list"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "MyPickIGithub.Commitmessageurlauthorcommitter": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "title": "commit message"
          },
          "url": {
            "type": "string",
            "format": "iri",
            "title": "uri\n\nuri to look up details of commitment"
          },
          "author": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "email": {
                "type": "string"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "author"
          },
          "committer": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "email": {
                "type": "string"
              },
              "date": {
                "type": "string",
                "format": "date-time"
              }
            },
            "required": [
              "name",
              "email",
              "date"
            ],
            "title": "committer"
          }
        },
        "required": [
          "message",
          "url",
          "author",
          "committer"
        ]
      },
      "IGithub.IGetCommitListInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "sha": {
            "type": "string",
            "title": "sha\n\nSHA or branch to start listing commits from. Default: the repository’s default branch (usually main)."
          },
          "path": {
            "type": "string",
            "title": "path\n\nOnly commits containing this file path will be returned."
          },
          "author": {
            "type": "string",
            "title": "author\n\nGitHub username or email address to use to filter by commit author."
          },
          "committer": {
            "type": "string",
            "title": "committer\n\nGitHub username or email address to use to filter by commit committer."
          },
          "since": {
            "type": "string",
            "format": "date-time",
            "title": "since\n\nOnly show results that were last updated after the given time. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned."
          },
          "until": {
            "type": "string",
            "format": "date-time",
            "title": "until\n\nOnly commits before this date will be returned. This is a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "order": {
            "oneOf": [
              {
                "const": "asc",
                "default": "desc"
              },
              {
                "const": "desc",
                "default": "desc"
              }
            ],
            "title": "order\n\nDetermines whether the first search result returned is the highest number of matches (desc) or lowest number of matches (asc).\nThis parameter is ignored unless you provide sort."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IGetFollowerOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Useridloginhtml_urlavatar_url"
            },
            "title": "followers"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "MyPickIGithub.Useridloginhtml_urlavatar_url": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "title": "id\n\nThis means the user's ID."
          },
          "login": {
            "type": "string",
            "title": "login\n\nThis means the user's nickname.\nIn github, nicknames are unique at least until that user changes their own nickname.\nThis means that only one person can own the nickname at a time.\nTherefore, it may be important to know the exact nickname because the github API calls the appi using the user's nickname."
          },
          "html_url": {
            "type": "string",
            "format": "iri",
            "title": "html_url\n\nIf you want to look up your profile, you can access this website."
          },
          "avatar_url": {
            "type": "string",
            "format": "iri",
            "title": "avatar url\n\nThis means the user's profile image."
          }
        },
        "required": [
          "id",
          "login",
          "html_url",
          "avatar_url"
        ]
      },
      "IGithub.IGetFollowerInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "order": {
            "oneOf": [
              {
                "const": "asc",
                "default": "desc"
              },
              {
                "const": "desc",
                "default": "desc"
              }
            ],
            "title": "order\n\nDetermines whether the first search result returned is the highest number of matches (desc) or lowest number of matches (asc).\nThis parameter is ignored unless you provide sort."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetFolloweeOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.Useridloginhtml_urlavatar_url"
            },
            "title": "followees"
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.IGetFolloweeInput": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string",
            "title": "user's nickname"
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "order": {
            "oneOf": [
              {
                "const": "asc",
                "default": "desc"
              },
              {
                "const": "desc",
                "default": "desc"
              }
            ],
            "title": "order\n\nDetermines whether the first search result returned is the highest number of matches (desc) or lowest number of matches (asc).\nThis parameter is ignored unless you provide sort."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "user"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "username",
          "secretKey"
        ]
      },
      "IGithub.IGetLabelOutput": {
        "type": "object",
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IGithub.Label"
            }
          },
          "nextPage": {
            "type": "boolean",
            "title": "true if there is a next page\n\nHowever, since true and false are judged by comparing the number of requested objects with the number of searched objects,\neven if true, the next page may be empty."
          },
          "after": {
            "type": "string",
            "title": "after\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the next page."
          },
          "before": {
            "type": "string",
            "title": "before\n\nIf this is the response value for cursor-based pagenation, it provides a hash code for the previous page."
          },
          "prev": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "prev\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the previous page."
          },
          "next": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ],
            "title": "next\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the next page."
          },
          "last": {
            "type": "number",
            "title": "last\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the last page."
          },
          "first": {
            "type": "number",
            "title": "first\n\nIf this is a response by offset-based pagenation, provide metadata for the next page.\nThis means the first page."
          }
        },
        "required": [
          "result",
          "nextPage"
        ]
      },
      "IGithub.Label": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "label name"
          },
          "color": {
            "type": "string",
            "title": "color"
          },
          "default": {
            "type": "boolean",
            "title": "default\n\nTrue if it is not created by the user but automatically created from the beginning."
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "description"
          }
        },
        "required": [
          "name",
          "color",
          "default",
          "description"
        ]
      },
      "IGithub.IGetLabelInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "page": {
            "type": "integer",
            "default": 1,
            "title": "page\nThe page number of the results to fetch."
          },
          "per_page": {
            "type": "integer",
            "default": 30,
            "maximum": 100,
            "title": "per_page\nThe number of results per page (max 100)."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "secretKey"
        ]
      },
      "IGithub.IUpdateIssueInput": {
        "type": "object",
        "properties": {
          "issue_number": {
            "oneOf": [
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/github/issues",
                  "jmesPath": "{label:number, value:title}"
                }
              },
              {
                "type": "integer",
                "minimum": 1,
                "x-wrtn-prerequisite": {
                  "method": "post",
                  "path": "/connector/github/issues",
                  "jmesPath": "result[].{label:number, value:title}"
                }
              }
            ],
            "title": "issue number to update"
          },
          "title": {
            "type": "string",
            "title": "tite of this issue"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          },
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "body": {
            "type": "string",
            "title": "body of this issue\n\nIt can be markdown format\nIf you provide text in utf-8 format, which can be recognized by a person, in markdown format, it will be written as it is."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "assignees": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/github/repos/get-collaborators",
                "jmesPath": "result[].{value:login, label:login}"
              }
            },
            "title": "assignees\n\nDeliver the user nickname to be designated as the person in charge in the array."
          }
        },
        "required": [
          "issue_number",
          "secretKey",
          "owner",
          "repo"
        ]
      },
      "IGithub.ICreateIssueInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "title": "user's nickname"
          },
          "repo": {
            "type": "string",
            "title": "The name of the repository"
          },
          "title": {
            "type": "string",
            "title": "tite of this issue"
          },
          "body": {
            "type": "string",
            "title": "body of this issue\n\nIt can be markdown format\nIf you provide text in utf-8 format, which can be recognized by a person, in markdown format, it will be written as it is."
          },
          "assignees": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/github/repos/get-collaborators",
                "jmesPath": "result[].{value:login, label:login}"
              }
            },
            "title": "assignees\n\nDeliver the user nickname to be designated as the person in charge in the array."
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "labels"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "github",
            "x-wrtn-secret-scopes": [
              "repo"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "repo",
          "title",
          "secretKey"
        ]
      },
      "IGithub.UploadFileInput": {
        "type": "object",
        "properties": {
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MyPickIGithub.RepositoryFilecontentpath"
            }
          },
          "key": {
            "type": "string"
          }
        },
        "required": [
          "files",
          "key"
        ]
      },
      "MyPickIGithub.RepositoryFilecontentpath": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "title": "content"
          },
          "path": {
            "type": "string",
            "title": "path\n\nIt must be unique as a path for identifying that file in the root folder."
          }
        },
        "required": [
          "content",
          "path"
        ]
      },
      "IShortLink.IResponse": {
        "type": "object",
        "properties": {}
      },
      "IShortLink.IRequest": {
        "type": "object",
        "properties": {}
      },
      "IDiscord.IChannel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "type": {
            "type": "number"
          },
          "guild_id": {
            "type": "string"
          },
          "position": {
            "type": "number"
          },
          "permission_overwrites": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IOverwrite"
            }
          },
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "topic": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "recipients": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IUser"
            }
          },
          "icon": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "owner_id": {
            "type": "string"
          },
          "application_id": {
            "type": "string"
          },
          "managed": {
            "type": "boolean"
          },
          "parent_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "last_pin_timestamp": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ]
          },
          "rtc_region": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "video_quality_mode": {
            "type": "number"
          },
          "message_count": {
            "type": "number"
          },
          "member_count": {
            "type": "number"
          },
          "thread_metadata": {
            "$ref": "#/components/schemas/IDiscord.IThreadMetadata"
          },
          "member": {
            "$ref": "#/components/schemas/IDiscord.IThreadMember"
          },
          "default_auto_archive_duration": {
            "type": "number"
          },
          "permissions": {
            "type": "string"
          },
          "flags": {
            "type": "number"
          },
          "total_message_sent": {
            "type": "number"
          },
          "available_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.ITag"
            }
          },
          "applied_tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "default_reaction_emoji": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IDiscord.IDefaultReaction"
              }
            ]
          },
          "default_thread_rate_limit_per_user": {
            "type": "number"
          },
          "default_sort_order": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ]
          },
          "default_forum_layout": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "type"
        ],
        "title": "채널 정보"
      },
      "IDiscord.IOverwrite": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "type": {
            "type": "number"
          },
          "allow": {
            "type": "string"
          },
          "deny": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "type",
          "allow",
          "deny"
        ]
      },
      "IDiscord.IUser": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "유저 고유 id",
            "description": "유저마다 발급된 고유 id 입니다."
          },
          "username": {
            "type": "string",
            "title": "유저 이름",
            "description": "유저 이름입니다."
          },
          "discriminator": {
            "type": "string",
            "title": "유저의 discord tag 입니다",
            "description": "유저의 discord tag 입니다."
          },
          "global_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "유저가 설정한 이름",
            "description": "유저가 설정한 이름입니다. 봇 유저는 어플리케이션 이름이 됩니다."
          },
          "bot": {
            "type": "boolean",
            "title": "봇 유저 여부",
            "description": "봇 유저 여부입니다."
          },
          "email": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "이메일",
            "description": "유저 이메일입니다."
          }
        },
        "required": [
          "id",
          "username",
          "discriminator",
          "global_name"
        ],
        "title": "유저 정보"
      },
      "IDiscord.IThreadMetadata": {
        "type": "object",
        "properties": {
          "archived": {
            "type": "boolean"
          },
          "auto_archive_duration": {
            "type": "number"
          },
          "archive_timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "locked": {
            "type": "boolean"
          },
          "invitable": {
            "type": "boolean"
          },
          "create_timestamp": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ]
          }
        },
        "required": [
          "archived",
          "auto_archive_duration",
          "archive_timestamp",
          "locked"
        ]
      },
      "IDiscord.IThreadMember": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "user_id": {
            "type": "string"
          },
          "join_timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "flags": {
            "type": "number"
          },
          "member": {
            "$ref": "#/components/schemas/IDiscord.IGuildMember"
          }
        },
        "required": [
          "join_timestamp",
          "flags"
        ]
      },
      "IDiscord.IGuildMember": {
        "type": "object",
        "properties": {
          "user": {
            "$ref": "#/components/schemas/IDiscord.IUser"
          },
          "nick": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "avatar": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "joined_at": {
            "type": "string",
            "format": "date-time"
          },
          "premium_since": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ]
          },
          "deaf": {
            "type": "boolean"
          },
          "mute": {
            "type": "boolean"
          },
          "flags": {
            "type": "number"
          },
          "pending": {
            "type": "boolean"
          },
          "permissions": {
            "type": "string"
          },
          "communication_disabled_until": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ]
          },
          "avatar_decoration_data": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/IDiscord.IAvatarDecorationData"
              }
            ]
          }
        },
        "required": [
          "roles",
          "joined_at",
          "deaf",
          "mute",
          "flags"
        ],
        "title": "서버에 있는 멤버 정보"
      },
      "IDiscord.IAvatarDecorationData": {
        "type": "object",
        "properties": {
          "asset": {
            "type": "string"
          },
          "sku_id": {
            "type": "string"
          }
        },
        "required": [
          "asset",
          "sku_id"
        ]
      },
      "IDiscord.ITag": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "moderated": {
            "type": "boolean"
          },
          "emoji_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "emoji_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "id",
          "name",
          "moderated",
          "emoji_id",
          "emoji_name"
        ]
      },
      "IDiscord.IDefaultReaction": {
        "type": "object",
        "properties": {
          "emoji_id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "emoji_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "emoji_id",
          "emoji_name"
        ]
      },
      "IDiscord.ICreateDMRequest": {
        "type": "object",
        "properties": {
          "recipient_id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/discord/get-list-guild-members",
              "jmesPath": "[].{value:user.id, label:user.username}"
            },
            "title": "상대방",
            "description": "DM을 보낼 상대방을 선택해주세요."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "discord",
            "x-wrtn-secret-scopes": [
              "bot"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "recipient_id",
          "secretKey"
        ],
        "title": "DM을 보내기 위해 필요한 정보"
      },
      "IDiscord.IGuild": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "owner": {
            "type": "boolean"
          },
          "owner_id": {
            "type": "string"
          },
          "roles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IRole"
            }
          },
          "features": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "const": "ANIMATED_BANNER"
                },
                {
                  "const": "ANIMATED_ICON"
                },
                {
                  "const": "APPLICATION_COMMAND_PERMISSIONS_V2"
                },
                {
                  "const": "AUTO_MODERATION"
                },
                {
                  "const": "BANNER"
                },
                {
                  "const": "COMMUNITY"
                },
                {
                  "const": "CREATOR_MONETIZABLE_PROVISIONAL"
                },
                {
                  "const": "CREATOR_STORE_PAGE"
                },
                {
                  "const": "DEVELOPER_SUPPORT_SERVER"
                },
                {
                  "const": "DISCOVERABLE"
                },
                {
                  "const": "FEATURABLE"
                },
                {
                  "const": "INVITES_DISABLED"
                },
                {
                  "const": "INVITE_SPLASH"
                },
                {
                  "const": "MEMBER_VERIFICATION_GATE_ENABLED"
                },
                {
                  "const": "MORE_STICKERS"
                },
                {
                  "const": "NEWS"
                },
                {
                  "const": "PARTNERED"
                },
                {
                  "const": "PREVIEW_ENABLED"
                },
                {
                  "const": "RAID_ALERTS_DISABLED"
                },
                {
                  "const": "ROLE_ICONS"
                },
                {
                  "const": "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE"
                },
                {
                  "const": "ROLE_SUBSCRIPTIONS_ENABLED"
                },
                {
                  "const": "TICKETED_EVENTS_ENABLED"
                },
                {
                  "const": "VANITY_URL"
                },
                {
                  "const": "VERIFIED"
                },
                {
                  "const": "VIP_REGIONS"
                },
                {
                  "const": "WELCOME_SCREEN_ENABLED"
                }
              ]
            }
          },
          "description": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "id",
          "name",
          "features"
        ],
        "title": "서버 정보"
      },
      "IDiscord.IRole": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "color": {
            "type": "number"
          },
          "hoist": {
            "type": "boolean"
          },
          "icon": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "unicode_emoji": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "position": {
            "type": "number"
          },
          "permissions": {
            "type": "string"
          },
          "managed": {
            "type": "boolean"
          },
          "mentionable": {
            "type": "boolean"
          },
          "tags": {
            "$ref": "#/components/schemas/IDiscord.ITags"
          },
          "flags": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "name",
          "color",
          "hoist",
          "position",
          "permissions",
          "managed",
          "mentionable",
          "flags"
        ]
      },
      "IDiscord.ITags": {
        "type": "object",
        "properties": {
          "bot_id": {
            "type": "string"
          },
          "integration_id": {
            "type": "string"
          },
          "premium_subscriber": {
            "type": "null"
          },
          "subscription_listing_id": {
            "type": "number"
          },
          "available_for_purchase": {
            "type": "null"
          },
          "guild_connections": {
            "type": "null"
          }
        }
      },
      "IDiscord.IModifyGuildRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "수정할 이름",
            "description": "수정할 서버 이름을 입력해주세요."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "discord",
            "x-wrtn-secret-scopes": [
              "bot"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "secretKey"
        ],
        "title": "서버 정보를 수정하기 위해 필요한 정보"
      },
      "IDiscord.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "discord",
            "x-wrtn-secret-scopes": [
              "bot"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "IDiscord.ICreateGuildChannelRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 100,
            "title": "채널 이름",
            "description": "생성할 서버 이름을 입력해주세요."
          },
          "type": {
            "oneOf": [
              {
                "const": 0,
                "title": "텍스트 채널"
              },
              {
                "const": 1,
                "title": "DM 채널"
              }
            ],
            "title": "유형",
            "description": "서버 유형을 선택해주세요."
          },
          "topic": {
            "type": "string",
            "maxLength": 1024,
            "title": "주제",
            "description": "채널 주제를 입력해주세요."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "discord",
            "x-wrtn-secret-scopes": [
              "bot"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "type",
          "secretKey"
        ],
        "title": "채널을 생성하기 위해 필요한 정보"
      },
      "IDiscord.IRemoveGuildMember": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/discord/get-list-guild-members",
              "jmesPath": "[].{value:user.id, label:user.username}"
            },
            "title": "멤버",
            "description": "차단할 멤버를 선택해주세요."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "discord",
            "x-wrtn-secret-scopes": [
              "bot"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "userId",
          "secretKey"
        ],
        "title": "멤버를 차단 하기 위해 필요한 정보"
      },
      "IDiscord.IModifyChannelRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "수정할 채널 이름",
            "description": "수정할 채널 이름을 입력해주세요."
          },
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "수정할 채널을 선택해주세요."
          }
        },
        "required": [
          "name",
          "channelId"
        ],
        "title": "채널을 수정하기 위해 필요한 정보"
      },
      "IDiscord.IDeleteChannelRequest": {
        "type": "object",
        "properties": {
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "삭제할 채널을 선택해주세요."
          }
        },
        "required": [
          "channelId"
        ],
        "title": "채널을 삭제하기 위해 필요한 정보"
      },
      "IDiscord.IMessage": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "channel_id": {
            "type": "string"
          },
          "author": {
            "$ref": "#/components/schemas/IDiscord.IUser"
          },
          "content": {
            "type": "string"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "edited_timestamp": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ]
          },
          "tts": {
            "type": "boolean"
          },
          "mention_everyone": {
            "type": "boolean"
          },
          "mentions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IUser"
            }
          },
          "mention_channels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IChannelMention"
            }
          },
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IAttachment"
            }
          },
          "embeds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IEmbed"
            }
          },
          "reactions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IReaction"
            }
          },
          "pinned": {
            "type": "boolean"
          },
          "type": {
            "type": "integer",
            "minimum": 0,
            "maximum": 45
          },
          "thread": {
            "$ref": "#/components/schemas/IDiscord.IChannel"
          }
        },
        "required": [
          "id",
          "channel_id",
          "author",
          "content",
          "timestamp",
          "tts",
          "mention_everyone",
          "mentions",
          "attachments",
          "embeds",
          "pinned",
          "type"
        ],
        "title": "메세지 정보"
      },
      "IDiscord.IChannelMention": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "guild_id": {
            "type": "string"
          },
          "type": {
            "oneOf": [
              {
                "const": 0,
                "title": "텍스트 채널"
              },
              {
                "const": 1,
                "title": "DM 채널"
              }
            ]
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "guild_id",
          "type",
          "name"
        ]
      },
      "IDiscord.IAttachment": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "filename": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "conetnt_type": {
            "type": "string"
          },
          "size": {
            "type": "number"
          },
          "url": {
            "type": "string"
          },
          "proxy_url": {
            "type": "string"
          },
          "height": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ]
          },
          "width": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "number"
              }
            ]
          },
          "ephemeral": {
            "type": "boolean"
          },
          "duration_secs": {
            "type": "number"
          },
          "waveform": {
            "type": "string"
          },
          "flags": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "filename",
          "size",
          "url",
          "proxy_url"
        ]
      },
      "IDiscord.IEmbed": {
        "type": "object",
        "properties": {
          "title": {
            "type": "string"
          },
          "type": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "url": {
            "type": "string"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "color": {
            "type": "number"
          },
          "footer": {
            "$ref": "#/components/schemas/IDiscord.IEmbedFooter"
          },
          "image": {
            "$ref": "#/components/schemas/IDiscord.IEmbedImage"
          },
          "thumbnail": {
            "$ref": "#/components/schemas/IDiscord.IEmbedThumbnail"
          },
          "video": {
            "$ref": "#/components/schemas/IDiscord.IEmbedVideo"
          },
          "provider": {
            "$ref": "#/components/schemas/IDiscord.IEmbedProvider"
          },
          "author": {
            "$ref": "#/components/schemas/IDiscord.IEmbedAuthor"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IDiscord.IEmbedField"
            }
          }
        }
      },
      "IDiscord.IEmbedFooter": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string"
          },
          "icon_url": {
            "type": "string"
          },
          "proxy_icon_url": {
            "type": "string"
          }
        },
        "required": [
          "text"
        ]
      },
      "IDiscord.IEmbedImage": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string"
          },
          "proxy_url": {
            "type": "string"
          },
          "height": {
            "type": "number"
          },
          "width": {
            "type": "number"
          }
        },
        "required": [
          "url"
        ]
      },
      "IDiscord.IEmbedThumbnail": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string"
          },
          "proxy_url": {
            "type": "string"
          },
          "height": {
            "type": "number"
          },
          "width": {
            "type": "number"
          }
        },
        "required": [
          "url"
        ]
      },
      "IDiscord.IEmbedVideo": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string"
          },
          "proxy_url": {
            "type": "string"
          },
          "height": {
            "type": "number"
          },
          "width": {
            "type": "number"
          }
        }
      },
      "IDiscord.IEmbedProvider": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "IDiscord.IEmbedAuthor": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "url": {
            "type": "string"
          },
          "icon_url": {
            "type": "string"
          },
          "proxy_icon_url": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "IDiscord.IEmbedField": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "inline": {
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "IDiscord.IReaction": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "count_details": {
            "$ref": "#/components/schemas/IDiscord.IReactionCountDetails"
          },
          "me": {
            "type": "boolean"
          },
          "me_burst": {
            "type": "boolean"
          },
          "emoji": {
            "$ref": "#/components/schemas/PartialIDiscord.IEmoji"
          },
          "burst_colors": {
            "type": "array",
            "prefixItems": [],
            "additionalItems": false
          }
        },
        "required": [
          "count",
          "count_details",
          "me",
          "me_burst",
          "emoji",
          "burst_colors"
        ]
      },
      "IDiscord.IReactionCountDetails": {
        "type": "object",
        "properties": {
          "burst": {
            "type": "number"
          },
          "normal": {
            "type": "number"
          }
        },
        "required": [
          "burst",
          "normal"
        ]
      },
      "PartialIDiscord.IEmoji": {
        "type": "object",
        "properties": {
          "id": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ]
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "user": {
            "$ref": "#/components/schemas/IDiscord.IUser"
          },
          "require_colons": {
            "type": "boolean"
          },
          "managed": {
            "type": "boolean"
          },
          "animated": {
            "type": "boolean"
          },
          "available": {
            "type": "boolean"
          }
        },
        "description": "Make all properties in T optional"
      },
      "IDiscord.IGetPinnedMessagesRequest": {
        "type": "object",
        "properties": {
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "고정된 메세지를 가져올 채널을 선택해주세요."
          }
        },
        "required": [
          "channelId"
        ],
        "title": "고정된 메세지를 가져오기 위해 필요한 정보"
      },
      "IDiscord.IPinOrUnpinMessagesRequest": {
        "type": "object",
        "properties": {
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "메세지를 고정 또는 고정 해제할 채널을 선택해주세요."
          },
          "messageId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/discord/get-channel-message-histories",
              "jmesPath": "[].{value:id, label:content}"
            },
            "title": "메세지",
            "description": "고정 또는 고정 해제할 메세지를 선택해주세요."
          }
        },
        "required": [
          "channelId",
          "messageId"
        ],
        "title": "메세지를 고정 또는 고정 해제하기 위해 필요한 정보"
      },
      "IDiscord.IGetChannelMessageHistoriesRequest": {
        "type": "object",
        "properties": {
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "메세지 목록을 가져올 채널을 선택해주세요."
          }
        },
        "required": [
          "channelId"
        ],
        "title": "채널의 메세지 목록을 가져오기 위해 필요한 정보"
      },
      "IDiscord.ICreateMessageRequest": {
        "type": "object",
        "properties": {
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "메세지를 생성할 채널을 선택해주세요."
          },
          "content": {
            "type": "string",
            "title": "메세지 내용",
            "description": "메세지 내용을 입력해주세요."
          }
        },
        "required": [
          "channelId",
          "content"
        ],
        "title": "메세지를 생성하기 위해 필요한 정보"
      },
      "IDiscord.IEditMessageRequest": {
        "type": "object",
        "properties": {
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "메세지를 수정할 채널을 선택해주세요."
          },
          "messageId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/discord/get-channel-message-histories",
              "jmesPath": "[].{value:id, label:content}"
            },
            "title": "수정할 메세지",
            "description": "수정할 메세지를 선택해주세요."
          },
          "content": {
            "type": "string",
            "title": "수정할 내용",
            "description": "수정할 내용을 입력해주세요."
          }
        },
        "required": [
          "channelId",
          "messageId",
          "content"
        ],
        "title": "메세지 수정하기 위해 필요한 정보"
      },
      "IDiscord.IDeleteMessageRequest": {
        "type": "object",
        "properties": {
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "메세지를 삭제할 채널을 선택해주세요."
          },
          "messageId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/discord/get-channel-message-histories",
              "jmesPath": "[].{value:id, label:content}"
            },
            "title": "삭제할 메세지",
            "description": "삭제할 메세지를 선택해주세요"
          }
        },
        "required": [
          "channelId",
          "messageId"
        ],
        "title": "메세지 삭제하기 위해 필요한 정보"
      },
      "IDiscord.IBulkDeleteMessagesRequest": {
        "type": "object",
        "properties": {
          "channelId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/discord/get-guild-channels",
              "jmesPath": "[].{value:id, label:name}"
            },
            "title": "채널",
            "description": "메세지를 삭제할 채널을 선택해주세요."
          },
          "messages": {
            "type": "array",
            "items": {
              "type": "string",
              "x-wrtn-prerequisite": {
                "method": "post",
                "path": "/connector/discord/get-channel-message-histories",
                "jmesPath": "[].{value:id, label:content}"
              }
            },
            "title": "삭제할 메세지들",
            "description": "삭제할 메세지들을 선택해주세요"
          }
        },
        "required": [
          "channelId",
          "messages"
        ],
        "title": "여러 개의 메세지를 한꺼번에 삭제하기 위해 필요한 정보"
      },
      "ICalendly.CreateSchedulingLinkOutput": {
        "type": "object",
        "properties": {
          "resource": {
            "type": "object",
            "properties": {
              "booking_url": {
                "type": "string",
                "format": "iri",
                "title": "Scheduling link url"
              },
              "owner": {
                "type": "string",
                "format": "iri",
                "title": "owner\nA link to the resource that owns this Scheduling Link (currently, this is always an Event Type)"
              },
              "owner_type": {
                "const": "EventType",
                "title": "owner_type\nResource type (currently, this is always EventType)"
              }
            },
            "required": [
              "booking_url",
              "owner",
              "owner_type"
            ]
          }
        },
        "required": [
          "resource"
        ]
      },
      "ICalendly.CreateSchedulingLinkInput": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "format": "iri"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "calendly",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "owner",
          "secretKey"
        ]
      },
      "ICalendly.IGetEventTypeOutput": {
        "type": "object",
        "properties": {
          "collection": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ICalendly.EventType"
            }
          },
          "pagination": {
            "$ref": "#/components/schemas/ICalendly.Pagination"
          }
        },
        "required": [
          "collection",
          "pagination"
        ]
      },
      "ICalendly.EventType": {
        "type": "object",
        "properties": {
          "uri": {
            "type": "string",
            "format": "iri",
            "title": "uri\nCanonical reference (unique identifier) for the event type.\nFor example, 'https://api.calendly.com/event_types/AAAAAAAAAAAAAAAA'"
          },
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "15 Minute Meeting"
              }
            ],
            "title": "name\nThe event type name (in human-readable format)"
          },
          "active": {
            "type": "boolean",
            "title": "active\nIndicates if the event is active or not."
          },
          "slug": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "acmesales"
              }
            ],
            "title": "slug\nThe portion of the event type's URL that identifies a specific web page (in a human-readable format)"
          },
          "scheduling_url": {
            "type": "string",
            "format": "uri",
            "x-wrtn-placeholder": "https://calendly.com/acmesales",
            "title": "schduling_url\nThe URL of the user’s scheduling site where invitees book this event type"
          },
          "duration": {
            "type": "integer",
            "x-wrtn-placeholder": "30",
            "title": "duration\nThe length of sessions booked with this event type"
          },
          "kind": {
            "oneOf": [
              {
                "const": "solo",
                "title": "solo"
              },
              {
                "const": "group",
                "title": "group"
              }
            ],
            "title": "kind\nIndicates if the event type is \"solo\" (belongs to an individual user) or \"group\""
          },
          "pooling_type": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "round_robin",
                "title": "round_robin"
              },
              {
                "const": "collective",
                "title": "collective"
              },
              {
                "const": "multi_pool",
                "title": "multi_pool"
              }
            ],
            "title": "pooling_type\nIndicates if the event type is \"round robin\" (alternates between hosts) or \"collective\" (invitees pick a time when all participants are available) or “multi-pool” (considers availability delineated by pools of participants) or \"null\" (the event type doesn’t consider the availability of a group participants)"
          },
          "type": {
            "oneOf": [
              {
                "const": "StandardEventType",
                "title": "StandardEventType"
              },
              {
                "const": "AdhocEventType",
                "title": "AdhocEventType"
              }
            ],
            "title": "type\nIndicates if the event type is \"AdhocEventType\" (ad hoc event) or \"StandardEventType\" (standard event type)"
          },
          "color": {
            "type": "string",
            "pattern": "^#([0-9A-Fa-f]{6})$",
            "x-wrtn-placeholder": "#fff200",
            "title": "color\nThe hexadecimal color value of the event type's scheduling page"
          },
          "created_at": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/Formatdate-time"
              }
            ],
            "title": "created_at\nThe moment the event type was created (e.g. \"2020-01-02T03:04:05.678123Z\")"
          },
          "updated_at": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/Formatdate-time"
              }
            ],
            "title": "updated_at\nThe moment the event type was last updated (e.g. \"2020-01-02T03:04:05.678123Z\")"
          },
          "internal_note": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "internal_note\nContents of a note that may be associated with the event type"
          },
          "description_plain": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "15 Minute Meeting"
              }
            ],
            "title": "description_plain\nThe event type's description (in non formatted text)"
          },
          "description_html": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "<p>15 Minute Meeting</p>"
              }
            ],
            "title": "description_html\nThe event type's description (formatted with HTML)"
          },
          "profile": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ICalendly.Profile"
              }
            ],
            "title": "profile\nThe publicly visible profile of a User or a Team that's associated with the Event Type (note: some Event Types don't have profiles)"
          },
          "secret": {
            "type": "boolean",
            "title": "secret\nIndicates if the event type is hidden on the owner's main scheduling page"
          },
          "booking_method": {
            "oneOf": [
              {
                "const": "instant",
                "title": "instant"
              },
              {
                "const": "poll",
                "title": "poll"
              }
            ],
            "title": "booking_method\nIndicates if the event type is for a poll or an instant booking"
          },
          "custom_questions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ICalendly.CustomQuestion"
            },
            "title": "custom_questions"
          },
          "deleted_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "deleted_at\nThe moment the event type was deleted (e.g. \"2020-01-02T03:04:05.678123Z\"). Since event types can be deleted but their scheduled events remain it's useful to fetch a deleted event type when you still require event type data for a scheduled event."
          },
          "admin_managed": {
            "type": "boolean",
            "title": "admin_managed\nIndicates if this event type is managed by an organization admin"
          },
          "locations": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ICalendly.Location"
                }
              }
            ],
            "title": "locations\nConfiguration information for each possible location for this Event Type"
          },
          "position": {
            "type": "number",
            "title": "position\nPosition order of Event Type, starting with 0 (for display purposes)"
          }
        },
        "required": [
          "uri",
          "name",
          "active",
          "slug",
          "scheduling_url",
          "duration",
          "kind",
          "pooling_type",
          "type",
          "color",
          "created_at",
          "updated_at",
          "internal_note",
          "description_plain",
          "description_html",
          "profile",
          "secret",
          "booking_method",
          "custom_questions",
          "deleted_at",
          "admin_managed",
          "locations",
          "position"
        ]
      },
      "Formatdate-time": {
        "type": "object",
        "properties": {
          "typia.tag": {
            "type": "object",
            "properties": {
              "target": {
                "const": "string"
              },
              "kind": {
                "const": "format"
              },
              "value": {
                "const": "date-time"
              },
              "validate": {
                "const": "/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(T|\\s)([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](?:\\.[0-9]{1,9})?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])$/i.test($input)"
              },
              "exclusive": {
                "type": "array",
                "prefixItems": [
                  {
                    "const": "format"
                  },
                  {
                    "const": "pattern"
                  }
                ],
                "additionalItems": false
              },
              "schema": {
                "type": "object",
                "properties": {
                  "format": {
                    "const": "date-time"
                  }
                },
                "required": [
                  "format"
                ]
              }
            },
            "required": [
              "target",
              "kind",
              "value",
              "validate",
              "exclusive",
              "schema"
            ],
            "title": "This is a dummy property for compilation",
            "description": "This is a dummy property for compilation.\n\nIt does not mean anything in runtime."
          }
        }
      },
      "ICalendly.Profile": {
        "type": "object",
        "properties": {
          "type": {
            "oneOf": [
              {
                "const": "User",
                "title": "User"
              },
              {
                "const": "Team",
                "title": "Team"
              }
            ],
            "title": "type\nIndicates if the profile belongs to a \"user\" (individual) or \"team\""
          },
          "name": {
            "type": "string",
            "x-wrtn-placeholder": "Tamara Jones",
            "title": "name\nHuman-readable name for the profile of the user that's associated with the event type"
          },
          "owner": {
            "type": "string",
            "format": "uri",
            "x-wrtn-placeholder": "https://api.calendly.com/users/AAAAAAAAAAAAAAAA",
            "title": "owner\nThe unique reference to the user associated with the profile"
          }
        },
        "required": [
          "type",
          "name",
          "owner"
        ]
      },
      "ICalendly.CustomQuestion": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "name\nThe custom question that the host created for the event type."
          },
          "type": {
            "oneOf": [
              {
                "const": "text",
                "title": "text"
              },
              {
                "const": "phone_number",
                "title": "phone_number"
              },
              {
                "const": "single_select",
                "title": "single_select"
              },
              {
                "const": "multi_select",
                "title": "multi_select"
              }
            ],
            "title": "type\nThe type of response that the invitee provides to the custom question; can be one or multiple lines of text, a phone number, or single- or multiple-select."
          },
          "position": {
            "type": "number",
            "title": "position\nThe numerical position of the question on the event booking page after the name and email address fields."
          },
          "enabled": {
            "type": "boolean",
            "title": "enabled\ntrue if the question created by the host is turned ON and visible on the event booking page; false if turned OFF and invisible on the event booking page."
          },
          "required": {
            "type": "boolean",
            "title": "required\ntrue if a response to the question created by the host is required for invitees to book the event type; false if not required."
          },
          "answer_choices": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "answer_choices\nThe invitee’s option(s) for single_select or multi_select type of responses."
          },
          "include_other": {
            "type": "boolean",
            "title": "include_other\ntrue if the custom question lets invitees record a written response in addition to single-select or multiple-select type of responses; false if it doesn’t."
          }
        },
        "required": [
          "name",
          "type",
          "position",
          "enabled",
          "required",
          "answer_choices",
          "include_other"
        ]
      },
      "ICalendly.Location": {
        "type": "object",
        "properties": {
          "kind": {
            "type": "string",
            "title": "kind"
          },
          "phone_number": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ],
            "title": "phone_number"
          },
          "additional_info": {
            "type": "string",
            "title": "additional_info"
          }
        },
        "required": [
          "kind"
        ]
      },
      "ICalendly.Pagination": {
        "type": "object",
        "properties": {
          "count": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100,
            "x-wrtn-placeholder": "20",
            "title": "count\nThe number of rows to return"
          },
          "next_page": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "next_page\nURI to return the next page of an ordered list (\"null\" indicates no additional results are available)"
          },
          "previous_page": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "previous_page\nURI to return the previous page of an ordered list (\"null\" indicates no additional results are available)"
          },
          "next_page_token": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "next_page_token\nToken to return the next page of an ordered list (\"null\" indicates no additional results are available)"
          },
          "previous_page_token": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "previous_page_token\nToken to return the previous page of an ordered list (\"null\" indicates no additional results are available)"
          }
        },
        "required": [
          "count",
          "next_page",
          "previous_page",
          "next_page_token",
          "previous_page_token"
        ]
      },
      "ICalendly.IGetEventTypeInput": {
        "type": "object",
        "properties": {
          "admin_managed": {
            "type": "boolean",
            "title": "admin_managed\nReturn only admin managed event types if true, exclude admin managed event types if false, or include all event types if this parameter is omitted."
          },
          "organization": {
            "type": "string",
            "format": "iri",
            "title": "organization\nView available personal, team, and organization event types associated with the organization's URI.\nuser or organization must be filled."
          },
          "user": {
            "type": "string",
            "format": "iri",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/calendly/users/get-me",
              "jmesPath": "resource.{value:url, label:name}"
            },
            "title": "user\nView available personal, team, and organization event types associated with the user's URI.\nuser or organization must be filled."
          },
          "user_availability_schedule": {
            "type": "string",
            "format": "iri",
            "title": "user_availability_schedule"
          },
          "active": {
            "type": "boolean",
            "title": "active\nReturn only active event types if true, only inactive if false, or all event types if this parameter is omitted."
          },
          "count": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "title": "count\nThe number of rows to return"
          },
          "page_token": {
            "type": "string",
            "title": "page_token\nThe token to pass to get the next or previous portion of the collection."
          },
          "sort": {
            "oneOf": [
              {
                "const": "name:asc",
                "title": "이름 정순 정렬"
              },
              {
                "const": "name:desc",
                "title": "이름 역순 정렬"
              },
              {
                "const": "position:asc",
                "title": "위치 정순 정렬"
              },
              {
                "const": "position:desc",
                "title": "위치 역순 정렬"
              },
              {
                "const": "created_at:asc",
                "title": "생성일자 정순 정렬"
              },
              {
                "const": "created_at:desc",
                "title": "생성일자 역순 정렬"
              },
              {
                "const": "updated_at:asc",
                "title": "수정일자 정순 정렬"
              },
              {
                "const": "updated_at:desc",
                "title": "수정일자 역순 정렬"
              }
            ],
            "title": "sort\nOrder results by the specified field and direction. Accepts comma-separated list of {field}:{direction} values.\nSupported fields are: name, position, created_at, updated_at. Sort direction is specified as: asc, desc.\nIt must be one of: 'name:asc', 'name:desc', 'position:asc', 'position:desc', 'created_at:asc', 'created_at:desc', 'updated_at:asc', 'updated_at:desc'."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "calendly",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ICalendly.Secret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "calendly",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ICalendly.IGetOneScheduledEventOutput": {
        "type": "object",
        "properties": {
          "resource": {
            "$ref": "#/components/schemas/ICalendly.Event",
            "title": "event"
          }
        },
        "required": [
          "resource"
        ]
      },
      "ICalendly.Event": {
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "title": "uuid\nuuid from url (ex. \"https://api.calendly.com/scheduled_events/:uuid\" )"
          },
          "uri": {
            "type": "string",
            "format": "iri",
            "title": "uri\nCanonical reference (unique identifier) for the resource"
          },
          "name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "15 Minute Meeting"
              }
            ],
            "title": "name\nThe event name"
          },
          "meeting_notes_plain": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "x-wrtn-placeholder": "15 Minute Meeting"
              }
            ],
            "title": "meeting_notes_plain\nThe internal meeting notes (in non formatted text)"
          },
          "meeting_notes_html": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "meeting_notes_html\nThe internal meeting notes (formatted with HTML)"
          },
          "status": {
            "oneOf": [
              {
                "const": "active",
                "title": "active"
              },
              {
                "const": "canceled",
                "title": "canceled"
              }
            ],
            "title": "status\nIndicates if the event is \"active\" or \"canceled\""
          },
          "start_time": {
            "type": "string",
            "format": "date-time",
            "title": "start_time\nThe moment the event was scheduled to start in UTC time"
          },
          "end_time": {
            "type": "string",
            "format": "date-time",
            "title": "end_time\nThe moment the event was scheduled to end in UTC time"
          },
          "event_type": {
            "type": "string",
            "format": "iri",
            "title": "event_type\nEvent Type URI"
          },
          "location": {
            "type": "object",
            "properties": {
              "type": {
                "oneOf": [
                  {
                    "const": "physical"
                  },
                  {
                    "const": "custom"
                  }
                ],
                "title": "type\nIndicates that the event will be an in-person meeting."
              },
              "location": {
                "type": "string",
                "title": "location\nThe physical location specified by the event host (publisher)"
              },
              "additional_info": {
                "type": "string",
                "title": "additional_info\n추가 정보"
              }
            },
            "required": [
              "type",
              "location"
            ],
            "title": "location\nThe event type associated with this event"
          },
          "invitees_counter": {
            "type": "object",
            "properties": {
              "total": {
                "type": "integer",
                "title": "total\nTotal invitees for an event, including invitees that have canceled"
              },
              "active": {
                "type": "integer",
                "title": "active\nTotal invitees for an event that have not canceled"
              },
              "limit": {
                "type": "integer",
                "title": "limit\nMaximum number of active invitees that can book the event"
              }
            },
            "required": [
              "total",
              "active",
              "limit"
            ],
            "title": "invitees_counter\nInvitees counter"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at\nThe moment when the event was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at\nThe moment when the event was last updated"
          },
          "event_memberships": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "user": {
                  "type": "string",
                  "format": "iri",
                  "title": "user\nCanonical reference (unique identifier) for the user"
                },
                "user_email": {
                  "type": "string",
                  "format": "email",
                  "title": "user_email\nThe user's email"
                },
                "user_name": {
                  "type": "string",
                  "x-wrtn-placeholder": "John Smith",
                  "title": "user_name\nThe user's name"
                },
                "buffered_start_time": {
                  "type": "string",
                  "format": "date-time",
                  "title": "buffered_start_time\nThe moment the membership's time buffer starts for the event in UTC time"
                },
                "buffered_end_time": {
                  "type": "string",
                  "format": "date-time",
                  "title": "buffered_end_time\nThe moment the membership's time buffer ends for the event in UTC time"
                }
              },
              "required": [
                "user",
                "user_email",
                "user_name",
                "buffered_start_time",
                "buffered_end_time"
              ]
            },
            "title": "event_memberships\nEvent Membership List"
          },
          "event_guests": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "email": {
                  "type": "string",
                  "format": "email",
                  "title": "email"
                },
                "created_at": {
                  "type": "string",
                  "format": "date-time",
                  "title": "created_at"
                },
                "updated_at": {
                  "type": "string",
                  "format": "date-time",
                  "title": "updated_at"
                }
              },
              "required": [
                "email",
                "created_at",
                "updated_at"
              ]
            },
            "title": "event_guests\nAdditional people added to an event by an invitee"
          },
          "cancellation": {
            "$ref": "#/components/schemas/ICalendly.Cancellation",
            "title": "cancellation\nInformation about the calendar event from the calendar provider."
          }
        },
        "required": [
          "uuid",
          "uri",
          "name",
          "meeting_notes_plain",
          "meeting_notes_html",
          "status",
          "start_time",
          "end_time",
          "event_type",
          "location",
          "invitees_counter",
          "created_at",
          "updated_at",
          "event_memberships",
          "event_guests"
        ]
      },
      "ICalendly.Cancellation": {
        "type": "object",
        "properties": {
          "canceled_by": {
            "type": "string",
            "title": "canceled_by\nName of the person whom canceled"
          },
          "reason": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "reason\nReason that the cancellation occurred"
          },
          "canceler_type": {
            "oneOf": [
              {
                "const": "host",
                "title": "host"
              },
              {
                "const": "invitee",
                "title": "invitee"
              }
            ],
            "title": "canceler_type"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at\nThe moment when the cancellation was created"
          }
        },
        "required": [
          "canceled_by",
          "reason",
          "canceler_type",
          "created_at"
        ]
      },
      "ICalendly.IGetScheduledEventOutput": {
        "type": "object",
        "properties": {
          "collection": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ICalendly.Event"
            }
          },
          "pagination": {
            "$ref": "#/components/schemas/ICalendly.Pagination"
          }
        },
        "required": [
          "collection",
          "pagination"
        ]
      },
      "ICalendly.IGetScheduledEventInput": {
        "type": "object",
        "properties": {
          "count": {
            "type": "integer",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "title": "count\nThe number of rows to return."
          },
          "who": {
            "oneOf": [
              {
                "type": "object",
                "properties": {
                  "user": {
                    "type": "string",
                    "format": "iri",
                    "title": "user\nReturn events that are scheduled with the user associated with this URI.\nThere must be either a user or a group."
                  },
                  "group": {
                    "type": "string",
                    "format": "iri",
                    "title": "group\nReturn events that are scheduled with the group associated with this URI.\nThere must be either a user or a group."
                  }
                },
                "required": [
                  "user",
                  "group"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "user": {
                    "type": "string",
                    "format": "iri",
                    "title": "user\nReturn events that are scheduled with the user associated with this URI.\nThere must be either a user or a group."
                  },
                  "group": {
                    "type": "string",
                    "format": "iri",
                    "title": "group\nReturn events that are scheduled with the group associated with this URI.\nThere must be either a user or a group."
                  }
                },
                "required": [
                  "user",
                  "group"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "user": {
                    "type": "string",
                    "format": "iri",
                    "title": "user\nReturn events that are scheduled with the user associated with this URI.\nThere must be either a user or a group."
                  }
                },
                "required": [
                  "user"
                ]
              }
            ],
            "title": "Whose event is it?\n\n- If you are an administrator/owner of an organization, you can use both and to get a list of events for a specific user within an organization user.\n- If you are the administrator/owner of an organization, you can use both and to get a list of events for a specific group within an organization group.\n- User Only available for requesting private events; events within all organizations that are currently or previously affiliated are returned."
          },
          "organization": {
            "type": "string",
            "format": "iri",
            "title": "organization\nReturn events that are scheduled with the organization associated with this URI."
          },
          "invitee_email": {
            "type": "string",
            "format": "email",
            "title": "invitee_email\nReturn events that are scheduled with the invitee associated with this email address."
          },
          "max_start_time": {
            "type": "string",
            "format": "date-time",
            "title": "max_start_time\nInclude events with start times prior to this time. This time should use the UTC timezone."
          },
          "min_start_time": {
            "type": "string",
            "format": "date-time",
            "title": "min_start_time\nInclude events with start times after this time. This time should use the UTC timezone."
          },
          "page_token": {
            "type": "string",
            "title": "page_token\nThe token to pass to get the next or previous portion of the collection."
          },
          "sort": {
            "oneOf": [
              {
                "const": "start_time:asc",
                "title": "시작 시간 정순 정렬"
              },
              {
                "const": "start_time:desc",
                "title": "시작 시간 역순 정렬"
              }
            ],
            "title": "sort\nOrder results by the specified field and direction. Accepts comma-separated list of {field}:{direction} values.\nSupported fields are: start_time. Sort direction is specified as: asc, desc."
          },
          "status": {
            "oneOf": [
              {
                "const": "active",
                "title": "active"
              },
              {
                "const": "canceled",
                "title": "canceled"
              }
            ],
            "title": "status\nWhether the scheduled event is active or canceled.\nAllowed values: active, canceled."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "calendly",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "who",
          "secretKey"
        ],
        "title": "Conditions for querying scheduled events"
      },
      "ICalendly.ICheckNoShowOutput": {
        "type": "object",
        "properties": {
          "resource": {
            "$ref": "#/components/schemas/ICalendly.NoShow"
          }
        },
        "required": [
          "resource"
        ]
      },
      "ICalendly.NoShow": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "format": "iri",
            "title": "url\nCanonical reference (unique identifier) for the no show"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at\nThe moment when the no show was created"
          }
        },
        "required": [
          "url",
          "created_at"
        ]
      },
      "ICalendly.IGetOneScheduledEventInviteeOutput": {
        "type": "object",
        "properties": {
          "resource": {
            "$ref": "#/components/schemas/ICalendly.Invitee"
          }
        },
        "required": [
          "resource"
        ]
      },
      "ICalendly.Invitee": {
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "title": "uuid\nuuid from \"https://calendly.com/scheduled_events/AAAAAAAAAAAAAAAA/invitees/:uuid\""
          },
          "uri": {
            "type": "string",
            "format": "iri",
            "title": "uri\nCanonical reference (unique identifier) for the invitee"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "email\nThe invitee’s email address"
          },
          "first_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "first_name\nThe first name of the invitee who booked the event when the event type is configured to use separate fields for first name and last name. Null when event type is configured to use a single field for name."
          },
          "last_name": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "last_name\nThe last name of the invitee who booked the event when the event type is configured to use separate fields for first name and last name. Null when event type is configured to use a single field for name."
          },
          "name": {
            "type": "string",
            "title": "name\nThe invitee’s name (in human-readable format)"
          },
          "status": {
            "oneOf": [
              {
                "const": "active",
                "title": "active"
              },
              {
                "const": "canceled",
                "title": "canceled"
              }
            ],
            "title": "status\nIndicates if the invitee is \"active\" or \"canceled\""
          },
          "questions_and_answers": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "question": {
                  "type": "string",
                  "title": "question\nA question on the invitee's booking form"
                },
                "answer": {
                  "type": "string",
                  "title": "answer\nThe invitee's answer to the question"
                },
                "position": {
                  "type": "number",
                  "title": "position\nThe position of the question in relation to others on the booking form"
                }
              },
              "required": [
                "question",
                "answer",
                "position"
              ]
            },
            "title": "questions_and_answers\nA collection of the invitee's responses to questions on the event booking confirmation form"
          },
          "timezone": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "timezone\nTime zone to use when displaying time to the invitee"
          },
          "event": {
            "type": "string",
            "format": "iri",
            "title": "event\nA reference to the event"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at\nThe moment when the event was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at\nThe moment when the event was last updated"
          },
          "tracking": {
            "type": "object",
            "properties": {
              "utm_campaign": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "utm_campaign\nThe UTM parameter used to track a campaign"
              },
              "utm_source": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "utm_source\nThe UTM parameter that identifies the source (platform where the traffic originates)"
              },
              "utm_medium": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "utm_medium\nThe UTM parameter that identifies the type of input (e.g. CPC, social media, etc.)"
              },
              "utm_content": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "utm_content\nUTM content tracking parameter"
              },
              "utm_term": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "utm_term\nThe UTM parameter used to track keywords"
              },
              "salesforce_uuid": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "type": "string"
                  }
                ],
                "title": "salesforce_uuid\nThe Salesforce record unique identifier"
              }
            },
            "required": [
              "utm_campaign",
              "utm_source",
              "utm_medium",
              "utm_content",
              "utm_term",
              "salesforce_uuid"
            ],
            "title": "tracking\nThe UTM and Salesforce tracking parameters associated with an invitee"
          },
          "text_reminder_number": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "text_reminder_number\nThe phone number to use when sending text (SMS) reminders"
          },
          "rescheduled": {
            "type": "boolean",
            "title": "rescheduled\nIndicates if this invitee has rescheduled"
          },
          "old_invitee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "old_invitee\nReference to old Invitee instance that got rescheduled"
          },
          "new_invitee": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "new_invitee\nLink to new invitee after reschedule"
          },
          "cancel_url": {
            "type": "string",
            "format": "iri",
            "title": "cancel_url\nLink to cancelling the event for the invitee"
          },
          "reschedule_url": {
            "type": "string",
            "format": "iri",
            "title": "reschedule_url\nLink to rescheduling the event for the invitee"
          },
          "routing_form_submission": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "routing_form_submission\nReference to a routing form submission that redirected the invitee to a booking page."
          },
          "cancellation": {
            "$ref": "#/components/schemas/ICalendly.Cancellation",
            "title": "cancellation\nProvides data pertaining to the cancellation of the Event or the Invitee"
          },
          "payment": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ICalendly.Payment"
              }
            ],
            "title": "Invitee payment"
          },
          "no_show": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ICalendly.NoShow"
              }
            ],
            "title": "no_show\nProvides data pertaining to the associated no show for the Invitee"
          },
          "reconfirmation": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ICalendly.Reconfirmation"
              }
            ],
            "title": "reconfirmation\nAssuming reconfirmation is enabled for the event type, when reconfirmation is requested this object is present with a created_at that reflects when the reconfirmation notification was sent. Once the invitee has reconfirmed"
          },
          "scheduling_method": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "const": "instant_book",
                "title": "instant_book"
              }
            ],
            "title": "scheduling_method\nThe method used to schedule the event"
          },
          "invitee_scheduled_by": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "invitee_scheduled_by\nReference to user URI who scheduled the event"
          }
        },
        "required": [
          "uuid",
          "uri",
          "email",
          "first_name",
          "last_name",
          "name",
          "status",
          "questions_and_answers",
          "timezone",
          "event",
          "created_at",
          "updated_at",
          "tracking",
          "text_reminder_number",
          "rescheduled",
          "old_invitee",
          "new_invitee",
          "cancel_url",
          "reschedule_url",
          "routing_form_submission",
          "payment",
          "no_show",
          "reconfirmation",
          "scheduling_method",
          "invitee_scheduled_by"
        ]
      },
      "ICalendly.Payment": {
        "type": "object",
        "properties": {
          "external_id": {
            "type": "string",
            "title": "external_id\nUnique identifier for the payment"
          },
          "provider": {
            "type": "string",
            "title": "provider\nPayment provider"
          },
          "amount": {
            "type": "number",
            "title": "amount\nThe amount of the payment"
          },
          "currency": {
            "oneOf": [
              {
                "const": "AUD",
                "title": "AUD"
              },
              {
                "const": "CAD",
                "title": "CAD"
              },
              {
                "const": "EUR",
                "title": "EUR"
              },
              {
                "const": "GBP",
                "title": "GBP"
              },
              {
                "const": "USD",
                "title": "USD"
              }
            ],
            "title": "currency\nThe currency format that the payment is in."
          },
          "terms": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string"
              }
            ],
            "title": "terms\nTerms of the payment"
          },
          "successful": {
            "type": "boolean",
            "title": "successful\nIndicates whether the payment was successfully processed"
          }
        },
        "required": [
          "external_id",
          "provider",
          "amount",
          "currency",
          "terms",
          "successful"
        ]
      },
      "ICalendly.Reconfirmation": {
        "type": "object",
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at\nWhen the reconfirmation was created."
          },
          "confirmed_at": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "date-time"
              }
            ],
            "title": "confirmed_at\nWhen the Invitee confirmed their attendance."
          }
        },
        "required": [
          "created_at",
          "confirmed_at"
        ]
      },
      "ICalendly.IGetScheduledEventInviteeOutput": {
        "type": "object",
        "properties": {
          "collection": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ICalendly.Invitee"
            }
          },
          "pagination": {
            "$ref": "#/components/schemas/ICalendly.Pagination"
          }
        },
        "required": [
          "collection",
          "pagination"
        ]
      },
      "ICalendly.IGetScheduledEventInviteeInput": {
        "type": "object",
        "properties": {
          "scheduled_event_uuid": {
            "type": "string",
            "title": "scheduled_event_uuid"
          },
          "count": {
            "type": "number",
            "minimum": 1,
            "maximum": 100,
            "default": 20,
            "title": "count\nThe number of rows to return (1 to 100)"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "email\nFilter results by email address (optional)"
          },
          "page_token": {
            "type": "string",
            "title": "page_token\nThe token to pass for pagination to get the next or previous portion of the collection"
          },
          "sort": {
            "oneOf": [
              {
                "const": "created_at:asc",
                "title": "created_at:asc"
              },
              {
                "const": "\"created_at:desc\"",
                "title": "\"created_at:desc\""
              },
              {
                "$ref": "#/components/schemas/Defaultcreated_atasc"
              }
            ],
            "title": "sort\nOrder results by the `created_at` field and direction.\nAllowed values: \"asc\" for ascending, \"desc\" for descending."
          },
          "status": {
            "oneOf": [
              {
                "const": "active",
                "title": "active"
              },
              {
                "const": "canceled",
                "title": "canceled"
              }
            ],
            "title": "status\nFilter by invitee status (either \"active\" or \"canceled\")."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "calendly",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "scheduled_event_uuid",
          "secretKey"
        ]
      },
      "Defaultcreated_atasc": {
        "type": "object",
        "properties": {
          "typia.tag": {
            "type": "object",
            "properties": {
              "target": {
                "const": "string"
              },
              "kind": {
                "const": "default"
              },
              "value": {
                "const": "created_at:asc"
              },
              "exclusive": {
                "const": true
              },
              "schema": {
                "type": "object",
                "properties": {
                  "default": {
                    "const": "created_at:asc"
                  }
                },
                "required": [
                  "default"
                ]
              }
            },
            "required": [
              "target",
              "kind",
              "value",
              "exclusive",
              "schema"
            ],
            "title": "This is a dummy property for compilation",
            "description": "This is a dummy property for compilation.\n\nIt does not mean anything in runtime."
          }
        }
      },
      "ICalendly.ICreateOneOffEventTypeOutput": {
        "type": "object",
        "properties": {
          "resource": {
            "$ref": "#/components/schemas/ICalendly.EventType",
            "title": "EventType\nA configuration for an Event"
          }
        },
        "required": [
          "resource"
        ]
      },
      "ICalendly.ICreateOneOffEventTypeInput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 55,
            "x-wrtn-placeholder": "My Meeting",
            "title": "name\nEvent type name"
          },
          "host": {
            "type": "string",
            "format": "uri",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/calendly/users/get-me",
              "jmesPath": "resource.{value:url, label:name}"
            },
            "title": "host\nHost user uri"
          },
          "co_host": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "iri"
            },
            "maxItems": 9,
            "title": "co_hosts\nCollection of meeting co-host(s) user URIs"
          },
          "duration": {
            "type": "integer",
            "minimum": 1,
            "maximum": 720,
            "title": "duration\nDuration of meeting in minutes"
          },
          "timezone": {
            "type": "string",
            "x-wrtn-placeholder": "America/New_York",
            "title": "timezone\nTime zone used for meeting. Defaults to host's time zone."
          },
          "date_setting": {
            "type": "object",
            "properties": {
              "type": {
                "const": "date_range",
                "title": "type"
              },
              "start_date": {
                "type": "string",
                "format": "date",
                "title": "start_date\nAvailability start - Must be before end_date. Format: YYYY-MM-DD"
              },
              "end_date": {
                "type": "string",
                "format": "date",
                "title": "end_date\nAvailability end - Must be a date in the future and less than 365 days in the future from start_date. Format: YYYY-MM-DD"
              }
            },
            "required": [
              "type",
              "start_date",
              "end_date"
            ],
            "title": "date_setting\nOnly allow scheduling within a specified date range"
          },
          "location": {
            "type": "object",
            "properties": {
              "kind": {
                "const": "custom",
                "title": "kind"
              },
              "location": {
                "type": "string",
                "title": "location"
              }
            },
            "required": [
              "kind",
              "location"
            ],
            "title": "location\nInformation for a Custom Location"
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "calendly",
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "host",
          "duration",
          "date_setting",
          "location",
          "secretKey"
        ]
      },
      "ICalendly.IGetUserInfoOutput": {
        "type": "object",
        "properties": {
          "resource": {
            "$ref": "#/components/schemas/ICalendly.User"
          }
        },
        "required": [
          "resource"
        ]
      },
      "ICalendly.User": {
        "type": "object",
        "properties": {
          "uri": {
            "type": "string",
            "format": "iri",
            "title": "uri\nCanonical reference (unique identifier) for the user"
          },
          "name": {
            "type": "string",
            "title": "name\nThe user's name (human-readable format)"
          },
          "slug": {
            "type": "string",
            "title": "slug\nThe portion of URL for the user's scheduling page (where invitees book sessions)"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "email\nThe user's email address"
          },
          "scheduling_url": {
            "type": "string",
            "format": "iri",
            "title": "scheduling_url\nThe URL of the user's Calendly landing page (that lists all the user's event types)"
          },
          "timezone": {
            "type": "string",
            "x-wrtn-placeholder": "Asia/Tokyo",
            "title": "timezone\nThe time zone to use when presenting time to the user"
          },
          "avatar_url": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "string",
                "format": "iri"
              }
            ],
            "title": "avatar_url\nThe URL of the user's avatar (image). Can be null."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "created_at\nThe moment when the user's record was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "updated_at\nThe moment when the user's record was last updated"
          },
          "current_organization": {
            "type": "string",
            "format": "iri",
            "title": "current_organization\nA unique reference to the user's current organization"
          },
          "resource_type": {
            "type": "string",
            "title": "resource_type\nResource type to support polymorphic associations"
          }
        },
        "required": [
          "uri",
          "name",
          "slug",
          "email",
          "scheduling_url",
          "timezone",
          "avatar_url",
          "created_at",
          "updated_at",
          "current_organization",
          "resource_type"
        ],
        "title": "user\nInformation about the user."
      },
      "IAISearch.IRequest": {
        "type": "object",
        "properties": {
          "search_query": {
            "type": "string",
            "maxLength": 100,
            "title": "Search term",
            "description": "Please enter your search term."
          }
        },
        "required": [
          "search_query"
        ],
        "title": "Conditions required for search"
      },
      "ITypeform.ICreateWorkspaceOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "Workspace id.",
            "description": "The generated workspace id."
          },
          "name": {
            "type": "string",
            "title": "Workspace name.",
            "description": "The name of the generated workspace."
          },
          "link": {
            "type": "string",
            "title": "Workspace Link.",
            "description": "Here is the generated workspace link."
          }
        },
        "required": [
          "id",
          "name",
          "link"
        ]
      },
      "ITypeform.ICreateWorkspaceInput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Workspace name.",
            "description": "The name of the workspace to be created."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "typeform",
            "x-wrtn-secret-scopes": [
              "accounts:read",
              "forms:read",
              "forms:write",
              "images:read",
              "images:write",
              "responses:read",
              "responses:write",
              "themes:read",
              "themes:write",
              "workspaces:read",
              "workspaces:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "secretKey"
        ]
      },
      "ITypeform.ISecret": {
        "type": "object",
        "properties": {
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "typeform",
            "x-wrtn-secret-scopes": [
              "accounts:read",
              "forms:read",
              "forms:write",
              "images:read",
              "images:write",
              "responses:read",
              "responses:write",
              "themes:read",
              "themes:write",
              "workspaces:read",
              "workspaces:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "secretKey"
        ]
      },
      "ITypeform.IFindWorkspaceOutput": {
        "type": "object",
        "properties": {
          "workspace_id": {
            "type": "string",
            "title": "Workspace id.",
            "description": "The id of the workspace that was read."
          },
          "name": {
            "type": "string",
            "title": "Workspace name.",
            "description": "The name of the workspace you're reading from."
          },
          "link": {
            "type": "string",
            "title": "Workspace Link.",
            "description": "Here is a link to the workspace you've read."
          }
        },
        "required": [
          "workspace_id",
          "name",
          "link"
        ]
      },
      "ITypeform.ICreateFormOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "title": "form id.",
            "description": "The id of the generated form."
          },
          "name": {
            "type": "string",
            "title": "Form name.",
            "description": "The name of the generated form."
          },
          "type": {
            "type": "string",
            "title": "Form Type.",
            "description": "The type of the generated form."
          }
        },
        "required": [
          "id",
          "name",
          "type"
        ]
      },
      "ITypeform.ICreateEmptyFormInput": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "title": "Form title.",
            "description": "The title of the form to be created."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "typeform",
            "x-wrtn-secret-scopes": [
              "accounts:read",
              "forms:read",
              "forms:write",
              "images:read",
              "images:write",
              "responses:read",
              "responses:write",
              "themes:read",
              "themes:write",
              "workspaces:read",
              "workspaces:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "name",
          "secretKey"
        ]
      },
      "ITypeform.IFindFormOutput": {
        "type": "object",
        "properties": {
          "formId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/typeform/get-forms",
              "jmesPath": "[].{value:formId, label:name || 'form title'}"
            },
            "title": "form id.",
            "description": "The id of the form being read."
          },
          "name": {
            "type": "string",
            "title": "Form name.",
            "description": "The name of the form being read."
          }
        },
        "required": [
          "formId",
          "name"
        ]
      },
      "ITypeform.IDuplicateExistingFormInput": {
        "type": "object",
        "properties": {
          "formId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/typeform/get-forms",
              "jmesPath": "[].{value:formId, label:name || 'form title'}"
            },
            "title": "form.",
            "description": "The form to update the values."
          },
          "workspaceLink": {
            "type": "string",
            "title": "Workspace Link.",
            "description": "The workspace link to duplicate the form."
          },
          "name": {
            "type": "string",
            "title": "Form name.",
            "description": "The name of the form to be cloned and created."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "typeform",
            "x-wrtn-secret-scopes": [
              "accounts:read",
              "forms:read",
              "forms:write",
              "images:read",
              "images:write",
              "responses:read",
              "responses:write",
              "themes:read",
              "themes:write",
              "workspaces:read",
              "workspaces:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "formId",
          "workspaceLink",
          "name",
          "secretKey"
        ]
      },
      "ITypeform.IFieldInfoForUpdateFieldValueOutput": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/typeform/forms/get-update-form-fields",
              "jmesPath": "[].{value:id, label:name || 'field title'}"
            },
            "title": "field",
            "description": "Field to update value"
          },
          "name": {
            "type": "string",
            "title": "Field name.",
            "description": "The name of the field whose value is to be updated."
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "ITypeform.IGetFieldForUpdateFieldValueInput": {
        "type": "object",
        "properties": {
          "formId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/typeform/get-forms",
              "jmesPath": "[].{value:formId, label:name || 'form title'}"
            },
            "title": "field id.",
            "description": "The id of the field whose value you want to update."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "typeform",
            "x-wrtn-secret-scopes": [
              "accounts:read",
              "forms:read",
              "forms:write",
              "images:read",
              "images:write",
              "responses:read",
              "responses:write",
              "themes:read",
              "themes:write",
              "workspaces:read",
              "workspaces:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "formId",
          "secretKey"
        ]
      },
      "ITypeform.IUpdateFormFieldValueOutput": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ITypeform.IFieldInformation"
            },
            "title": "Information about the field whose value has been updated.",
            "description": "Information about the field whose value has been updated."
          },
          "formId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/typeform/get-forms",
              "jmesPath": "[].{value:formId, label:name || 'form title'}"
            },
            "title": "form id.",
            "description": "The id of the form being read."
          },
          "name": {
            "type": "string",
            "title": "Form name.",
            "description": "The name of the form being read."
          }
        },
        "required": [
          "fields",
          "formId",
          "name"
        ]
      },
      "ITypeform.IFieldInformation": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "title": "field value.",
            "description": "The value of the updated field."
          },
          "id": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/typeform/forms/get-update-form-fields",
              "jmesPath": "[].{value:id, label:name || 'field title'}"
            },
            "title": "field",
            "description": "Field to update value"
          },
          "name": {
            "type": "string",
            "title": "Field name.",
            "description": "The name of the field whose value is to be updated."
          }
        },
        "required": [
          "value",
          "id",
          "name"
        ]
      },
      "ITypeform.IUpdateFormFieldValueInput": {
        "type": "object",
        "properties": {
          "formId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/typeform/get-forms",
              "jmesPath": "[].{value:formId, label:name || 'form title'}"
            },
            "title": "form.",
            "description": "The form to update the values."
          },
          "fieldId": {
            "type": "string",
            "x-wrtn-prerequisite": {
              "method": "post",
              "path": "/connector/typeform/forms/get-update-form-fields",
              "jmesPath": "[].{value:id, label:name || 'field title'}"
            },
            "title": "The field whose value is to be updated.",
            "description": "The field whose value is to be updated."
          },
          "value": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "field value.",
            "description": "The value of the field to update."
          },
          "secretKey": {
            "type": "string",
            "x-wrtn-secret-key": "typeform",
            "x-wrtn-secret-scopes": [
              "accounts:read",
              "forms:read",
              "forms:write",
              "images:read",
              "images:write",
              "responses:read",
              "responses:write",
              "themes:read",
              "themes:write",
              "workspaces:read",
              "workspaces:write"
            ],
            "title": "Select authentication information",
            "description": "secret key."
          }
        },
        "required": [
          "formId",
          "fieldId",
          "value",
          "secretKey"
        ]
      },
      "IMarp.IConvertOutput": {
        "type": "object",
        "properties": {
          "s3Link": {
            "type": "string",
            "title": "S3 link",
            "description": "S3 link for the converted PPT."
          }
        },
        "required": [
          "s3Link"
        ],
        "title": "Marp conversion output"
      },
      "IMarp.IConvertInput": {
        "type": "object",
        "properties": {
          "markdown": {
            "type": "string",
            "title": "Marp markdown",
            "description": "Marp markdown input string."
          }
        },
        "required": [
          "markdown"
        ],
        "title": "Parameters for Marp conversion"
      }
    }
  },
  "tags": [
    {
      "name": "RAG"
    },
    {
      "name": "Hwp"
    },
    {
      "name": "Excel"
    },
    {
      "name": "Google Docs"
    },
    {
      "name": "Google Sheet"
    },
    {
      "name": "Google Calendar"
    },
    {
      "name": "Google Drive"
    },
    {
      "name": "Llm",
      "description": "selection Extract selection"
    },
    {
      "name": "Gmail"
    },
    {
      "name": "Figma"
    },
    {
      "name": "Zoom"
    },
    {
      "name": "SweetTracker"
    },
    {
      "name": "Hancel"
    },
    {
      "name": "KakaoTalk"
    },
    {
      "name": "Kakao Map"
    },
    {
      "name": "Kakao Navi"
    },
    {
      "name": "Google Slide"
    },
    {
      "name": "Imweb"
    },
    {
      "name": "Open Data"
    },
    {
      "name": "Korea Eximbank"
    },
    {
      "name": "Stable Diffusion"
    },
    {
      "name": "Dall-e-3"
    },
    {
      "name": "Google Search"
    },
    {
      "name": "Wanted"
    },
    {
      "name": "Incruit"
    },
    {
      "name": "Saramin"
    },
    {
      "name": "Jumpit"
    },
    {
      "name": "Careerly"
    },
    {
      "name": "Aladin"
    },
    {
      "name": "AliExpress"
    },
    {
      "name": "Coupang"
    },
    {
      "name": "EQL"
    },
    {
      "name": "iHerb"
    },
    {
      "name": "Market Kurly"
    },
    {
      "name": "OCO"
    },
    {
      "name": "Olive Young"
    },
    {
      "name": "29CM"
    },
    {
      "name": "Uniqlo"
    },
    {
      "name": "yes24"
    },
    {
      "name": "Musinsa"
    },
    {
      "name": "Google Ads"
    },
    {
      "name": "Arxiv"
    },
    {
      "name": "Daum"
    },
    {
      "name": "Naver"
    },
    {
      "name": "Youtube"
    },
    {
      "name": "Google Scholar"
    },
    {
      "name": "CSV"
    },
    {
      "name": "Notion"
    },
    {
      "name": "Google Hotel"
    },
    {
      "name": "Search Airport Information"
    },
    {
      "name": "Google Flight"
    },
    {
      "name": "Slack"
    },
    {
      "name": "Jira"
    },
    {
      "name": "Google Trends"
    },
    {
      "name": "Google Map"
    },
    {
      "name": "Github"
    },
    {
      "name": "Discord"
    },
    {
      "name": "Calendly"
    },
    {
      "name": "AI Search"
    },
    {
      "name": "Typeform"
    },
    {
      "name": "Marp"
    },
    {
      "name": "pptx"
    },
    {
      "name": "hanshow"
    },
    {
      "name": "ppt"
    },
    {
      "name": "powerpoint"
    },
    {
      "name": "markdown"
    },
    {
      "name": "marp"
    }
  ],
  "x-samchon-emended": true
}